from typing import Any, List, Optional

from loguru import logger
from universal_mcp.applications import APIApplication
from universal_mcp.integrations import Integration


class GithubApp(APIApplication):
    def __init__(self, integration: Integration) -> None:
        super().__init__(name="github", integration=integration)
        self.base_api_url = "https://api.github.com/repos"
        self.base_url = "https://api.github.com"

    def _get_headers(self):
        if not self.integration:
            raise ValueError("Integration not configured")
        credentials = self.integration.get_credentials()
        if "headers" in credentials:
            return credentials["headers"]
        return {
            "Authorization": f"Bearer {credentials['access_token']}",
            "Accept": "application/vnd.github.v3+json",
        }

    def star_repository(self, repo_full_name: str) -> str:
        """
        Stars a GitHub repository using the GitHub API and returns a status message.

        Args:
            repo_full_name: The full name of the repository in 'owner/repo' format (e.g., 'octocat/Hello-World')

        Returns:
            A string message indicating whether the starring operation was successful, the repository was not found, or an error occurred

        Raises:
            RequestException: If there are network connectivity issues or API request failures
            ValueError: If the repository name format is invalid

        Tags:
            star, github, api, action, social, repository, important
        """
        url = f"https://api.github.com/user/starred/{repo_full_name}"
        response = self._put(url, data={})
        if response.status_code == 204:
            return f"Successfully starred repository {repo_full_name}"
        elif response.status_code == 404:
            return f"Repository {repo_full_name} not found"
        else:
            logger.error(response.text)
            return f"Error starring repository: {response.text}"

    def list_commits(self, repo_full_name: str) -> str:
        """
        Retrieves and formats a list of recent commits from a GitHub repository

        Args:
            repo_full_name: The full name of the repository in 'owner/repo' format

        Returns:
            A formatted string containing the most recent 12 commits, including commit hash, message, and author

        Raises:
            requests.exceptions.HTTPError: When the GitHub API request fails (e.g., repository not found, rate limit exceeded)
            requests.exceptions.RequestException: When network issues or other request-related problems occur

        Tags:
            list, read, commits, github, history, api, important
        """
        repo_full_name = repo_full_name.strip()
        url = f"{self.base_api_url}/{repo_full_name}/commits"
        response = self._get(url)
        response.raise_for_status()
        commits = response.json()
        if not commits:
            return f"No commits found for repository {repo_full_name}"
        result = f"Recent commits for {repo_full_name}:\n\n"
        for commit in commits[:12]:  # Limit to 12 commits
            sha = commit.get("sha", "")[:7]
            message = commit.get("commit", {}).get("message", "").split("\n")[0]
            author = commit.get("commit", {}).get("author", {}).get("name", "Unknown")

            result += f"- {sha}: {message} (by {author})\n"
        return result

    def list_branches(self, repo_full_name: str) -> str:
        """
        Lists all branches for a specified GitHub repository and returns them in a formatted string representation.

        Args:
            repo_full_name: The full name of the repository in 'owner/repo' format (e.g., 'octocat/Hello-World')

        Returns:
            A formatted string containing the list of branches, or a message indicating no branches were found

        Raises:
            HTTPError: When the GitHub API request fails (e.g., repository not found, authentication error)
            RequestException: When there are network connectivity issues or API communication problems

        Tags:
            list, branches, github, read, api, repository, important
        """
        repo_full_name = repo_full_name.strip()
        url = f"{self.base_api_url}/{repo_full_name}/branches"
        response = self._get(url)
        response.raise_for_status()
        branches = response.json()
        if not branches:
            return f"No branches found for repository {repo_full_name}"
        result = f"Branches for {repo_full_name}:\n\n"
        for branch in branches:
            branch_name = branch.get("name", "Unknown")
            result += f"- {branch_name}\n"
        return result

    def list_pull_requests(self, repo_full_name: str, state: str = "open") -> str:
        """
        Retrieves and formats a list of pull requests for a specified GitHub repository.

        Args:
            repo_full_name: The full name of the repository in the format 'owner/repo' (e.g., 'tensorflow/tensorflow')
            state: Filter for pull request state. Can be 'open', 'closed', or 'all'. Defaults to 'open'

        Returns:
            A formatted string containing the list of pull requests, including PR number, title, author, and status. Returns a message if no pull requests are found.

        Raises:
            HTTPError: Raised when the GitHub API request fails (e.g., invalid repository name, rate limiting, or authentication issues)

        Tags:
            list, pull-request, github, api, read, important, fetch, query
        """
        repo_full_name = repo_full_name.strip()
        url = f"{self.base_api_url}/{repo_full_name}/pulls"
        params = {"state": state}
        response = self._get(url, params=params)
        response.raise_for_status()
        pull_requests = response.json()
        if not pull_requests:
            return f"No pull requests found for repository {repo_full_name} with state '{state}'"
        result = f"Pull requests for {repo_full_name} (State: {state}):\n\n"
        for pr in pull_requests:
            pr_title = pr.get("title", "No Title")
            pr_number = pr.get("number", "Unknown")
            pr_state = pr.get("state", "Unknown")
            pr_user = pr.get("user", {}).get("login", "Unknown")

            result += (
                f"- PR #{pr_number}: {pr_title} (by {pr_user}, Status: {pr_state})\n"
            )
        return result

    def list_issues(
        self,
        repo_full_name: str,
        state: str = "open",
        assignee: str = None,
        labels: str = None,
        per_page: int = 30,
        page: int = 1,
    ) -> list[dict[str, Any]]:
        """
        Retrieves a list of issues from a specified GitHub repository with optional filtering parameters.

        Args:
            repo_full_name: The full name of the repository in 'owner/repo' format
            state: Filter issues by state ('open', 'closed', 'all'). Defaults to 'open'
            assignee: Filter by assignee username. Use 'none' for unassigned issues, '*' for assigned issues
            labels: Comma-separated string of label names to filter by (e.g., 'bug,ui,@high')
            per_page: Number of results per page (max 100). Defaults to 30
            page: Page number for pagination. Defaults to 1

        Returns:
            List of dictionaries containing issue data from the GitHub API response

        Raises:
            HTTPError: When the GitHub API request fails (e.g., invalid repository name, authentication failure)
            RequestException: When there are network connectivity issues or other request-related problems

        Tags:
            list, issues, github, api, read, filter, pagination, important, project-management
        """
        repo_full_name = repo_full_name.strip()
        url = f"{self.base_api_url}/{repo_full_name}/issues"
        params = {"state": state, "per_page": per_page, "page": page}
        if assignee:
            params["assignee"] = assignee
        if labels:
            params["labels"] = labels
        response = self._get(url, params=params)
        response.raise_for_status()
        return response.json()

    def get_pull_request(self, repo_full_name: str, pull_number: int) -> str:
        """
        Retrieves and formats detailed information about a specific GitHub pull request from a repository

        Args:
            repo_full_name: The full repository name in 'owner/repo' format (e.g., 'octocat/Hello-World')
            pull_number: The numeric identifier of the pull request to retrieve

        Returns:
            A formatted string containing pull request details including title, creator, status, and description

        Raises:
            HTTPError: Raised when the GitHub API request fails (e.g., invalid repository name, non-existent PR number, or authentication issues)
            RequestException: Raised when there are network connectivity issues or other request-related problems

        Tags:
            get, read, github, pull-request, api, fetch, format, important
        """
        repo_full_name = repo_full_name.strip()
        url = f"{self.base_api_url}/{repo_full_name}/pulls/{pull_number}"
        response = self._get(url)
        response.raise_for_status()
        pr = response.json()
        pr_title = pr.get("title", "No Title")
        pr_number = pr.get("number", "Unknown")
        pr_state = pr.get("state", "Unknown")
        pr_user = pr.get("user", {}).get("login", "Unknown")
        pr_body = pr.get("body", "No description provided.")
        result = (
            f"Pull Request #{pr_number}: {pr_title}\n"
            f"Created by: {pr_user}\n"
            f"Status: {pr_state}\n"
            f"Description: {pr_body}\n"
        )
        return result

    def create_pull_request(
        self,
        repo_full_name: str,
        head: str,
        base: str,
        title: str = None,
        body: str = None,
        issue: int = None,
        maintainer_can_modify: bool = True,
        draft: bool = False,
    ) -> dict[str, Any]:
        """
        Creates a new pull request in a GitHub repository, optionally converting an existing issue into a pull request.

        Args:
            repo_full_name: The full name of the repository (e.g. 'owner/repo')
            head: The name of the branch where your changes are implemented
            base: The name of the branch you want the changes pulled into
            title: The title of the new pull request (required if issue is not specified)
            body: The contents of the pull request
            issue: An issue number to convert to a pull request. If specified, the issue's title, body, and comments will be used
            maintainer_can_modify: Indicates whether maintainers can modify the pull request
            draft: Indicates whether the pull request is a draft

        Returns:
            A dictionary containing the complete GitHub API response

        Raises:
            ValueError: Raised when neither 'title' nor 'issue' parameter is specified
            HTTPError: Raised when the GitHub API request fails

        Tags:
            create, pull-request, github, api, write, important
        """
        repo_full_name = repo_full_name.strip()
        url = f"{self.base_api_url}/{repo_full_name}/pulls"
        pull_request_data = {
            "head": head,
            "base": base,
            "maintainer_can_modify": maintainer_can_modify,
            "draft": draft,
        }
        if issue is not None:
            pull_request_data["issue"] = issue
        else:
            if title is None:
                raise ValueError("Either 'title' or 'issue' must be specified")
            pull_request_data["title"] = title
            if body is not None:
                pull_request_data["body"] = body
        response = self._post(url, pull_request_data)
        response.raise_for_status()
        return response.json()

    def create_issue(
        self, repo_full_name: str, title: str, body: str = "", labels=None
    ) -> str:
        """
        Creates a new issue in a specified GitHub repository with a title, body content, and optional labels.

        Args:
            repo_full_name: The full name of the repository in 'owner/repo' format
            title: The title of the issue
            body: The contents/description of the issue (defaults to empty string)
            labels: Labels to associate with the issue, as a comma-separated string or list. Only users with push access can set labels

        Returns:
            A string containing a confirmation message with the issue number, title, and URL

        Raises:
            HTTPError: When the GitHub API request fails (e.g., invalid repository name, authentication issues, or insufficient permissions)

        Tags:
            create, issues, github, api, project-management, write, important
        """
        repo_full_name = repo_full_name.strip()
        url = f"{self.base_api_url}/{repo_full_name}/issues"
        issue_data = {"title": title, "body": body}
        if labels:
            if isinstance(labels, str):
                labels_list = [
                    label.strip() for label in labels.split(",") if label.strip()
                ]
                issue_data["labels"] = labels_list
            else:
                issue_data["labels"] = labels
        response = self._post(url, issue_data)
        response.raise_for_status()
        issue = response.json()
        issue_number = issue.get("number", "Unknown")
        issue_url = issue.get("html_url", "")
        return (
            f"Successfully created issue #{issue_number}:\n"
            f"Title: {title}\n"
            f"URL: {issue_url}"
        )

    def list_repo_activities(
        self, repo_full_name: str, direction: str = "desc", per_page: int = 30
    ) -> str:
        """
        Retrieves and formats a list of activities for a specified GitHub repository.

        Args:
            repo_full_name: The full name of the repository in 'owner/repo' format
            direction: The sort direction for results ('asc' or 'desc'). Defaults to 'desc'
            per_page: Number of activities to return per page (1-100). Defaults to 30

        Returns:
            A formatted string containing a list of repository activities, including timestamps and actor names. Returns a 'No activities' message if no activities are found.

        Raises:
            HTTPError: Raised when the GitHub API request fails
            ValueError: May be raised if repo_full_name is invalid or empty after stripping

        Tags:
            list, activity, github, read, events, api, query, format
        """
        repo_full_name = repo_full_name.strip()
        url = f"{self.base_api_url}/{repo_full_name}/activity"
        params = {"direction": direction, "per_page": per_page}
        response = self._get(url, params=params)
        response.raise_for_status()
        activities = response.json()
        if not activities:
            return f"No activities found for repository {repo_full_name}"
        result = f"Repository activities for {repo_full_name}:\n\n"
        for activity in activities:
            # Extract common fields
            timestamp = activity.get("timestamp", "Unknown time")
            actor_name = "Unknown user"
            if "actor" in activity and activity["actor"]:
                actor_name = activity["actor"].get("login", "Unknown user")

            # Create a simple description of the activity
            result += f"- {actor_name} performed an activity at {timestamp}\n"
        return result

    def update_issue(
        self,
        repo_full_name: str,
        issue_number: int,
        title: str = None,
        body: str = None,
        assignee: str = None,
        state: str = None,
        state_reason: str = None,
    ) -> dict[str, Any]:
        """
        Updates an existing GitHub issue with specified parameters including title, body, assignee, state, and state reason.

        Args:
            repo_full_name: The full name of the repository in 'owner/repo' format
            issue_number: The unique identifier number of the issue to update
            title: The new title of the issue (optional)
            body: The new content/description of the issue (optional)
            assignee: GitHub username to assign to the issue (optional)
            state: The desired state of the issue ('open' or 'closed') (optional)
            state_reason: The reason for state change ('completed', 'not_planned', 'reopened', or null) (optional)

        Returns:
            A dictionary containing the complete GitHub API response with updated issue details

        Raises:
            HTTPError: Raised when the GitHub API request fails (e.g., invalid repository, non-existent issue, insufficient permissions)
            RequestException: Raised when there's a network error or API connectivity issue

        Tags:
            github, issues, update, api, project-management, write, important
        """
        url = f"{self.base_api_url}/{repo_full_name}/issues/{issue_number}"
        update_data = {}
        if title is not None:
            update_data["title"] = title
        if body is not None:
            update_data["body"] = body
        if assignee is not None:
            update_data["assignee"] = assignee
        if state is not None:
            update_data["state"] = state
        if state_reason is not None:
            update_data["state_reason"] = state_reason
        response = self._patch(url, update_data)
        response.raise_for_status()
        return response.json()

    def meta_root(self) -> dict[str, Any]:
        """
        Retrieves data or information from the root resource using the "GET" method at the path "/".

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            meta
        """
        url = f"{self.base_url}/"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_advisories(self, ghsa_id: Optional[str] = None, type: Optional[str] = None, cve_id: Optional[str] = None, ecosystem: Optional[str] = None, severity: Optional[str] = None, cwes: Optional[Any] = None, is_withdrawn: Optional[bool] = None, affects: Optional[Any] = None, published: Optional[str] = None, updated: Optional[str] = None, modified: Optional[str] = None, epss_percentage: Optional[str] = None, epss_percentile: Optional[str] = None, before: Optional[str] = None, after: Optional[str] = None, direction: Optional[str] = None, per_page: Optional[int] = None, sort: Optional[str] = None) -> list[Any]:
        """
        Retrieves global security advisories from GitHub's database, filtered by parameters such as GHSA ID, CVE ID, severity, ecosystem, and publication date.

        Args:
            ghsa_id (string): If specified, only advisories with this GHSA (GitHub Security Advisory) identifier will be returned.
            type (string): If specified, only advisories of this type will be returned. By default, a request with no other parameters defined will only return reviewed advisories that are not malware.
            cve_id (string): If specified, only advisories with this CVE (Common Vulnerabilities and Exposures) identifier will be returned.
            ecosystem (string): If specified, only advisories for these ecosystems will be returned.
            severity (string): If specified, only advisories with these severities will be returned.
            cwes (string): If specified, only advisories with these Common Weakness Enumerations (CWEs) will be returned. Example: `cwes=79,284,22` or `cwes[]=79&cwes[]=284&cwes[]=22`
            is_withdrawn (boolean): Whether to only return advisories that have been withdrawn.
            affects (string): If specified, only return advisories that affect any of `package` or `package@version`. A maximum of 1000 packages can be specified.
        If the query parameter causes the URL to exceed the maximum URL length supported by your client, you must specify fewer packages. Example: `affects=package1,package2@1.0.0,package3@^2.0.0` or `affects[]=package1&affects[]=package2@1.0.0`
            published (string): If specified, only return advisories that were published on a date or date range. For more information on the syntax of the date range, see "[Understanding the search syntax](
            updated (string): If specified, only return advisories that were updated on a date or date range. For more information on the syntax of the date range, see "[Understanding the search syntax](
            modified (string): If specified, only show advisories that were updated or published on a date or date range. For more information on the syntax of the date range, see "[Understanding the search syntax](
            epss_percentage (string): If specified, only return advisories that have an EPSS percentage score that matches the provided value.
        The EPSS percentage represents the likelihood of a CVE being exploited.
            epss_percentile (string): If specified, only return advisories that have an EPSS percentile score that matches the provided value.
        The EPSS percentile represents the relative rank of the CVE's likelihood of being exploited compared to other CVEs.
            before (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            after (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            direction (string): The direction to sort the results by.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](
            sort (string): The property to sort the results by.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            security-advisories
        """
        url = f"{self.base_url}/advisories"
        query_params = {k: v for k, v in [('ghsa_id', ghsa_id), ('type', type), ('cve_id', cve_id), ('ecosystem', ecosystem), ('severity', severity), ('cwes', cwes), ('is_withdrawn', is_withdrawn), ('affects', affects), ('published', published), ('updated', updated), ('modified', modified), ('epss_percentage', epss_percentage), ('epss_percentile', epss_percentile), ('before', before), ('after', after), ('direction', direction), ('per_page', per_page), ('sort', sort)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_advisory_by_id(self, ghsa_id: str) -> dict[str, Any]:
        """
        Retrieves details of a specific global security advisory using its GitHub Security Advisory (GHSA) identifier.

        Args:
            ghsa_id (string): ghsa_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            security-advisories
        """
        if ghsa_id is None:
            raise ValueError("Missing required parameter 'ghsa_id'.")
        url = f"{self.base_url}/advisories/{ghsa_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def apps_get_authenticated(self) -> dict[str, Any]:
        """
        Retrieves data from the application at the "/app" path using the GET method.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        url = f"{self.base_url}/app"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def apps_create_from_manifest(self, code: str) -> Any:
        """
        Converts a specific app manifest identified by the code using the POST method and returns a successful creation status.

        Args:
            code (string): code

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        if code is None:
            raise ValueError("Missing required parameter 'code'.")
        request_body_data = None
        url = f"{self.base_url}/app-manifests/{code}/conversions"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_app_hook_config(self) -> dict[str, Any]:
        """
        Retrieves the configuration for an application hook using the GET method at the "/app/hook/config" endpoint.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        url = f"{self.base_url}/app/hook/config"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_hook_config(self, url: Optional[str] = None, content_type: Optional[str] = None, secret: Optional[str] = None, insecure_ssl: Optional[Any] = None) -> dict[str, Any]:
        """
        Updates the configuration of an application hook using PATCH and returns a status message upon success.

        Args:
            url (string): The URL to which the payloads will be delivered. Example: 'https://example.com/webhook'.
            content_type (string): The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`. Example: '"json"'.
            secret (string): If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers). Example: '"********"'.
            insecure_ssl (string): insecure_ssl Example: '0'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        request_body_data = None
        request_body_data = {
            'url': url,
            'content_type': content_type,
            'secret': secret,
            'insecure_ssl': insecure_ssl,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/app/hook/config"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def apps_list_webhook_deliveries(self, per_page: Optional[int] = None, cursor: Optional[str] = None) -> list[Any]:
        """
        Retrieves a list of webhook deliveries with pagination support via per-page and cursor parameters.

        Args:
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            cursor (string): Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        url = f"{self.base_url}/app/hook/deliveries"
        query_params = {k: v for k, v in [('per_page', per_page), ('cursor', cursor)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def apps_get_webhook_delivery(self, delivery_id: str) -> dict[str, Any]:
        """
        Retrieves a specific delivery record by its unique ID from a webhook's delivery history.

        Args:
            delivery_id (string): delivery_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        if delivery_id is None:
            raise ValueError("Missing required parameter 'delivery_id'.")
        url = f"{self.base_url}/app/hook/deliveries/{delivery_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def add_delivery_attempt(self, delivery_id: str) -> dict[str, Any]:
        """
        Registers an attempt for a specific delivery using the "POST" method at the path "/app/hook/deliveries/{delivery_id}/attempts".

        Args:
            delivery_id (string): delivery_id

        Returns:
            dict[str, Any]: Accepted

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        if delivery_id is None:
            raise ValueError("Missing required parameter 'delivery_id'.")
        request_body_data = None
        url = f"{self.base_url}/app/hook/deliveries/{delivery_id}/attempts"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_installation_requests(self, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of application installation requests.

        Args:
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: List of integration installation requests

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        url = f"{self.base_url}/app/installation-requests"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def apps_list_installations(self, per_page: Optional[int] = None, page: Optional[int] = None, since: Optional[str] = None, outdated: Optional[str] = None) -> list[Any]:
        """
        Retrieves a list of installations for an application, allowing filtering by page, per page results, since a specific time, and whether installations are outdated, using the GET method at the "/app/installations" endpoint.

        Args:
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            since (string): Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            outdated (string): Determines whether to include outdated installations in the results (deprecated).

        Returns:
            list[Any]: The permissions the installation has are included under the `permissions` key.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        url = f"{self.base_url}/app/installations"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page), ('since', since), ('outdated', outdated)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def apps_get_installation(self, installation_id: str) -> dict[str, Any]:
        """
        Retrieves information about a specific GitHub App installation by its ID using the GitHub API.

        Args:
            installation_id (string): installation_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        if installation_id is None:
            raise ValueError("Missing required parameter 'installation_id'.")
        url = f"{self.base_url}/app/installations/{installation_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def apps_delete_installation(self, installation_id: str) -> Any:
        """
        Deletes a GitHub App installation identified by the `installation_id` using the GitHub API and returns a status message when successful.

        Args:
            installation_id (string): installation_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        if installation_id is None:
            raise ValueError("Missing required parameter 'installation_id'.")
        url = f"{self.base_url}/app/installations/{installation_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_access_token(self, installation_id: str, repositories: Optional[List[str]] = None, repository_ids: Optional[List[int]] = None, permissions: Optional[dict[str, Any]] = None) -> dict[str, Any]:
        """
        Generates an installation access token for a GitHub App at a specified installation ID using the POST method, allowing authentication for actions within that installation.

        Args:
            installation_id (string): installation_id
            repositories (array): List of repository names that the token should have access to Example: ['Hello-World'].
            repository_ids (array): List of repository IDs that the token should have access to Example: '[1]'.
            permissions (object): The permissions granted to the user access token. Example: "{'contents': 'read', 'issues': 'read', 'deployments': 'write', 'single_file': 'read'}".

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        if installation_id is None:
            raise ValueError("Missing required parameter 'installation_id'.")
        request_body_data = None
        request_body_data = {
            'repositories': repositories,
            'repository_ids': repository_ids,
            'permissions': permissions,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/app/installations/{installation_id}/access_tokens"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def apps_suspend_installation(self, installation_id: str) -> Any:
        """
        Suspends a GitHub App installation using the GitHub API, blocking the app's access to resources owned by the installation account.

        Args:
            installation_id (string): installation_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        if installation_id is None:
            raise ValueError("Missing required parameter 'installation_id'.")
        request_body_data = None
        url = f"{self.base_url}/app/installations/{installation_id}/suspended"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def apps_unsuspend_installation(self, installation_id: str) -> Any:
        """
        Removes a GitHub App installation suspension using the GitHub API and returns a status code indicating success or failure.

        Args:
            installation_id (string): installation_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        if installation_id is None:
            raise ValueError("Missing required parameter 'installation_id'.")
        url = f"{self.base_url}/app/installations/{installation_id}/suspended"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def apps_delete_authorization(self, client_id: str, access_token: str) -> Any:
        """
        Revokes an application's OAuth grant and deletes associated user tokens for a GitHub application.

        Args:
            client_id (string): client_id
            access_token (string): The OAuth access token used to authenticate to the GitHub API. Example: 'e72e16c7e42f292c6912e7710c838347ae178b4a'.

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        if client_id is None:
            raise ValueError("Missing required parameter 'client_id'.")
        request_body_data = {
            'access_token': access_token,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/applications/{client_id}/grant"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def apps_check_token(self, client_id: str, access_token: str) -> dict[str, Any]:
        """
        Issues a token for a specified client application using the POST method at "/applications/{client_id}/token", returning a response based on the client's authentication status.

        Args:
            client_id (string): client_id
            access_token (string): The access_token of the OAuth or GitHub application. Example: 'e72e16c7e42f292c6912e7710c838347ae178b4a'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        if client_id is None:
            raise ValueError("Missing required parameter 'client_id'.")
        request_body_data = None
        request_body_data = {
            'access_token': access_token,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/applications/{client_id}/token"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def apps_reset_token(self, client_id: str, access_token: str) -> dict[str, Any]:
        """
        Updates the token configuration for a specified client application using the OAuth 2.0 framework and returns the operation status.

        Args:
            client_id (string): client_id
            access_token (string): The access_token of the OAuth or GitHub application. Example: 'e72e16c7e42f292c6912e7710c838347ae178b4a'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        if client_id is None:
            raise ValueError("Missing required parameter 'client_id'.")
        request_body_data = None
        request_body_data = {
            'access_token': access_token,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/applications/{client_id}/token"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def apps_delete_token(self, client_id: str, access_token: str) -> Any:
        """
        Deletes an application token by client ID using the DELETE method, returning a successful response with a 204 status code if the operation is completed without content.

        Args:
            client_id (string): client_id
            access_token (string): The OAuth access token used to authenticate to the GitHub API. Example: 'e72e16c7e42f292c6912e7710c838347ae178b4a'.

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        if client_id is None:
            raise ValueError("Missing required parameter 'client_id'.")
        request_body_data = {
            'access_token': access_token,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/applications/{client_id}/token"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def apps_scope_token(self, client_id: str, access_token: str, target: Optional[str] = None, target_id: Optional[int] = None, repositories: Optional[List[str]] = None, repository_ids: Optional[List[int]] = None, permissions: Optional[dict[str, Any]] = None) -> dict[str, Any]:
        """
        Generates a scoped access token for a specified client application with the provided client ID.

        Args:
            client_id (string): client_id
            access_token (string): The access token used to authenticate to the GitHub API. Example: 'e72e16c7e42f292c6912e7710c838347ae178b4a'.
            target (string): The name of the user or organization to scope the user access token to. **Required** unless `target_id` is specified. Example: 'octocat'.
            target_id (integer): The ID of the user or organization to scope the user access token to. **Required** unless `target` is specified. Example: '1'.
            repositories (array): The list of repository names to scope the user access token to. `repositories` may not be specified if `repository_ids` is specified.
            repository_ids (array): The list of repository IDs to scope the user access token to. `repository_ids` may not be specified if `repositories` is specified. Example: '[1]'.
            permissions (object): The permissions granted to the user access token. Example: "{'contents': 'read', 'issues': 'read', 'deployments': 'write', 'single_file': 'read'}".

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        if client_id is None:
            raise ValueError("Missing required parameter 'client_id'.")
        request_body_data = None
        request_body_data = {
            'access_token': access_token,
            'target': target,
            'target_id': target_id,
            'repositories': repositories,
            'repository_ids': repository_ids,
            'permissions': permissions,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/applications/{client_id}/token/scoped"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def apps_get_by_slug(self, app_slug: str) -> dict[str, Any]:
        """
        Retrieves details for the specified application using its unique app slug identifier.

        Args:
            app_slug (string): app_slug

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        if app_slug is None:
            raise ValueError("Missing required parameter 'app_slug'.")
        url = f"{self.base_url}/apps/{app_slug}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def classroom_get_an_assignment(self, assignment_id: str) -> dict[str, Any]:
        """
        Retrieves the details of a specific assignment using the provided assignment ID.

        Args:
            assignment_id (string): assignment_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            classroom
        """
        if assignment_id is None:
            raise ValueError("Missing required parameter 'assignment_id'.")
        url = f"{self.base_url}/assignments/{assignment_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_accepted_assignments_by_id(self, assignment_id: str, page: Optional[int] = None, per_page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of accepted assignments for a specified assignment using pagination control.

        Args:
            assignment_id (string): assignment_id
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            classroom
        """
        if assignment_id is None:
            raise ValueError("Missing required parameter 'assignment_id'.")
        url = f"{self.base_url}/assignments/{assignment_id}/accepted_assignments"
        query_params = {k: v for k, v in [('page', page), ('per_page', per_page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_assignment_grades(self, assignment_id: str) -> list[Any]:
        """
        Retrieves the grades associated with a specific assignment using the provided assignment ID and returns the grade data.

        Args:
            assignment_id (string): assignment_id

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            classroom
        """
        if assignment_id is None:
            raise ValueError("Missing required parameter 'assignment_id'.")
        url = f"{self.base_url}/assignments/{assignment_id}/grades"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def classroom_list_classrooms(self, page: Optional[int] = None, per_page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of classroom resources with support for page size and number parameters.

        Args:
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            classroom
        """
        url = f"{self.base_url}/classrooms"
        query_params = {k: v for k, v in [('page', page), ('per_page', per_page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def classroom_get_a_classroom(self, classroom_id: str) -> dict[str, Any]:
        """
        Retrieves details for a specific classroom using its unique identifier in the API.

        Args:
            classroom_id (string): classroom_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            classroom
        """
        if classroom_id is None:
            raise ValueError("Missing required parameter 'classroom_id'.")
        url = f"{self.base_url}/classrooms/{classroom_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_classroom_assignments(self, classroom_id: str, page: Optional[int] = None, per_page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of assignments for a specified classroom, allowing for pagination by page and per-page parameters.

        Args:
            classroom_id (string): classroom_id
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            classroom
        """
        if classroom_id is None:
            raise ValueError("Missing required parameter 'classroom_id'.")
        url = f"{self.base_url}/classrooms/{classroom_id}/assignments"
        query_params = {k: v for k, v in [('page', page), ('per_page', per_page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_codes_of_conduct(self) -> list[Any]:
        """
        Retrieves a list of GitHub's codes of conduct using the GitHub REST API.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codes-of-conduct
        """
        url = f"{self.base_url}/codes_of_conduct"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_conduct_by_key(self, key: str) -> dict[str, Any]:
        """
        Retrieves a specific code of conduct identified by the "key" parameter using the "GET" method.

        Args:
            key (string): key

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codes-of-conduct
        """
        if key is None:
            raise ValueError("Missing required parameter 'key'.")
        url = f"{self.base_url}/codes_of_conduct/{key}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def credentials_revoke(self, credentials: List[str]) -> dict[str, Any]:
        """
        Revokes a list of credentials by submitting them using the POST method to the "/credentials/revoke" endpoint.

        Args:
            credentials (array): A list of credentials to be revoked, up to 1000 per request. Example: ['ghp_1234567890abcdef1234567890abcdef12345678', 'ghp_abcdef1234567890abcdef1234567890abcdef12'].

        Returns:
            dict[str, Any]: Accepted

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            credentials
        """
        request_body_data = None
        request_body_data = {
            'credentials': credentials,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/credentials/revoke"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def emojis_get(self) -> dict[str, Any]:
        """
        Retrieves a list of emojis using the "GET" method at the "/emojis" path and returns the result with a status message.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            emojis
        """
        url = f"{self.base_url}/emojis"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def fetch_enterprise_code_sec_config(self, enterprise: str, per_page: Optional[int] = None, before: Optional[str] = None, after: Optional[str] = None) -> list[Any]:
        """
        Retrieves a paginated list of code security configurations available for an enterprise using the GitHub API.

        Args:
            enterprise (string): enterprise
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](
            before (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            after (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-security
        """
        if enterprise is None:
            raise ValueError("Missing required parameter 'enterprise'.")
        url = f"{self.base_url}/enterprises/{enterprise}/code-security/configurations"
        query_params = {k: v for k, v in [('per_page', per_page), ('before', before), ('after', after)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_code_security_config(self, enterprise: str, name: str, description: str, advanced_security: Optional[str] = None, dependency_graph: Optional[str] = None, dependency_graph_autosubmit_action: Optional[str] = None, dependency_graph_autosubmit_action_options: Optional[dict[str, Any]] = None, dependabot_alerts: Optional[str] = None, dependabot_security_updates: Optional[str] = None, code_scanning_default_setup: Optional[str] = None, code_scanning_default_setup_options: Optional[dict[str, Any]] = None, code_scanning_delegated_alert_dismissal: Optional[str] = None, secret_scanning: Optional[str] = None, secret_scanning_push_protection: Optional[str] = None, secret_scanning_validity_checks: Optional[str] = None, secret_scanning_non_provider_patterns: Optional[str] = None, secret_scanning_generic_secrets: Optional[str] = None, secret_scanning_delegated_alert_dismissal: Optional[str] = None, private_vulnerability_reporting: Optional[str] = None, enforcement: Optional[str] = None) -> dict[str, Any]:
        """
        Creates a custom code security configuration for an enterprise with specified security settings.

        Args:
            enterprise (string): enterprise
            name (string): The name of the code security configuration. Must be unique within the enterprise. Example: 'High rish settings'.
            description (string): A description of the code security configuration Example: 'This is a code security configuration for octo-enterprise'.
            advanced_security (string): The enablement status of GitHub Advanced Security features. `enabled` will enable both Code Security and Secret Protection features. Example: 'enabled'.
            dependency_graph (string): The enablement status of Dependency Graph
            dependency_graph_autosubmit_action (string): The enablement status of Automatic dependency submission
            dependency_graph_autosubmit_action_options (object): Feature options for Automatic dependency submission
            dependabot_alerts (string): The enablement status of Dependabot alerts Example: 'enabled'.
            dependabot_security_updates (string): The enablement status of Dependabot security updates Example: 'not_set'.
            code_scanning_default_setup (string): The enablement status of code scanning default setup
            code_scanning_default_setup_options (object): Feature options for code scanning default setup
            code_scanning_delegated_alert_dismissal (string): The enablement status of code scanning delegated alert dismissal
            secret_scanning (string): The enablement status of secret scanning Example: 'enabled'.
            secret_scanning_push_protection (string): The enablement status of secret scanning push protection
            secret_scanning_validity_checks (string): The enablement status of secret scanning validity checks
            secret_scanning_non_provider_patterns (string): The enablement status of secret scanning non provider patterns
            secret_scanning_generic_secrets (string): The enablement status of Copilot secret scanning
            secret_scanning_delegated_alert_dismissal (string): The enablement status of secret scanning delegated alert dismissal
            private_vulnerability_reporting (string): The enablement status of private vulnerability reporting
            enforcement (string): The enforcement status for a security configuration

        Returns:
            dict[str, Any]: Successfully created code security configuration

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-security
        """
        if enterprise is None:
            raise ValueError("Missing required parameter 'enterprise'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'description': description,
            'advanced_security': advanced_security,
            'dependency_graph': dependency_graph,
            'dependency_graph_autosubmit_action': dependency_graph_autosubmit_action,
            'dependency_graph_autosubmit_action_options': dependency_graph_autosubmit_action_options,
            'dependabot_alerts': dependabot_alerts,
            'dependabot_security_updates': dependabot_security_updates,
            'code_scanning_default_setup': code_scanning_default_setup,
            'code_scanning_default_setup_options': code_scanning_default_setup_options,
            'code_scanning_delegated_alert_dismissal': code_scanning_delegated_alert_dismissal,
            'secret_scanning': secret_scanning,
            'secret_scanning_push_protection': secret_scanning_push_protection,
            'secret_scanning_validity_checks': secret_scanning_validity_checks,
            'secret_scanning_non_provider_patterns': secret_scanning_non_provider_patterns,
            'secret_scanning_generic_secrets': secret_scanning_generic_secrets,
            'secret_scanning_delegated_alert_dismissal': secret_scanning_delegated_alert_dismissal,
            'private_vulnerability_reporting': private_vulnerability_reporting,
            'enforcement': enforcement,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/enterprises/{enterprise}/code-security/configurations"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_enterprise_security_defaults(self, enterprise: str) -> list[Any]:
        """
        Retrieves the default code security configuration for an enterprise using the GitHub API.

        Args:
            enterprise (string): enterprise

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-security
        """
        if enterprise is None:
            raise ValueError("Missing required parameter 'enterprise'.")
        url = f"{self.base_url}/enterprises/{enterprise}/code-security/configurations/defaults"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_enterprise_config(self, enterprise: str, configuration_id: str) -> dict[str, Any]:
        """
        Retrieves details of a specific code security configuration for a GitHub enterprise.

        Args:
            enterprise (string): enterprise
            configuration_id (string): configuration_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-security
        """
        if enterprise is None:
            raise ValueError("Missing required parameter 'enterprise'.")
        if configuration_id is None:
            raise ValueError("Missing required parameter 'configuration_id'.")
        url = f"{self.base_url}/enterprises/{enterprise}/code-security/configurations/{configuration_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_code_security_config(self, enterprise: str, configuration_id: str, name: Optional[str] = None, description: Optional[str] = None, advanced_security: Optional[str] = None, dependency_graph: Optional[str] = None, dependency_graph_autosubmit_action: Optional[str] = None, dependency_graph_autosubmit_action_options: Optional[dict[str, Any]] = None, dependabot_alerts: Optional[str] = None, dependabot_security_updates: Optional[str] = None, code_scanning_default_setup: Optional[str] = None, code_scanning_default_setup_options: Optional[dict[str, Any]] = None, code_scanning_delegated_alert_dismissal: Optional[str] = None, secret_scanning: Optional[str] = None, secret_scanning_push_protection: Optional[str] = None, secret_scanning_validity_checks: Optional[str] = None, secret_scanning_non_provider_patterns: Optional[str] = None, secret_scanning_generic_secrets: Optional[str] = None, secret_scanning_delegated_alert_dismissal: Optional[str] = None, private_vulnerability_reporting: Optional[str] = None, enforcement: Optional[str] = None) -> dict[str, Any]:
        """
        Sets a code security configuration as the default for new repositories in a GitHub enterprise, applying it to specified repository types by default.

        Args:
            enterprise (string): enterprise
            configuration_id (string): configuration_id
            name (string): The name of the code security configuration. Must be unique across the enterprise. Example: 'octo-enterprise recommended settings v2'.
            description (string): A description of the code security configuration
            advanced_security (string): The enablement status of GitHub Advanced Security features. `enabled` will enable both Code Security and Secret Protection features.
            dependency_graph (string): The enablement status of Dependency Graph
            dependency_graph_autosubmit_action (string): The enablement status of Automatic dependency submission
            dependency_graph_autosubmit_action_options (object): Feature options for Automatic dependency submission
            dependabot_alerts (string): The enablement status of Dependabot alerts
            dependabot_security_updates (string): The enablement status of Dependabot security updates
            code_scanning_default_setup (string): The enablement status of code scanning default setup Example: 'enabled'.
            code_scanning_default_setup_options (object): Feature options for code scanning default setup
            code_scanning_delegated_alert_dismissal (string): The enablement status of code scanning delegated alert dismissal
            secret_scanning (string): The enablement status of secret scanning Example: 'disabled'.
            secret_scanning_push_protection (string): The enablement status of secret scanning push protection
            secret_scanning_validity_checks (string): The enablement status of secret scanning validity checks
            secret_scanning_non_provider_patterns (string): The enablement status of secret scanning non-provider patterns
            secret_scanning_generic_secrets (string): The enablement status of Copilot secret scanning
            secret_scanning_delegated_alert_dismissal (string): The enablement status of secret scanning delegated alert dismissal
            private_vulnerability_reporting (string): The enablement status of private vulnerability reporting
            enforcement (string): The enforcement status for a security configuration

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-security
        """
        if enterprise is None:
            raise ValueError("Missing required parameter 'enterprise'.")
        if configuration_id is None:
            raise ValueError("Missing required parameter 'configuration_id'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'description': description,
            'advanced_security': advanced_security,
            'dependency_graph': dependency_graph,
            'dependency_graph_autosubmit_action': dependency_graph_autosubmit_action,
            'dependency_graph_autosubmit_action_options': dependency_graph_autosubmit_action_options,
            'dependabot_alerts': dependabot_alerts,
            'dependabot_security_updates': dependabot_security_updates,
            'code_scanning_default_setup': code_scanning_default_setup,
            'code_scanning_default_setup_options': code_scanning_default_setup_options,
            'code_scanning_delegated_alert_dismissal': code_scanning_delegated_alert_dismissal,
            'secret_scanning': secret_scanning,
            'secret_scanning_push_protection': secret_scanning_push_protection,
            'secret_scanning_validity_checks': secret_scanning_validity_checks,
            'secret_scanning_non_provider_patterns': secret_scanning_non_provider_patterns,
            'secret_scanning_generic_secrets': secret_scanning_generic_secrets,
            'secret_scanning_delegated_alert_dismissal': secret_scanning_delegated_alert_dismissal,
            'private_vulnerability_reporting': private_vulnerability_reporting,
            'enforcement': enforcement,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/enterprises/{enterprise}/code-security/configurations/{configuration_id}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_configuration_by_id(self, enterprise: str, configuration_id: str) -> Any:
        """
        Deletes a code security configuration from a GitHub enterprise, detaching associated repositories while preserving their existing settings.

        Args:
            enterprise (string): enterprise
            configuration_id (string): configuration_id

        Returns:
            Any: A header with no content is returned.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-security
        """
        if enterprise is None:
            raise ValueError("Missing required parameter 'enterprise'.")
        if configuration_id is None:
            raise ValueError("Missing required parameter 'configuration_id'.")
        url = f"{self.base_url}/enterprises/{enterprise}/code-security/configurations/{configuration_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def attach_configuration(self, enterprise: str, configuration_id: str, scope: str) -> dict[str, Any]:
        """
        Attaches an enterprise code security configuration to repositories and returns a status code indicating success or failure.

        Args:
            enterprise (string): enterprise
            configuration_id (string): configuration_id
            scope (string): The type of repositories to attach the configuration to. Example: 'all'.

        Returns:
            dict[str, Any]: Accepted

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-security
        """
        if enterprise is None:
            raise ValueError("Missing required parameter 'enterprise'.")
        if configuration_id is None:
            raise ValueError("Missing required parameter 'configuration_id'.")
        request_body_data = None
        request_body_data = {
            'scope': scope,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/enterprises/{enterprise}/code-security/configurations/{configuration_id}/attach"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_code_security_defaults(self, enterprise: str, configuration_id: str, default_for_new_repos: Optional[str] = None) -> dict[str, Any]:
        """
        Sets a code security configuration as the default for new repositories in a GitHub enterprise.

        Args:
            enterprise (string): enterprise
            configuration_id (string): configuration_id
            default_for_new_repos (string): Specify which types of repository this security configuration should be applied to by default. Example: 'all'.

        Returns:
            dict[str, Any]: Default successfully changed.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-security
        """
        if enterprise is None:
            raise ValueError("Missing required parameter 'enterprise'.")
        if configuration_id is None:
            raise ValueError("Missing required parameter 'configuration_id'.")
        request_body_data = None
        request_body_data = {
            'default_for_new_repos': default_for_new_repos,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/enterprises/{enterprise}/code-security/configurations/{configuration_id}/defaults"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_repo_config(self, enterprise: str, configuration_id: str, per_page: Optional[int] = None, before: Optional[str] = None, after: Optional[str] = None, status: Optional[str] = None) -> list[Any]:
        """
        Retrieves a paginated list of repositories associated with a specific code security configuration for an enterprise, including pagination parameters and status filtering.

        Args:
            enterprise (string): enterprise
            configuration_id (string): configuration_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](
            before (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            after (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            status (string): A comma-separated list of statuses. If specified, only repositories with these attachment statuses will be returned. Can be: `all`, `attached`, `attaching`, `removed`, `enforced`, `failed`, `updating`, `removed_by_enterprise`

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-security
        """
        if enterprise is None:
            raise ValueError("Missing required parameter 'enterprise'.")
        if configuration_id is None:
            raise ValueError("Missing required parameter 'configuration_id'.")
        url = f"{self.base_url}/enterprises/{enterprise}/code-security/configurations/{configuration_id}/repositories"
        query_params = {k: v for k, v in [('per_page', per_page), ('before', before), ('after', after), ('status', status)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_enterprise_dependabot_alerts(self, enterprise: str, state: Optional[str] = None, severity: Optional[str] = None, ecosystem: Optional[str] = None, package: Optional[str] = None, epss_percentage: Optional[str] = None, has: Optional[Any] = None, scope: Optional[str] = None, sort: Optional[str] = None, direction: Optional[str] = None, before: Optional[str] = None, after: Optional[str] = None, first: Optional[int] = None, last: Optional[int] = None, per_page: Optional[int] = None) -> list[Any]:
        """
        Retrieves Dependabot security alerts for repositories within an enterprise, filtered by state, severity, ecosystem, package, and other parameters.

        Args:
            enterprise (string): enterprise
            state (string): A comma-separated list of states. If specified, only alerts with these states will be returned.

        Can be: `auto_dismissed`, `dismissed`, `fixed`, `open`
            severity (string): A comma-separated list of severities. If specified, only alerts with these severities will be returned.

        Can be: `low`, `medium`, `high`, `critical`
            ecosystem (string): A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.

        Can be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`
            package (string): A comma-separated list of package names. If specified, only alerts for these packages will be returned.
            epss_percentage (string): CVE Exploit Prediction Scoring System (EPSS) percentage. Can be specified as:
        - An exact number (`n`)
        - Comparators such as `>n`, `<n`, `>=n`, `<=n`
        - A range like `n..n`, where `n` is a number from 0.0 to 1.0

        Filters the list of alerts based on EPSS percentages. If specified, only alerts with the provided EPSS percentages will be returned.
            has (string): Filters the list of alerts based on whether the alert has the given value. If specified, only alerts meeting this criterion will be returned.
        Multiple `has` filters can be passed to filter for alerts that have all of the values. Currently, only `patch` is supported.
            scope (string): The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.
            sort (string): The property by which to sort the results.
        `created` means when the alert was created.
        `updated` means when the alert's state last changed.
        `epss_percentage` sorts alerts by the Exploit Prediction Scoring System (EPSS) percentage.
            direction (string): The direction to sort the results by.
            before (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            after (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            first (integer): **Deprecated**. The number of results per page (max 100), starting from the first matching result.
        This parameter must not be used in combination with `last`.
        Instead, use `per_page` in combination with `after` to fetch the first page of results.
            last (integer): **Deprecated**. The number of results per page (max 100), starting from the last matching result.
        This parameter must not be used in combination with `first`.
        Instead, use `per_page` in combination with `before` to fetch the last page of results.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            dependabot
        """
        if enterprise is None:
            raise ValueError("Missing required parameter 'enterprise'.")
        url = f"{self.base_url}/enterprises/{enterprise}/dependabot/alerts"
        query_params = {k: v for k, v in [('state', state), ('severity', severity), ('ecosystem', ecosystem), ('package', package), ('epss_percentage', epss_percentage), ('has', has), ('scope', scope), ('sort', sort), ('direction', direction), ('before', before), ('after', after), ('first', first), ('last', last), ('per_page', per_page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_enterprise_secret_alerts(self, enterprise: str, state: Optional[str] = None, secret_type: Optional[str] = None, resolution: Optional[str] = None, sort: Optional[str] = None, direction: Optional[str] = None, per_page: Optional[int] = None, before: Optional[str] = None, after: Optional[str] = None, validity: Optional[str] = None, is_publicly_leaked: Optional[bool] = None, is_multi_repo: Optional[bool] = None) -> list[Any]:
        """
        Retrieves a list of secret scanning alerts for eligible repositories within an enterprise, from newest to oldest, based on specified filters such as alert state, secret type, resolution, and more.

        Args:
            enterprise (string): enterprise
            state (string): Set to `open` or `resolved` to only list secret scanning alerts in a specific state.
            secret_type (string): A comma-separated list of secret types to return. All default secret patterns are returned. To return generic patterns, pass the token name(s) in the parameter. See "[Supported secret scanning patterns](https://docs.github.com/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)" for a complete list of secret types.
            resolution (string): A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.
            sort (string): The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.
            direction (string): The direction to sort the results by.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            before (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            after (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            validity (string): A comma-separated list of validities that, when present, will return alerts that match the validities in this list. Valid options are `active`, `inactive`, and `unknown`.
            is_publicly_leaked (boolean): A boolean value representing whether or not to filter alerts by the publicly-leaked tag being present.
            is_multi_repo (boolean): A boolean value representing whether or not to filter alerts by the multi-repo tag being present.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            secret-scanning
        """
        if enterprise is None:
            raise ValueError("Missing required parameter 'enterprise'.")
        url = f"{self.base_url}/enterprises/{enterprise}/secret-scanning/alerts"
        query_params = {k: v for k, v in [('state', state), ('secret_type', secret_type), ('resolution', resolution), ('sort', sort), ('direction', direction), ('per_page', per_page), ('before', before), ('after', after), ('validity', validity), ('is_publicly_leaked', is_publicly_leaked), ('is_multi_repo', is_multi_repo)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def activity_list_public_events(self, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of events using the "GET" method at the "/events" endpoint, allowing pagination with "per-page" and "page" parameters.

        Args:
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        url = f"{self.base_url}/events"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def activity_get_feeds(self) -> dict[str, Any]:
        """
        Retrieves a list of feeds from the API.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        url = f"{self.base_url}/feeds"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def gists_list(self, since: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of public gists using GitHub's REST API.

        Args:
            since (string): Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            gists
        """
        url = f"{self.base_url}/gists"
        query_params = {k: v for k, v in [('since', since), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def gists_create(self, files: dict[str, dict[str, Any]], description: Optional[str] = None, public: Optional[Any] = None) -> dict[str, Any]:
        """
        Creates a new public or secret GitHub gist using the GitHub API and returns the created gist details.

        Args:
            files (object): Names and content for the files that make up the gist Example: '{\'hello.rb\': {\'content\': \'puts "Hello, World!"\'}}'.
            description (string): Description of the gist Example: 'Example Ruby script'.
            public (string): public Example: False.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            gists
        """
        request_body_data = None
        request_body_data = {
            'description': description,
            'files': files,
            'public': public,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/gists"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def gists_list_public(self, since: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of public gists from GitHub using the GET method at the "/gists/public" path, allowing for filtering by date and pagination.

        Args:
            since (string): Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            gists
        """
        url = f"{self.base_url}/gists/public"
        query_params = {k: v for k, v in [('since', since), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def gists_list_starred(self, since: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of starred gists owned by the authenticated user with pagination support.

        Args:
            since (string): Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            gists
        """
        url = f"{self.base_url}/gists/starred"
        query_params = {k: v for k, v in [('since', since), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def gists_get(self, gist_id: str) -> dict[str, Any]:
        """
        Retrieves the content of a GitHub gist identified by its ID using the "GET" method.

        Args:
            gist_id (string): gist_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            gists
        """
        if gist_id is None:
            raise ValueError("Missing required parameter 'gist_id'.")
        url = f"{self.base_url}/gists/{gist_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def gists_update(self, gist_id: str, description: Optional[str] = None, files: Optional[dict[str, dict[str, Any]]] = None) -> dict[str, Any]:
        """
        Updates an existing GitHub gist using the provided parameters and returns the modified gist.

        Args:
            gist_id (string): gist_id
            description (string): The description of the gist. Example: 'Example Ruby script'.
            files (object): The gist files to be updated, renamed, or deleted. Each `key` must match the current filename
        (including extension) of the targeted gist file. For example: `hello.py`.

        To delete a file, set the whole file to null. For example: `hello.py : null`. The file will also be
        deleted if the specified object does not contain at least one of `content` or `filename`. Example: "{'hello.rb': {'content': 'blah', 'filename': 'goodbye.rb'}}".

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            gists
        """
        if gist_id is None:
            raise ValueError("Missing required parameter 'gist_id'.")
        request_body_data = None
        request_body_data = {
            'description': description,
            'files': files,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/gists/{gist_id}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def gists_delete(self, gist_id: str) -> Any:
        """
        Deletes a GitHub gist using the GitHub API and returns a status message indicating success or failure based on the HTTP status code.

        Args:
            gist_id (string): gist_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            gists
        """
        if gist_id is None:
            raise ValueError("Missing required parameter 'gist_id'.")
        url = f"{self.base_url}/gists/{gist_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def gists_list_comments(self, gist_id: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of comments for a specific GitHub gist.

        Args:
            gist_id (string): gist_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            gists
        """
        if gist_id is None:
            raise ValueError("Missing required parameter 'gist_id'.")
        url = f"{self.base_url}/gists/{gist_id}/comments"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def gists_create_comment(self, gist_id: str, body: str) -> dict[str, Any]:
        """
        Creates a new comment on a specified GitHub gist using the "POST" method and returns a status message with a "201 Created" response upon success.

        Args:
            gist_id (string): gist_id
            body (string): The comment text. Example: 'Body of the attachment'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            gists
        """
        if gist_id is None:
            raise ValueError("Missing required parameter 'gist_id'.")
        request_body_data = None
        request_body_data = {
            'body': body,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/gists/{gist_id}/comments"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def gists_get_comment(self, gist_id: str, comment_id: str) -> dict[str, Any]:
        """
        Retrieves a specific comment from a GitHub gist using the provided gist and comment IDs.

        Args:
            gist_id (string): gist_id
            comment_id (string): comment_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            gists
        """
        if gist_id is None:
            raise ValueError("Missing required parameter 'gist_id'.")
        if comment_id is None:
            raise ValueError("Missing required parameter 'comment_id'.")
        url = f"{self.base_url}/gists/{gist_id}/comments/{comment_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def gists_update_comment(self, gist_id: str, comment_id: str, body: str) -> dict[str, Any]:
        """
        Updates a specific comment on a GitHub gist using the provided ID and returns the modified comment.

        Args:
            gist_id (string): gist_id
            comment_id (string): comment_id
            body (string): The comment text. Example: 'Body of the attachment'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            gists
        """
        if gist_id is None:
            raise ValueError("Missing required parameter 'gist_id'.")
        if comment_id is None:
            raise ValueError("Missing required parameter 'comment_id'.")
        request_body_data = None
        request_body_data = {
            'body': body,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/gists/{gist_id}/comments/{comment_id}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def gists_delete_comment(self, gist_id: str, comment_id: str) -> Any:
        """
        Deletes a GitHub gist comment specified by the gist ID and comment ID using the GitHub API.

        Args:
            gist_id (string): gist_id
            comment_id (string): comment_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            gists
        """
        if gist_id is None:
            raise ValueError("Missing required parameter 'gist_id'.")
        if comment_id is None:
            raise ValueError("Missing required parameter 'comment_id'.")
        url = f"{self.base_url}/gists/{gist_id}/comments/{comment_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def gists_list_commits(self, gist_id: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves paginated commit history for a specified GitHub gist.

        Args:
            gist_id (string): gist_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            gists
        """
        if gist_id is None:
            raise ValueError("Missing required parameter 'gist_id'.")
        url = f"{self.base_url}/gists/{gist_id}/commits"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def gists_list_forks(self, gist_id: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of forks for a specified GitHub gist using the GitHub API.

        Args:
            gist_id (string): gist_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            gists
        """
        if gist_id is None:
            raise ValueError("Missing required parameter 'gist_id'.")
        url = f"{self.base_url}/gists/{gist_id}/forks"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def gists_fork(self, gist_id: str) -> dict[str, Any]:
        """
        Creates a fork of a specified gist using the GitHub API and returns a status message.

        Args:
            gist_id (string): gist_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            gists
        """
        if gist_id is None:
            raise ValueError("Missing required parameter 'gist_id'.")
        request_body_data = None
        url = f"{self.base_url}/gists/{gist_id}/forks"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def gists_check_is_starred(self, gist_id: str) -> Any:
        """
        Checks if a gist is starred by the authenticated user using the GitHub API.

        Args:
            gist_id (string): gist_id

        Returns:
            Any: Response if gist is starred

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            gists
        """
        if gist_id is None:
            raise ValueError("Missing required parameter 'gist_id'.")
        url = f"{self.base_url}/gists/{gist_id}/star"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def gists_star(self, gist_id: str) -> Any:
        """
        Stars a GitHub gist using the GitHub API by sending a PUT request to the specified path.

        Args:
            gist_id (string): gist_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            gists
        """
        if gist_id is None:
            raise ValueError("Missing required parameter 'gist_id'.")
        request_body_data = None
        url = f"{self.base_url}/gists/{gist_id}/star"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def gists_unstar(self, gist_id: str) -> Any:
        """
        Removes a star from a GitHub gist using the GitHub API and returns a success status upon removal.

        Args:
            gist_id (string): gist_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            gists
        """
        if gist_id is None:
            raise ValueError("Missing required parameter 'gist_id'.")
        url = f"{self.base_url}/gists/{gist_id}/star"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def gists_get_revision(self, gist_id: str, sha: str) -> dict[str, Any]:
        """
        Retrieves a specific version of a GitHub gist by its ID and SHA, returning details about that version.

        Args:
            gist_id (string): gist_id
            sha (string): sha

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            gists
        """
        if gist_id is None:
            raise ValueError("Missing required parameter 'gist_id'.")
        if sha is None:
            raise ValueError("Missing required parameter 'sha'.")
        url = f"{self.base_url}/gists/{gist_id}/{sha}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def gitignore_get_all_templates(self) -> list[Any]:
        """
        Retrieves available .gitignore templates for ignoring files and directories in repositories.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            gitignore
        """
        url = f"{self.base_url}/gitignore/templates"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def gitignore_get_template(self, name: str) -> dict[str, Any]:
        """
        Retrieves a .gitignore template by name for specifying files or directories to be ignored in a repository using the GitHub API.

        Args:
            name (string): name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            gitignore
        """
        if name is None:
            raise ValueError("Missing required parameter 'name'.")
        url = f"{self.base_url}/gitignore/templates/{name}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_installation_repositories(self, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a paginated list of repositories accessible to the authenticated installation, supporting pagination via page and per-page parameters.

        Args:
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        url = f"{self.base_url}/installation/repositories"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_installation_token(self) -> Any:
        """
        Revokes a GitHub App installation access token, invalidating it and requiring a new token for future requests.

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        url = f"{self.base_url}/installation/token"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_list(self, filter: Optional[str] = None, state: Optional[str] = None, labels: Optional[str] = None, sort: Optional[str] = None, direction: Optional[str] = None, since: Optional[str] = None, collab: Optional[bool] = None, orgs: Optional[bool] = None, owned: Optional[bool] = None, pulls: Optional[bool] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of issues from a repository using the GitHub API, allowing filtering by criteria such as state, labels, and sort order, and returns issue details in response.

        Args:
            filter (string): Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation.
            state (string): Indicates the state of the issues to return.
            labels (string): A list of comma separated label names. Example: `bug,ui,@high`
            sort (string): What to sort results by.
            direction (string): The direction to sort the results by.
            since (string): Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            collab (boolean): Determines whether to include collaboration-related data in the response.
            orgs (boolean): The "orgs" parameter filters issues by organization, allowing users to specify which organizations' issues to retrieve.
            owned (boolean): Specifies whether to filter results to only include issues owned by the authenticated user.
            pulls (boolean): A query parameter that filters issues to only include pull requests when set to "true."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        url = f"{self.base_url}/issues"
        query_params = {k: v for k, v in [('filter', filter), ('state', state), ('labels', labels), ('sort', sort), ('direction', direction), ('since', since), ('collab', collab), ('orgs', orgs), ('owned', owned), ('pulls', pulls), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def licenses_get_all_commonly_used(self, featured: Optional[bool] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of licenses, optionally filtered by featured status.

        Args:
            featured (boolean): Indicates whether to filter results to only include featured licenses.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            licenses
        """
        url = f"{self.base_url}/licenses"
        query_params = {k: v for k, v in [('featured', featured), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def licenses_get(self, license: str) -> dict[str, Any]:
        """
        Retrieves information about a specific license identified by the "{license}" path parameter using the GET method.

        Args:
            license (string): license

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            licenses
        """
        if license is None:
            raise ValueError("Missing required parameter 'license'.")
        url = f"{self.base_url}/licenses/{license}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def markdown_render(self, text: str, mode: Optional[str] = None, context: Optional[str] = None) -> Any:
        """
        Renders Markdown content as formatted HTML or raw text using a POST request to the specified endpoint.

        Args:
            text (string): The Markdown text to render in HTML. Example: 'Hello **world**'.
            mode (string): The rendering mode. Example: 'markdown'.
            context (string): The repository context to use when creating references in `gfm` mode.  For example, setting `context` to `octo-org/octo-repo` will change the text `#42` into an HTML link to issue 42 in the `octo-org/octo-repo` repository.

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            markdown
        """
        request_body_data = None
        request_body_data = {
            'text': text,
            'mode': mode,
            'context': context,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/markdown"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def markdown_render_raw(self, body_content: Optional[str] = None) -> Any:
        """
        Renders Markdown text into raw format using the "POST" method at the "/markdown/raw" endpoint.

        Args:
            body_content (str | None): Raw text content for the request body.

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            markdown
        """
        request_body_data = None
        request_body_data = body_content
        url = f"{self.base_url}/markdown/raw"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='text/plain')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_account_details(self, account_id: str) -> dict[str, Any]:
        """
        Retrieves account information for a specified marketplace listing account using the GET method, returning relevant details associated with the provided account ID.

        Args:
            account_id (string): account_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        if account_id is None:
            raise ValueError("Missing required parameter 'account_id'.")
        url = f"{self.base_url}/marketplace_listing/accounts/{account_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def apps_list_plans(self, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of marketplace plans using the GET method, allowing users to navigate through pages of plan details based on parameters such as per page and page number.

        Args:
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        url = f"{self.base_url}/marketplace_listing/plans"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def apps_list_accounts_for_plan(self, plan_id: str, sort: Optional[str] = None, direction: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of accounts associated with a specified marketplace plan, allowing sorting by direction and pagination for per-page results.

        Args:
            plan_id (string): plan_id
            sort (string): The property to sort the results by.
            direction (string): To return the oldest accounts first, set to `asc`. Ignored without the `sort` parameter.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        if plan_id is None:
            raise ValueError("Missing required parameter 'plan_id'.")
        url = f"{self.base_url}/marketplace_listing/plans/{plan_id}/accounts"
        query_params = {k: v for k, v in [('sort', sort), ('direction', direction), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_stubbed_account(self, account_id: str) -> dict[str, Any]:
        """
        Retrieves stubbed account information for a specified marketplace listing account ID using a GET request.

        Args:
            account_id (string): account_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        if account_id is None:
            raise ValueError("Missing required parameter 'account_id'.")
        url = f"{self.base_url}/marketplace_listing/stubbed/accounts/{account_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def apps_list_plans_stubbed(self, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves paginated listings of marketplace plans with optional page size and number parameters.

        Args:
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        url = f"{self.base_url}/marketplace_listing/stubbed/plans"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_plan_accounts(self, plan_id: str, sort: Optional[str] = None, direction: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves user and organization accounts associated with a specific GitHub Marketplace plan, including subscription details and pending changes.

        Args:
            plan_id (string): plan_id
            sort (string): The property to sort the results by.
            direction (string): To return the oldest accounts first, set to `asc`. Ignored without the `sort` parameter.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        if plan_id is None:
            raise ValueError("Missing required parameter 'plan_id'.")
        url = f"{self.base_url}/marketplace_listing/stubbed/plans/{plan_id}/accounts"
        query_params = {k: v for k, v in [('sort', sort), ('direction', direction), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def meta_get(self) -> dict[str, Any]:
        """
        Retrieves metadata information using the "GET" method at the "/meta" path.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            meta
        """
        url = f"{self.base_url}/meta"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_network_repo_events(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of public events for a repository's network with latency up to 6 hours.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/networks/{owner}/{repo}/events"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_notifications(self, all: Optional[bool] = None, participating: Optional[bool] = None, since: Optional[str] = None, before: Optional[str] = None, page: Optional[int] = None, per_page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of notifications using the GET method at the "/notifications" path, allowing filters by parameters such as participating, since, before, page, and per_page.

        Args:
            all (boolean): If `true`, show notifications marked as read.
            participating (boolean): If `true`, only shows notifications in which the user is directly participating or mentioned.
            since (string): Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            before (string): Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 50). For more information, see "[Using pagination in the REST API](

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        url = f"{self.base_url}/notifications"
        query_params = {k: v for k, v in [('all', all), ('participating', participating), ('since', since), ('before', before), ('page', page), ('per_page', per_page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_notification(self, last_read_at: Optional[str] = None, read: Optional[bool] = None) -> dict[str, Any]:
        """
        Updates or creates a notification resource at the specified path by replacing or creating it with the provided data.

        Args:
            last_read_at (string): Describes the last point that notifications were checked. Anything updated since this time will not be marked as read. If you omit this parameter, all notifications are marked as read. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Default: The current timestamp. Example: '2022-06-10T00:00:00Z'.
            read (boolean): Whether the notification has been read. Example: True.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        request_body_data = None
        request_body_data = {
            'last_read_at': last_read_at,
            'read': read,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/notifications"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def activity_get_thread(self, thread_id: str) -> dict[str, Any]:
        """
        Retrieves information about a specific notification thread by its ID, using the "GET" method.

        Args:
            thread_id (string): thread_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        if thread_id is None:
            raise ValueError("Missing required parameter 'thread_id'.")
        url = f"{self.base_url}/notifications/threads/{thread_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def activity_mark_thread_as_read(self, thread_id: str) -> Any:
        """
        Updates a notification thread with the specified ID using the PATCH method, allowing partial modifications to its properties.

        Args:
            thread_id (string): thread_id

        Returns:
            Any: Reset Content

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        if thread_id is None:
            raise ValueError("Missing required parameter 'thread_id'.")
        request_body_data = None
        url = f"{self.base_url}/notifications/threads/{thread_id}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def activity_mark_thread_as_done(self, thread_id: str) -> Any:
        """
        Deletes a notification thread subscription at the specified thread ID using the "DELETE" method, effectively muting future notifications for that conversation.

        Args:
            thread_id (string): thread_id

        Returns:
            Any: No content

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        if thread_id is None:
            raise ValueError("Missing required parameter 'thread_id'.")
        url = f"{self.base_url}/notifications/threads/{thread_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_thread_subscription(self, thread_id: str) -> dict[str, Any]:
        """
        Retrieves the subscription details for a specific notification thread using the provided thread ID.

        Args:
            thread_id (string): thread_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        if thread_id is None:
            raise ValueError("Missing required parameter 'thread_id'.")
        url = f"{self.base_url}/notifications/threads/{thread_id}/subscription"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_thread_subscription(self, thread_id: str, ignored: Optional[bool] = None) -> dict[str, Any]:
        """
        Subscribes to a GitHub notification thread and returns the subscription status.

        Args:
            thread_id (string): thread_id
            ignored (boolean): Whether to block all notifications from a thread. Example: False.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        if thread_id is None:
            raise ValueError("Missing required parameter 'thread_id'.")
        request_body_data = None
        request_body_data = {
            'ignored': ignored,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/notifications/threads/{thread_id}/subscription"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def unsubscribe_thread(self, thread_id: str) -> Any:
        """
        Mutes future notifications for a GitHub thread until user interaction occurs.

        Args:
            thread_id (string): thread_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        if thread_id is None:
            raise ValueError("Missing required parameter 'thread_id'.")
        url = f"{self.base_url}/notifications/threads/{thread_id}/subscription"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def meta_get_octocat(self, s: Optional[str] = None) -> Any:
        """
        Retrieves the GitHub Octocat mascot as ASCII art with optional text in a speech bubble via the "s" query parameter.

        Args:
            s (string): The words to show in Octocat's speech bubble

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            meta
        """
        url = f"{self.base_url}/octocat"
        query_params = {k: v for k, v in [('s', s)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_list(self, since: Optional[int] = None, per_page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of organizations using the "GET" method at the "/organizations" path, allowing optional filtering by parameters such as "since" and "per page".

        Args:
            since (integer): An organization ID. Only return organizations with an ID greater than this ID.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        url = f"{self.base_url}/organizations"
        query_params = {k: v for k, v in [('since', since), ('per_page', per_page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_billing_usage(self, org: str, year: Optional[int] = None, month: Optional[int] = None, day: Optional[int] = None, hour: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves billing usage data for an organization, allowing for the specification of year, month, day, and hour parameters to filter the results.

        Args:
            org (string): org
            year (integer): If specified, only return results for a single year. The value of `year` is an integer with four digits representing a year. For example, `2025`. Default value is the current year.
            month (integer): If specified, only return results for a single month. The value of `month` is an integer between `1` and `12`. If no year is specified the default `year` is used.
            day (integer): If specified, only return results for a single day. The value of `day` is an integer between `1` and `31`. If no `year` or `month` is specified, the default `year` and `month` are used.
            hour (integer): If specified, only return results for a single hour. The value of `hour` is an integer between `0` and `23`. If no `year`, `month`, or `day` is specified, the default `year`, `month`, and `day` are used.

        Returns:
            dict[str, Any]: Billing usage report response for an organization

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            billing
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/organizations/{org}/settings/billing/usage"
        query_params = {k: v for k, v in [('year', year), ('month', month), ('day', day), ('hour', hour)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_get(self, org: str) -> dict[str, Any]:
        """
        Retrieves detailed information about a specified GitHub organization.

        Args:
            org (string): org

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_update(self, org: str, billing_email: Optional[str] = None, company: Optional[str] = None, email: Optional[str] = None, twitter_username: Optional[str] = None, location: Optional[str] = None, name: Optional[str] = None, description: Optional[str] = None, has_organization_projects: Optional[bool] = None, has_repository_projects: Optional[bool] = None, default_repository_permission: Optional[str] = None, members_can_create_repositories: Optional[bool] = None, members_can_create_internal_repositories: Optional[bool] = None, members_can_create_private_repositories: Optional[bool] = None, members_can_create_public_repositories: Optional[bool] = None, members_allowed_repository_creation_type: Optional[str] = None, members_can_create_pages: Optional[bool] = None, members_can_create_public_pages: Optional[bool] = None, members_can_create_private_pages: Optional[bool] = None, members_can_fork_private_repositories: Optional[bool] = None, web_commit_signoff_required: Optional[bool] = None, blog: Optional[str] = None, advanced_security_enabled_for_new_repositories: Optional[bool] = None, dependabot_alerts_enabled_for_new_repositories: Optional[bool] = None, dependabot_security_updates_enabled_for_new_repositories: Optional[bool] = None, dependency_graph_enabled_for_new_repositories: Optional[bool] = None, secret_scanning_enabled_for_new_repositories: Optional[bool] = None, secret_scanning_push_protection_enabled_for_new_repositories: Optional[bool] = None, secret_scanning_push_protection_custom_link_enabled: Optional[bool] = None, secret_scanning_push_protection_custom_link: Optional[str] = None, deploy_keys_enabled_for_repositories: Optional[bool] = None) -> dict[str, Any]:
        """
        Updates an organization's configuration in the GitHub API and returns the modified organization details.

        Args:
            org (string): org
            billing_email (string): Billing email address. This address is not publicized. Example: 'mona@github.com'.
            company (string): The company name. Example: 'GitHub'.
            email (string): The publicly visible email address. Example: 'mona@github.com'.
            twitter_username (string): The Twitter username of the company. Example: 'github'.
            location (string): The location. Example: 'San Francisco'.
            name (string): The shorthand name of the company. Example: 'github'.
            description (string): The description of the company. The maximum size is 160 characters. Example: 'GitHub, the company.'.
            has_organization_projects (boolean): Whether an organization can use organization projects.
            has_repository_projects (boolean): Whether repositories that belong to the organization can use repository projects.
            default_repository_permission (string): Default permission level members have for organization repositories. Example: 'read'.
            members_can_create_repositories (boolean): Whether of non-admin organization members can create repositories. **Note:** A parameter can override this parameter. See `members_allowed_repository_creation_type` in this table for details. Example: True.
            members_can_create_internal_repositories (boolean): Whether organization members can create internal repositories, which are visible to all enterprise members. You can only allow members to create internal repositories if your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation.
            members_can_create_private_repositories (boolean): Whether organization members can create private repositories, which are visible to organization members with permission. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation.
            members_can_create_public_repositories (boolean): Whether organization members can create public repositories, which are visible to anyone. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation.
            members_allowed_repository_creation_type (string): Specifies which types of repositories non-admin organization members can create. `private` is only available to repositories that are part of an organization on GitHub Enterprise Cloud. 
        **Note:** This parameter is closing down and will be removed in the future. Its return value ignores internal repositories. Using this parameter overrides values set in `members_can_create_repositories`. See the parameter deprecation notice in the operation description for details. Example: 'all'.
            members_can_create_pages (boolean): Whether organization members can create GitHub Pages sites. Existing published sites will not be impacted.
            members_can_create_public_pages (boolean): Whether organization members can create public GitHub Pages sites. Existing published sites will not be impacted.
            members_can_create_private_pages (boolean): Whether organization members can create private GitHub Pages sites. Existing published sites will not be impacted.
            members_can_fork_private_repositories (boolean): Whether organization members can fork private organization repositories.
            web_commit_signoff_required (boolean): Whether contributors to organization repositories are required to sign off on commits they make through GitHub's web interface.
            blog (string): blog Example: '"http://github.blog"'.
            advanced_security_enabled_for_new_repositories (boolean): **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.

        Whether GitHub Advanced Security is automatically enabled for new repositories and repositories transferred to this organization.

        To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."

        You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
            dependabot_alerts_enabled_for_new_repositories (boolean): **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.

        Whether Dependabot alerts are automatically enabled for new repositories and repositories transferred to this organization.

        To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."

        You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
            dependabot_security_updates_enabled_for_new_repositories (boolean): **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.

        Whether Dependabot security updates are automatically enabled for new repositories and repositories transferred to this organization.

        To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."

        You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
            dependency_graph_enabled_for_new_repositories (boolean): **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.

        Whether dependency graph is automatically enabled for new repositories and repositories transferred to this organization.

        To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."

        You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
            secret_scanning_enabled_for_new_repositories (boolean): **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.

        Whether secret scanning is automatically enabled for new repositories and repositories transferred to this organization.

        To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."

        You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
            secret_scanning_push_protection_enabled_for_new_repositories (boolean): **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.

        Whether secret scanning push protection is automatically enabled for new repositories and repositories transferred to this organization.

        To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."

        You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
            secret_scanning_push_protection_custom_link_enabled (boolean): Whether a custom link is shown to contributors who are blocked from pushing a secret by push protection.
            secret_scanning_push_protection_custom_link (string): If `secret_scanning_push_protection_custom_link_enabled` is true, the URL that will be displayed to contributors who are blocked from pushing a secret.
            deploy_keys_enabled_for_repositories (boolean): Controls whether or not deploy keys may be added and used for repositories in the organization.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'billing_email': billing_email,
            'company': company,
            'email': email,
            'twitter_username': twitter_username,
            'location': location,
            'name': name,
            'description': description,
            'has_organization_projects': has_organization_projects,
            'has_repository_projects': has_repository_projects,
            'default_repository_permission': default_repository_permission,
            'members_can_create_repositories': members_can_create_repositories,
            'members_can_create_internal_repositories': members_can_create_internal_repositories,
            'members_can_create_private_repositories': members_can_create_private_repositories,
            'members_can_create_public_repositories': members_can_create_public_repositories,
            'members_allowed_repository_creation_type': members_allowed_repository_creation_type,
            'members_can_create_pages': members_can_create_pages,
            'members_can_create_public_pages': members_can_create_public_pages,
            'members_can_create_private_pages': members_can_create_private_pages,
            'members_can_fork_private_repositories': members_can_fork_private_repositories,
            'web_commit_signoff_required': web_commit_signoff_required,
            'blog': blog,
            'advanced_security_enabled_for_new_repositories': advanced_security_enabled_for_new_repositories,
            'dependabot_alerts_enabled_for_new_repositories': dependabot_alerts_enabled_for_new_repositories,
            'dependabot_security_updates_enabled_for_new_repositories': dependabot_security_updates_enabled_for_new_repositories,
            'dependency_graph_enabled_for_new_repositories': dependency_graph_enabled_for_new_repositories,
            'secret_scanning_enabled_for_new_repositories': secret_scanning_enabled_for_new_repositories,
            'secret_scanning_push_protection_enabled_for_new_repositories': secret_scanning_push_protection_enabled_for_new_repositories,
            'secret_scanning_push_protection_custom_link_enabled': secret_scanning_push_protection_custom_link_enabled,
            'secret_scanning_push_protection_custom_link': secret_scanning_push_protection_custom_link,
            'deploy_keys_enabled_for_repositories': deploy_keys_enabled_for_repositories,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_delete(self, org: str) -> dict[str, Any]:
        """
        Deletes a GitHub organization and all its repositories, returning status codes for success or failure.

        Args:
            org (string): org

        Returns:
            dict[str, Any]: Accepted

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_cache_usage(self, org: str) -> dict[str, Any]:
        """
        Retrieves GitHub Actions cache usage for an organization, providing information on how much storage the caches consume across its repositories.

        Args:
            org (string): org

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/actions/cache/usage"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_cache_usage_by_repo(self, org: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves cache usage details across all repositories in an organization using the GitHub API.

        Args:
            org (string): org
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/actions/cache/usage-by-repository"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_hosted_runners(self, org: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a paginated list of GitHub-hosted runners available to an organization.

        Args:
            org (string): org
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/actions/hosted-runners"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_hosted_runner(self, org: str, name: str, image: dict[str, Any], size: str, runner_group_id: int, maximum_runners: Optional[int] = None, enable_static_ip: Optional[bool] = None) -> dict[str, Any]:
        """
        Creates a GitHub-hosted runner for an organization using the GitHub API.

        Args:
            org (string): org
            name (string): Name of the runner. Must be between 1 and 64 characters and may only contain upper and lowercase letters a-z, numbers 0-9, '.', '-', and '_'. Example: 'My Hosted runner'.
            image (object): The image of runner. To list all available images, use `GET /actions/hosted-runners/images/github-owned` or `GET /actions/hosted-runners/images/partner`. Example: {'id': 'ubuntu-latest', 'source': 'github'}.
            size (string): The machine size of the runner. To list available sizes, use `GET actions/hosted-runners/machine-sizes` Example: '4-core'.
            runner_group_id (integer): The existing runner group to add this runner to. Example: 1.
            maximum_runners (integer): The maximum amount of runners to scale up to. Runners will not auto-scale above this number. Use this setting to limit your cost. Example: 50.
            enable_static_ip (boolean): Whether this runner should be created with a static public IP. Note limit on account. To list limits on account, use `GET actions/hosted-runners/limits` Example: False.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'image': image,
            'size': size,
            'runner_group_id': runner_group_id,
            'maximum_runners': maximum_runners,
            'enable_static_ip': enable_static_ip,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/actions/hosted-runners"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_images(self, org: str) -> dict[str, Any]:
        """
        Retrieves GitHub-owned images for GitHub-hosted runners within a specified organization, returning relevant details for these images.

        Args:
            org (string): org

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/actions/hosted-runners/images/github-owned"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_hosted_images_by_org_id(self, org: str) -> dict[str, Any]:
        """
        Retrieves the list of partner-hosted runner images available for GitHub-hosted runners in an organization.

        Args:
            org (string): org

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/actions/hosted-runners/images/partner"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_runner_limits(self, org: str) -> dict[str, Any]:
        """
        Retrieves the usage limits for hosted runners in a GitHub organization using the GitHub API.

        Args:
            org (string): org

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/actions/hosted-runners/limits"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_actions_hosted_runner_sizes(self, org: str) -> dict[str, Any]:
        """
        Retrieves the available machine sizes and specifications for GitHub-hosted runners within a specified organization.

        Args:
            org (string): org

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/actions/hosted-runners/machine-sizes"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_hosted_platforms(self, org: str) -> dict[str, Any]:
        """
        Retrieves a list of platforms available for GitHub-hosted runners in an organization.

        Args:
            org (string): org

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/actions/hosted-runners/platforms"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_hosted_runner_by_id(self, org: str, hosted_runner_id: str) -> dict[str, Any]:
        """
        Retrieves information about a specific GitHub-hosted runner in an organization using the GitHub API.

        Args:
            org (string): org
            hosted_runner_id (string): hosted_runner_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if hosted_runner_id is None:
            raise ValueError("Missing required parameter 'hosted_runner_id'.")
        url = f"{self.base_url}/orgs/{org}/actions/hosted-runners/{hosted_runner_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def patch_org_hosted_runner(self, org: str, hosted_runner_id: str, name: Optional[str] = None, runner_group_id: Optional[int] = None, maximum_runners: Optional[int] = None, enable_static_ip: Optional[bool] = None) -> dict[str, Any]:
        """
        Updates configuration details for a GitHub-hosted runner in an organization.

        Args:
            org (string): org
            hosted_runner_id (string): hosted_runner_id
            name (string): Name of the runner. Must be between 1 and 64 characters and may only contain upper and lowercase letters a-z, numbers 0-9, '.', '-', and '_'. Example: 'My larger runner'.
            runner_group_id (integer): The existing runner group to add this runner to. Example: 1.
            maximum_runners (integer): The maximum amount of runners to scale up to. Runners will not auto-scale above this number. Use this setting to limit your cost. Example: 50.
            enable_static_ip (boolean): Whether this runner should be updated with a static public IP. Note limit on account. To list limits on account, use `GET actions/hosted-runners/limits` Example: False.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if hosted_runner_id is None:
            raise ValueError("Missing required parameter 'hosted_runner_id'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'runner_group_id': runner_group_id,
            'maximum_runners': maximum_runners,
            'enable_static_ip': enable_static_ip,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/actions/hosted-runners/{hosted_runner_id}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_hosted_runner_by_id(self, org: str, hosted_runner_id: str) -> dict[str, Any]:
        """
        Deletes a hosted runner from an organization using the GitHub API, returning a status code indicating success or failure.

        Args:
            org (string): org
            hosted_runner_id (string): hosted_runner_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if hosted_runner_id is None:
            raise ValueError("Missing required parameter 'hosted_runner_id'.")
        url = f"{self.base_url}/orgs/{org}/actions/hosted-runners/{hosted_runner_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_oidc_customization_sub(self, org: str) -> dict[str, Any]:
        """
        Retrieves the customization template for an OpenID Connect (OIDC) subject claim for an organization, providing the current configuration used in GitHub Actions.

        Args:
            org (string): org

        Returns:
            dict[str, Any]: A JSON serialized template for OIDC subject claim customization

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            oidc
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/actions/oidc/customization/sub"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_org_oidc_customization(self, org: str, include_claim_keys: List[str]) -> dict[str, Any]:
        """
        Configures the OIDC subject claim customization template for a GitHub organization using specified claim keys.

        Args:
            org (string): org
            include_claim_keys (array): Array of unique strings. Each claim key can only contain alphanumeric characters and underscores. Example: ['repo', 'context'].

        Returns:
            dict[str, Any]: Empty response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            oidc
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'include_claim_keys': include_claim_keys,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/actions/oidc/customization/sub"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_permissions(self, org: str) -> dict[str, Any]:
        """
        Retrieves the GitHub Actions permissions policy for repositories and allowed actions in an organization.

        Args:
            org (string): org

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/actions/permissions"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_org_permissions(self, org: str, enabled_repositories: str, allowed_actions: Optional[str] = None) -> Any:
        """
        Sets GitHub Actions permissions (enabled repositories and allowed actions) for an organization.

        Args:
            org (string): org
            enabled_repositories (string): The policy that controls the repositories in the organization that are allowed to run GitHub Actions. Example: 'all'.
            allowed_actions (string): The permissions policy that controls the actions and reusable workflows that are allowed to run. Example: 'selected'.

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'enabled_repositories': enabled_repositories,
            'allowed_actions': allowed_actions,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/actions/permissions"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_repo_permissions(self, org: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Lists selected repositories enabled for GitHub Actions in an organization.

        Args:
            org (string): org
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/actions/permissions/repositories"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_org_repo_permissions(self, org: str, selected_repository_ids: List[int]) -> Any:
        """
        Sets the list of repositories enabled for GitHub Actions in an organization, requiring admin permissions and returning a 204 status code on success.

        Args:
            org (string): org
            selected_repository_ids (array): List of repository IDs to enable for GitHub Actions. Example: [32, 42].

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'selected_repository_ids': selected_repository_ids,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/actions/permissions/repositories"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_repo_permissions(self, org: str, repository_id: str) -> Any:
        """
        Updates the GitHub Actions permissions for a specific repository within an organization using the "PUT" method.

        Args:
            org (string): org
            repository_id (string): repository_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if repository_id is None:
            raise ValueError("Missing required parameter 'repository_id'.")
        request_body_data = None
        url = f"{self.base_url}/orgs/{org}/actions/permissions/repositories/{repository_id}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_org_repo_permission(self, org: str, repository_id: str) -> Any:
        """
        Disables a repository for running GitHub Actions within an organization using the GitHub API.

        Args:
            org (string): org
            repository_id (string): repository_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if repository_id is None:
            raise ValueError("Missing required parameter 'repository_id'.")
        url = f"{self.base_url}/orgs/{org}/actions/permissions/repositories/{repository_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_org_actions(self, org: str) -> dict[str, Any]:
        """
        Retrieves the selected actions for a GitHub organization using the "GET" method at the "/orgs/{org}/actions/permissions/selected-actions" path.

        Args:
            org (string): org

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/actions/permissions/selected-actions"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_org_actions_permissions(self, org: str, github_owned_allowed: Optional[bool] = None, verified_allowed: Optional[bool] = None, patterns_allowed: Optional[List[str]] = None) -> Any:
        """
        Configures the allowed GitHub Actions and reusable workflows for an organization, restricting them to selected options.

        Args:
            org (string): org
            github_owned_allowed (boolean): Whether GitHub-owned actions are allowed. For example, this includes the actions in the `actions` organization. Example: True.
            verified_allowed (boolean): Whether actions from GitHub Marketplace verified creators are allowed. Set to `true` to allow all actions by GitHub Marketplace verified creators. Example: False.
            patterns_allowed (array): Specifies a list of string-matching patterns to allow specific action(s) and reusable workflow(s). Wildcards, tags, and SHAs are allowed. For example, `monalisa/octocat@*`, `monalisa/octocat@v2`, `monalisa/*`.

        > [!NOTE]
        > The `patterns_allowed` setting only applies to public repositories. Example: ['monalisa/octocat@*', 'docker/*'].

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'github_owned_allowed': github_owned_allowed,
            'verified_allowed': verified_allowed,
            'patterns_allowed': patterns_allowed,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/actions/permissions/selected-actions"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_workflow_permissions(self, org: str) -> dict[str, Any]:
        """
        Retrieves the default workflow permissions configured for a GitHub organization.

        Args:
            org (string): org

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/actions/permissions/workflow"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_org_workflow_permissions(self, org: str, default_workflow_permissions: Optional[str] = None, can_approve_pull_request_reviews: Optional[bool] = None) -> Any:
        """
        Updates the default workflow permissions for GitHub Actions across all repositories in an organization.

        Args:
            org (string): org
            default_workflow_permissions (string): The default workflow permissions granted to the GITHUB_TOKEN when running workflows. Example: 'read'.
            can_approve_pull_request_reviews (boolean): Whether GitHub Actions can approve pull requests. Enabling this can be a security risk. Example: True.

        Returns:
            Any: Success response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'default_workflow_permissions': default_workflow_permissions,
            'can_approve_pull_request_reviews': can_approve_pull_request_reviews,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/actions/permissions/workflow"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_runner_groups(self, org: str, per_page: Optional[int] = None, page: Optional[int] = None, visible_to_repository: Optional[str] = None) -> dict[str, Any]:
        """
        Retrieves a list of self-hosted runner groups for a GitHub organization, with optional pagination and repository visibility filtering.

        Args:
            org (string): org
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            visible_to_repository (string): Only return runner groups that are allowed to be used by this repository.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/actions/runner-groups"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page), ('visible_to_repository', visible_to_repository)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_runner_group(self, org: str, name: str, visibility: Optional[str] = None, selected_repository_ids: Optional[List[int]] = None, runners: Optional[List[int]] = None, allows_public_repositories: Optional[bool] = None, restricted_to_workflows: Optional[bool] = None, selected_workflows: Optional[List[str]] = None, network_configuration_id: Optional[str] = None) -> dict[str, Any]:
        """
        Creates a new self-hosted runner group for a GitHub organization, allowing customized repository access and runner management policies.

        Args:
            org (string): org
            name (string): Name of the runner group. Example: 'Expensive hardware runners'.
            visibility (string): Visibility of a runner group. You can select all repositories, select individual repositories, or limit access to private repositories. Example: 'selected'.
            selected_repository_ids (array): List of repository IDs that can access the runner group. Example: [32, 91].
            runners (array): List of runner IDs to add to the runner group. Example: [9, 2].
            allows_public_repositories (boolean): Whether the runner group can be used by `public` repositories.
            restricted_to_workflows (boolean): If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.
            selected_workflows (array): List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.
            network_configuration_id (string): The identifier of a hosted compute network configuration.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'visibility': visibility,
            'selected_repository_ids': selected_repository_ids,
            'runners': runners,
            'allows_public_repositories': allows_public_repositories,
            'restricted_to_workflows': restricted_to_workflows,
            'selected_workflows': selected_workflows,
            'network_configuration_id': network_configuration_id,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/actions/runner-groups"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_runner_group(self, org: str, runner_group_id: str) -> dict[str, Any]:
        """
        Retrieves a list of GitHub-hosted runners in a specific runner group for an organization using the GitHub Actions API.

        Args:
            org (string): org
            runner_group_id (string): runner_group_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if runner_group_id is None:
            raise ValueError("Missing required parameter 'runner_group_id'.")
        url = f"{self.base_url}/orgs/{org}/actions/runner-groups/{runner_group_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def patch_org_runner_group(self, org: str, runner_group_id: str, name: str, visibility: Optional[str] = None, allows_public_repositories: Optional[bool] = None, restricted_to_workflows: Optional[bool] = None, selected_workflows: Optional[List[str]] = None, network_configuration_id: Optional[str] = None) -> dict[str, Any]:
        """
        Updates the name and visibility settings of a self-hosted runner group for a GitHub organization.

        Args:
            org (string): org
            runner_group_id (string): runner_group_id
            name (string): Name of the runner group. Example: 'Expensive hardware runners'.
            visibility (string): Visibility of a runner group. You can select all repositories, select individual repositories, or all private repositories. Example: 'selected'.
            allows_public_repositories (boolean): Whether the runner group can be used by `public` repositories.
            restricted_to_workflows (boolean): If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.
            selected_workflows (array): List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.
            network_configuration_id (string): The identifier of a hosted compute network configuration.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if runner_group_id is None:
            raise ValueError("Missing required parameter 'runner_group_id'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'visibility': visibility,
            'allows_public_repositories': allows_public_repositories,
            'restricted_to_workflows': restricted_to_workflows,
            'selected_workflows': selected_workflows,
            'network_configuration_id': network_configuration_id,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/actions/runner-groups/{runner_group_id}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_runner_group(self, org: str, runner_group_id: str) -> Any:
        """
        Deletes a self-hosted runner group from a GitHub organization and returns a 204 No Content status upon success.

        Args:
            org (string): org
            runner_group_id (string): runner_group_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if runner_group_id is None:
            raise ValueError("Missing required parameter 'runner_group_id'.")
        url = f"{self.base_url}/orgs/{org}/actions/runner-groups/{runner_group_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_runner_group_hosted_runners(self, org: str, runner_group_id: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of GitHub-hosted runners within a specified runner group in an organization using the GitHub API.

        Args:
            org (string): org
            runner_group_id (string): runner_group_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if runner_group_id is None:
            raise ValueError("Missing required parameter 'runner_group_id'.")
        url = f"{self.base_url}/orgs/{org}/actions/runner-groups/{runner_group_id}/hosted-runners"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_runner_group_repos(self, org: str, runner_group_id: str, page: Optional[int] = None, per_page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a paginated list of repositories associated with a specific runner group in a GitHub organization.

        Args:
            org (string): org
            runner_group_id (string): runner_group_id
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if runner_group_id is None:
            raise ValueError("Missing required parameter 'runner_group_id'.")
        url = f"{self.base_url}/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories"
        query_params = {k: v for k, v in [('page', page), ('per_page', per_page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_runner_group_repo(self, org: str, runner_group_id: str, selected_repository_ids: List[int]) -> Any:
        """
        Sets the list of repositories with access to a self-hosted runner group in a GitHub organization.

        Args:
            org (string): org
            runner_group_id (string): runner_group_id
            selected_repository_ids (array): List of repository IDs that can access the runner group. Example: [32, 91].

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if runner_group_id is None:
            raise ValueError("Missing required parameter 'runner_group_id'.")
        request_body_data = None
        request_body_data = {
            'selected_repository_ids': selected_repository_ids,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_runner_group_repository(self, org: str, runner_group_id: str, repository_id: str) -> Any:
        """
        Adds a repository to a self-hosted runner group in GitHub Actions, enabling workflow access to the group's runners.

        Args:
            org (string): org
            runner_group_id (string): runner_group_id
            repository_id (string): repository_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if runner_group_id is None:
            raise ValueError("Missing required parameter 'runner_group_id'.")
        if repository_id is None:
            raise ValueError("Missing required parameter 'repository_id'.")
        request_body_data = None
        url = f"{self.base_url}/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_repo_from_runner_group(self, org: str, runner_group_id: str, repository_id: str) -> Any:
        """
        Removes repository access from a self-hosted runner group in an organization using the GitHub API.

        Args:
            org (string): org
            runner_group_id (string): runner_group_id
            repository_id (string): repository_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if runner_group_id is None:
            raise ValueError("Missing required parameter 'runner_group_id'.")
        if repository_id is None:
            raise ValueError("Missing required parameter 'repository_id'.")
        url = f"{self.base_url}/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_runner_group_runners(self, org: str, runner_group_id: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a paginated list of self-hosted runners associated with a specific runner group in a GitHub organization.

        Args:
            org (string): org
            runner_group_id (string): runner_group_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if runner_group_id is None:
            raise ValueError("Missing required parameter 'runner_group_id'.")
        url = f"{self.base_url}/orgs/{org}/actions/runner-groups/{runner_group_id}/runners"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_runner_group_runners(self, org: str, runner_group_id: str, runners: List[int]) -> Any:
        """
        Updates a self-hosted runner in a specified runner group for an organization using the GitHub API.

        Args:
            org (string): org
            runner_group_id (string): runner_group_id
            runners (array): List of runner IDs to add to the runner group. Example: [9, 2].

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if runner_group_id is None:
            raise ValueError("Missing required parameter 'runner_group_id'.")
        request_body_data = None
        request_body_data = {
            'runners': runners,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/actions/runner-groups/{runner_group_id}/runners"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_runner_group_runner_by_id(self, org: str, runner_group_id: str, runner_id: str) -> Any:
        """
        Adds a self-hosted runner to a specified organization runner group using the GitHub API and returns a success status upon completion.

        Args:
            org (string): org
            runner_group_id (string): runner_group_id
            runner_id (string): runner_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if runner_group_id is None:
            raise ValueError("Missing required parameter 'runner_group_id'.")
        if runner_id is None:
            raise ValueError("Missing required parameter 'runner_id'.")
        request_body_data = None
        url = f"{self.base_url}/orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_runner(self, org: str, runner_group_id: str, runner_id: str) -> Any:
        """
        Deletes a self-hosted runner from a GitHub Actions runner group within an organization using the "DELETE" method.

        Args:
            org (string): org
            runner_group_id (string): runner_group_id
            runner_id (string): runner_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if runner_group_id is None:
            raise ValueError("Missing required parameter 'runner_group_id'.")
        if runner_id is None:
            raise ValueError("Missing required parameter 'runner_id'.")
        url = f"{self.base_url}/orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_org_runners(self, org: str, name: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Lists all self-hosted runners configured in an organization, with optional filtering by runner name.

        Args:
            org (string): org
            name (string): The name of a self-hosted runner.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/actions/runners"
        query_params = {k: v for k, v in [('name', name), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_runner_downloads(self, org: str) -> list[Any]:
        """
        Lists runner applications for an organization, returning details such as operating system and download URL for managing self-hosted runners.

        Args:
            org (string): org

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/actions/runners/downloads"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def generate_jit_config(self, org: str, name: str, runner_group_id: int, labels: List[str], work_folder: Optional[str] = None) -> dict[str, Any]:
        """
        Generates a configuration for a just-in-time runner for an organization using the GitHub API.

        Args:
            org (string): org
            name (string): The name of the new runner. Example: 'New runner'.
            runner_group_id (integer): The ID of the runner group to register the runner to. Example: 1.
            labels (array): The names of the custom labels to add to the runner. **Minimum items**: 1. **Maximum items**: 100. Example: ['self-hosted', 'X64', 'macOS', 'no-gpu'].
            work_folder (string): The working directory to be used for job execution, relative to the runner install directory. Example: '_work'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'runner_group_id': runner_group_id,
            'labels': labels,
            'work_folder': work_folder,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/actions/runners/generate-jitconfig"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def register_runner_token(self, org: str) -> dict[str, Any]:
        """
        Generates a registration token for adding self-hosted runners to a GitHub organization.

        Args:
            org (string): org

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        url = f"{self.base_url}/orgs/{org}/actions/runners/registration-token"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def remove_org_token(self, org: str) -> dict[str, Any]:
        """
        Creates a temporary token to remove a self-hosted runner from a GitHub organization, valid for one hour.

        Args:
            org (string): org

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        url = f"{self.base_url}/orgs/{org}/actions/runners/remove-token"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_runner_info(self, org: str, runner_id: str) -> dict[str, Any]:
        """
        Retrieves details for a specific self-hosted runner in an organization using the GitHub Actions API.

        Args:
            org (string): org
            runner_id (string): runner_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if runner_id is None:
            raise ValueError("Missing required parameter 'runner_id'.")
        url = f"{self.base_url}/orgs/{org}/actions/runners/{runner_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_runner_by_id(self, org: str, runner_id: str) -> Any:
        """
        Deletes a self-hosted runner from a specified GitHub organization using the GitHub Actions API.

        Args:
            org (string): org
            runner_id (string): runner_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if runner_id is None:
            raise ValueError("Missing required parameter 'runner_id'.")
        url = f"{self.base_url}/orgs/{org}/actions/runners/{runner_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_runner_labels(self, org: str, runner_id: str) -> dict[str, Any]:
        """
        Retrieves the labels associated with a self-hosted runner in an organization using the GitHub API.

        Args:
            org (string): org
            runner_id (string): runner_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if runner_id is None:
            raise ValueError("Missing required parameter 'runner_id'.")
        url = f"{self.base_url}/orgs/{org}/actions/runners/{runner_id}/labels"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def add_runner_labels(self, org: str, runner_id: str, labels: List[str]) -> dict[str, Any]:
        """
        Replaces all custom labels for a self-hosted runner in a GitHub organization with new labels.

        Args:
            org (string): org
            runner_id (string): runner_id
            labels (array): The names of the custom labels to add to the runner. Example: ['gpu', 'accelerated'].

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if runner_id is None:
            raise ValueError("Missing required parameter 'runner_id'.")
        request_body_data = None
        request_body_data = {
            'labels': labels,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/actions/runners/{runner_id}/labels"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_runner_labels(self, org: str, runner_id: str, labels: List[str]) -> dict[str, Any]:
        """
        Adds custom labels to a self-hosted runner for an organization in GitHub Actions using the specified runner ID.

        Args:
            org (string): org
            runner_id (string): runner_id
            labels (array): The names of the custom labels to set for the runner. You can pass an empty array to remove all custom labels. Example: ['gpu', 'accelerated'].

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if runner_id is None:
            raise ValueError("Missing required parameter 'runner_id'.")
        request_body_data = None
        request_body_data = {
            'labels': labels,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/actions/runners/{runner_id}/labels"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_runner_label(self, org: str, runner_id: str) -> dict[str, Any]:
        """
        Removes a specified custom label from a self-hosted runner in a GitHub organization and returns the remaining labels.

        Args:
            org (string): org
            runner_id (string): runner_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if runner_id is None:
            raise ValueError("Missing required parameter 'runner_id'.")
        url = f"{self.base_url}/orgs/{org}/actions/runners/{runner_id}/labels"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_label_by_runner_id(self, org: str, runner_id: str, name: str) -> dict[str, Any]:
        """
        Removes a custom label from a self-hosted runner for an organization, returning the remaining labels from the runner if successful.

        Args:
            org (string): org
            runner_id (string): runner_id
            name (string): name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if runner_id is None:
            raise ValueError("Missing required parameter 'runner_id'.")
        if name is None:
            raise ValueError("Missing required parameter 'name'.")
        url = f"{self.base_url}/orgs/{org}/actions/runners/{runner_id}/labels/{name}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_list_org_secrets(self, org: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of organization-level GitHub Actions secrets without exposing their encrypted values.

        Args:
            org (string): org
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/actions/secrets"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_get_org_public_key(self, org: str) -> dict[str, Any]:
        """
        Retrieves the public key required to encrypt secrets for GitHub Actions at the organization level.

        Args:
            org (string): org

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/actions/secrets/public-key"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_get_org_secret(self, org: str, secret_name: str) -> dict[str, Any]:
        """
        Retrieves a specific GitHub Actions secret by name for an organization without revealing its encrypted value.

        Args:
            org (string): org
            secret_name (string): secret_name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        url = f"{self.base_url}/orgs/{org}/actions/secrets/{secret_name}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_secret(self, org: str, secret_name: str, encrypted_value: str, key_id: str, visibility: str, selected_repository_ids: Optional[List[int]] = None) -> dict[str, Any]:
        """
        Creates or updates an organization GitHub Actions secret with an encrypted value using the GitHub REST API.

        Args:
            org (string): org
            secret_name (string): secret_name
            encrypted_value (string): Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/actions/secrets#get-an-organization-public-key) endpoint. Example: 'c2VjcmV0'.
            key_id (string): ID of the key you used to encrypt the secret. Example: '012345678912345678'.
            visibility (string): Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret. Example: 'selected'.
            selected_repository_ids (array): An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/actions/secrets#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/actions/secrets#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/actions/secrets#remove-selected-repository-from-an-organization-secret) endpoints. Example: [1296269, 1296280].

        Returns:
            dict[str, Any]: Response when creating a secret

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        request_body_data = None
        request_body_data = {
            'encrypted_value': encrypted_value,
            'key_id': key_id,
            'visibility': visibility,
            'selected_repository_ids': selected_repository_ids,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/actions/secrets/{secret_name}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_delete_org_secret(self, org: str, secret_name: str) -> Any:
        """
        Deletes a GitHub Actions organization secret and returns a 204 No Content status upon success.

        Args:
            org (string): org
            secret_name (string): secret_name

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        url = f"{self.base_url}/orgs/{org}/actions/secrets/{secret_name}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_secret_repositories(self, org: str, secret_name: str, page: Optional[int] = None, per_page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of repositories that have access to a specific organization secret using the GitHub API.

        Args:
            org (string): org
            secret_name (string): secret_name
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        url = f"{self.base_url}/orgs/{org}/actions/secrets/{secret_name}/repositories"
        query_params = {k: v for k, v in [('page', page), ('per_page', per_page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def put_org_secret_repo_access(self, org: str, secret_name: str, selected_repository_ids: List[int]) -> Any:
        """
        Updates the list of repositories that can access a specific organization secret in GitHub Actions, returning a 204 status upon success.

        Args:
            org (string): org
            secret_name (string): secret_name
            selected_repository_ids (array): An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Add selected repository to an organization secret](https://docs.github.com/rest/actions/secrets#add-selected-repository-to-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/actions/secrets#remove-selected-repository-from-an-organization-secret) endpoints. Example: [64780797].

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        request_body_data = None
        request_body_data = {
            'selected_repository_ids': selected_repository_ids,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/actions/secrets/{secret_name}/repositories"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_secret_repo(self, org: str, secret_name: str, repository_id: str) -> Any:
        """
        Updates a secret for a specified repository within an organization using the GitHub API, allowing the secret to be used in GitHub Actions workflows for that repository.

        Args:
            org (string): org
            secret_name (string): secret_name
            repository_id (string): repository_id

        Returns:
            Any: No Content when repository was added to the selected list

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        if repository_id is None:
            raise ValueError("Missing required parameter 'repository_id'.")
        request_body_data = None
        url = f"{self.base_url}/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_org_secret_repo_by_id(self, org: str, secret_name: str, repository_id: str) -> Any:
        """
        Deletes a secret from a specific repository within an organization using the GitHub API.

        Args:
            org (string): org
            secret_name (string): secret_name
            repository_id (string): repository_id

        Returns:
            Any: Response when repository was removed from the selected list

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        if repository_id is None:
            raise ValueError("Missing required parameter 'repository_id'.")
        url = f"{self.base_url}/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_list_org_variables(self, org: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of organization-level GitHub Actions variables using the GitHub API.

        Args:
            org (string): org
            per_page (integer): The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/actions/variables"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_create_org_variable(self, org: str, name: str, value: str, visibility: str, selected_repository_ids: Optional[List[int]] = None) -> dict[str, Any]:
        """
        Creates an organization variable using the GitHub Actions API, allowing the variable to be referenced across workflows in the specified organization.

        Args:
            org (string): org
            name (string): The name of the variable. Example: 'USERNAME'.
            value (string): The value of the variable. Example: 'octocat'.
            visibility (string): The type of repositories in the organization that can access the variable. `selected` means only the repositories specified by `selected_repository_ids` can access the variable. Example: 'selected'.
            selected_repository_ids (array): An array of repository ids that can access the organization variable. You can only provide a list of repository ids when the `visibility` is set to `selected`. Example: [1296269, 1296280].

        Returns:
            dict[str, Any]: Response when creating a variable

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'value': value,
            'visibility': visibility,
            'selected_repository_ids': selected_repository_ids,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/actions/variables"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_get_org_variable(self, org: str, name: str) -> dict[str, Any]:
        """
        Retrieves a specific organization-level GitHub Actions variable by name.

        Args:
            org (string): org
            name (string): name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if name is None:
            raise ValueError("Missing required parameter 'name'.")
        url = f"{self.base_url}/orgs/{org}/actions/variables/{name}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_update_org_variable(self, org: str, name: str, name_body: Optional[str] = None, value: Optional[str] = None, visibility: Optional[str] = None, selected_repository_ids: Optional[List[int]] = None) -> Any:
        """
        Updates an organization variable in a GitHub organization using the "PATCH" method, allowing dynamic adjustments to GitHub Actions workflows by changing the variable's value.

        Args:
            org (string): org
            name (string): name
            name_body (string): The name of the variable. Example: 'USERNAME'.
            value (string): The value of the variable. Example: 'octocat'.
            visibility (string): The type of repositories in the organization that can access the variable. `selected` means only the repositories specified by `selected_repository_ids` can access the variable. Example: 'selected'.
            selected_repository_ids (array): An array of repository ids that can access the organization variable. You can only provide a list of repository ids when the `visibility` is set to `selected`. Example: [1296269, 1296280].

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if name is None:
            raise ValueError("Missing required parameter 'name'.")
        request_body_data = None
        request_body_data = {
            'name': name_body,
            'value': value,
            'visibility': visibility,
            'selected_repository_ids': selected_repository_ids,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/actions/variables/{name}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_delete_org_variable(self, org: str, name: str) -> Any:
        """
        Deletes an organization variable in GitHub Actions using the specified organization name and variable name, returning a successful status when completed.

        Args:
            org (string): org
            name (string): name

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if name is None:
            raise ValueError("Missing required parameter 'name'.")
        url = f"{self.base_url}/orgs/{org}/actions/variables/{name}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_variable_repos(self, org: str, name: str, page: Optional[int] = None, per_page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of repositories within an organization where a specific GitHub Actions variable is used, using the GET method.

        Args:
            org (string): org
            name (string): name
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if name is None:
            raise ValueError("Missing required parameter 'name'.")
        url = f"{self.base_url}/orgs/{org}/actions/variables/{name}/repositories"
        query_params = {k: v for k, v in [('page', page), ('per_page', per_page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_variable_repository(self, org: str, name: str, selected_repository_ids: List[int]) -> Any:
        """
        Adds or updates the list of repositories with access to a specific organization variable in GitHub Actions.

        Args:
            org (string): org
            name (string): name
            selected_repository_ids (array): The IDs of the repositories that can access the organization variable. Example: [64780797].

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if name is None:
            raise ValueError("Missing required parameter 'name'.")
        request_body_data = None
        request_body_data = {
            'selected_repository_ids': selected_repository_ids,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/actions/variables/{name}/repositories"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_org_action_variable_repo(self, org: str, name: str, repository_id: str) -> Any:
        """
        Updates organization-scoped variables for a specific repository using the GitHub API, allowing you to manage variable accessibility across selected repositories within an organization.

        Args:
            org (string): org
            name (string): name
            repository_id (string): repository_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if name is None:
            raise ValueError("Missing required parameter 'name'.")
        if repository_id is None:
            raise ValueError("Missing required parameter 'repository_id'.")
        request_body_data = None
        url = f"{self.base_url}/orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_repository_variable(self, org: str, name: str, repository_id: str) -> Any:
        """
        Removes a specific repository's association with an organization-level variable in GitHub Actions.

        Args:
            org (string): org
            name (string): name
            repository_id (string): repository_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if name is None:
            raise ValueError("Missing required parameter 'name'.")
        if repository_id is None:
            raise ValueError("Missing required parameter 'repository_id'.")
        url = f"{self.base_url}/orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_list_attestations(self, org: str, subject_digest: str, per_page: Optional[int] = None, before: Optional[str] = None, after: Optional[str] = None, predicate_type: Optional[str] = None) -> dict[str, Any]:
        """
        Retrieves artifact attestations for a specified subject digest within an organization, allowing for the verification of software build provenance and integrity.

        Args:
            org (string): org
            subject_digest (string): subject_digest
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            before (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            after (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            predicate_type (string): Optional filter for fetching attestations with a given predicate type.
        This option accepts `provenance`, `sbom`, or freeform text for custom predicate types.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if subject_digest is None:
            raise ValueError("Missing required parameter 'subject_digest'.")
        url = f"{self.base_url}/orgs/{org}/attestations/{subject_digest}"
        query_params = {k: v for k, v in [('per_page', per_page), ('before', before), ('after', after), ('predicate_type', predicate_type)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_list_blocked_users(self, org: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of users blocked by the specified GitHub organization.

        Args:
            org (string): org
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/blocks"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_check_blocked_user(self, org: str, username: str) -> Any:
        """
        Checks if a specified user is blocked by a given GitHub organization.

        Args:
            org (string): org
            username (string): username

        Returns:
            Any: If the user is blocked

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/orgs/{org}/blocks/{username}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_block_user(self, org: str, username: str) -> Any:
        """
        Blocks a specified user from a GitHub organization and returns a `204` status code upon success.

        Args:
            org (string): org
            username (string): username

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        request_body_data = None
        url = f"{self.base_url}/orgs/{org}/blocks/{username}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_unblock_user(self, org: str, username: str) -> Any:
        """
        Unblocks a specified user from a GitHub organization using the GitHub API.

        Args:
            org (string): org
            username (string): username

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/orgs/{org}/blocks/{username}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def campaigns_list_org_campaigns(self, org: str, page: Optional[int] = None, per_page: Optional[int] = None, direction: Optional[str] = None, state: Optional[str] = None, sort: Optional[str] = None) -> list[Any]:
        """
        Retrieves security campaigns for a GitHub organization, requiring owner or security manager permissions.

        Args:
            org (string): org
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            direction (string): The direction to sort the results by.
            state (string): If specified, only campaigns with this state will be returned.
            sort (string): The property by which to sort the results.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            campaigns
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/campaigns"
        query_params = {k: v for k, v in [('page', page), ('per_page', per_page), ('direction', direction), ('state', state), ('sort', sort)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def campaigns_create_campaign(self, org: str, name: str, description: str, ends_at: str, code_scanning_alerts: List[dict[str, Any]], managers: Optional[List[str]] = None, team_managers: Optional[List[str]] = None, contact_link: Optional[str] = None, generate_issues: Optional[bool] = None) -> dict[str, Any]:
        """
        Creates a new campaign within a specified organization using the POST method and returns a response based on the operation's success or failure.

        Args:
            org (string): org
            name (string): The name of the campaign Example: 'Critical CodeQL alerts'.
            description (string): A description for the campaign Example: 'Address critical alerts before they are exploited to prevent breaches, protect sensitive data, and mitigate financial and reputational damage.'.
            ends_at (string): The end date and time of the campaign. The date must be in the future. Example: '2024-03-14T00:00:00Z'.
            code_scanning_alerts (array): The code scanning alerts to include in this campaign Example: [{'repository_id': 1296269, 'alert_numbers': [1, 2]}].
            managers (array): The logins of the users to set as the campaign managers. At this time, only a single manager can be supplied. Example: ['octocat'].
            team_managers (array): The slugs of the teams to set as the campaign managers.
            contact_link (string): The contact link of the campaign. Must be a URI.
            generate_issues (boolean): If true, will automatically generate issues for the campaign. The default is false.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            campaigns
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'description': description,
            'managers': managers,
            'team_managers': team_managers,
            'ends_at': ends_at,
            'contact_link': contact_link,
            'code_scanning_alerts': code_scanning_alerts,
            'generate_issues': generate_issues,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/campaigns"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def campaigns_get_campaign_summary(self, org: str, campaign_number: str) -> dict[str, Any]:
        """
        Retrieves campaign details for a specific organization using the provided campaign number.

        Args:
            org (string): org
            campaign_number (string): campaign_number

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            campaigns
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if campaign_number is None:
            raise ValueError("Missing required parameter 'campaign_number'.")
        url = f"{self.base_url}/orgs/{org}/campaigns/{campaign_number}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def campaigns_update_campaign(self, org: str, campaign_number: str, name: Optional[str] = None, description: Optional[str] = None, managers: Optional[List[str]] = None, team_managers: Optional[List[str]] = None, ends_at: Optional[str] = None, contact_link: Optional[str] = None, state: Optional[str] = None) -> dict[str, Any]:
        """
        Updates a specific campaign within an organization using the PATCH method, allowing for partial modifications to campaign details.

        Args:
            org (string): org
            campaign_number (string): campaign_number
            name (string): The name of the campaign Example: 'Critical CodeQL alerts'.
            description (string): A description for the campaign
            managers (array): The logins of the users to set as the campaign managers. At this time, only a single manager can be supplied.
            team_managers (array): The slugs of the teams to set as the campaign managers.
            ends_at (string): The end date and time of the campaign, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.
            contact_link (string): The contact link of the campaign. Must be a URI.
            state (string): Indicates whether a campaign is open or closed

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            campaigns
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if campaign_number is None:
            raise ValueError("Missing required parameter 'campaign_number'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'description': description,
            'managers': managers,
            'team_managers': team_managers,
            'ends_at': ends_at,
            'contact_link': contact_link,
            'state': state,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/campaigns/{campaign_number}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def campaigns_delete_campaign(self, org: str, campaign_number: str) -> Any:
        """
        Deletes a security campaign in an organization using the GitHub API.

        Args:
            org (string): org
            campaign_number (string): campaign_number

        Returns:
            Any: Deletion successful

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            campaigns
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if campaign_number is None:
            raise ValueError("Missing required parameter 'campaign_number'.")
        url = f"{self.base_url}/orgs/{org}/campaigns/{campaign_number}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_org_code_scanning_alerts(self, org: str, tool_name: Optional[str] = None, tool_guid: Optional[str] = None, before: Optional[str] = None, after: Optional[str] = None, page: Optional[int] = None, per_page: Optional[int] = None, direction: Optional[str] = None, state: Optional[str] = None, sort: Optional[str] = None, severity: Optional[str] = None) -> list[Any]:
        """
        Retrieves a list of code scanning alerts for all repositories in a GitHub organization, optionally filtered by state, severity, and analysis tool.

        Args:
            org (string): org
            tool_name (string): The name of a code scanning tool. Only results by this tool will be listed. You can specify the tool by using either `tool_name` or `tool_guid`, but not both.
            tool_guid (string): The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code scanning tools may not include a GUID in their analysis data. You can specify the tool by using either `tool_guid` or `tool_name`, but not both.
            before (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            after (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            direction (string): The direction to sort the results by.
            state (string): If specified, only code scanning alerts with this state will be returned.
            sort (string): The property by which to sort the results.
            severity (string): If specified, only code scanning alerts with this severity will be returned.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-scanning
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/code-scanning/alerts"
        query_params = {k: v for k, v in [('tool_name', tool_name), ('tool_guid', tool_guid), ('before', before), ('after', after), ('page', page), ('per_page', per_page), ('direction', direction), ('state', state), ('sort', sort), ('severity', severity)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_code_configurations(self, org: str, target_type: Optional[str] = None, per_page: Optional[int] = None, before: Optional[str] = None, after: Optional[str] = None) -> list[Any]:
        """
        Retrieves code security configurations for a GitHub organization with pagination support.

        Args:
            org (string): org
            target_type (string): The target type of the code security configuration
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](
            before (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            after (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-security
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/code-security/configurations"
        query_params = {k: v for k, v in [('target_type', target_type), ('per_page', per_page), ('before', before), ('after', after)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_org_code_config(self, org: str, name: str, description: str, advanced_security: Optional[str] = None, dependency_graph: Optional[str] = None, dependency_graph_autosubmit_action: Optional[str] = None, dependency_graph_autosubmit_action_options: Optional[dict[str, Any]] = None, dependabot_alerts: Optional[str] = None, dependabot_security_updates: Optional[str] = None, code_scanning_default_setup: Optional[str] = None, code_scanning_default_setup_options: Optional[dict[str, Any]] = None, code_scanning_delegated_alert_dismissal: Optional[str] = None, secret_scanning: Optional[str] = None, secret_scanning_push_protection: Optional[str] = None, secret_scanning_delegated_bypass: Optional[str] = None, secret_scanning_delegated_bypass_options: Optional[dict[str, Any]] = None, secret_scanning_validity_checks: Optional[str] = None, secret_scanning_non_provider_patterns: Optional[str] = None, secret_scanning_generic_secrets: Optional[str] = None, secret_scanning_delegated_alert_dismissal: Optional[str] = None, private_vulnerability_reporting: Optional[str] = None, enforcement: Optional[str] = None) -> dict[str, Any]:
        """
        Creates a custom code security configuration for a GitHub organization, enabling specific security features like advanced security, dependabot alerts, and secret scanning.

        Args:
            org (string): org
            name (string): The name of the code security configuration. Must be unique within the organization. Example: 'octo-org recommended settings'.
            description (string): A description of the code security configuration Example: 'This is a code security configuration for octo-org'.
            advanced_security (string): The enablement status of GitHub Advanced Security features. `enabled` will enable both Code Security and Secret Protection features. Example: 'enabled'.
            dependency_graph (string): The enablement status of Dependency Graph
            dependency_graph_autosubmit_action (string): The enablement status of Automatic dependency submission
            dependency_graph_autosubmit_action_options (object): Feature options for Automatic dependency submission
            dependabot_alerts (string): The enablement status of Dependabot alerts Example: 'enabled'.
            dependabot_security_updates (string): The enablement status of Dependabot security updates Example: 'not_set'.
            code_scanning_default_setup (string): The enablement status of code scanning default setup
            code_scanning_default_setup_options (object): Feature options for code scanning default setup
            code_scanning_delegated_alert_dismissal (string): The enablement status of code scanning delegated alert dismissal
            secret_scanning (string): The enablement status of secret scanning Example: 'enabled'.
            secret_scanning_push_protection (string): The enablement status of secret scanning push protection
            secret_scanning_delegated_bypass (string): The enablement status of secret scanning delegated bypass
            secret_scanning_delegated_bypass_options (object): Feature options for secret scanning delegated bypass
            secret_scanning_validity_checks (string): The enablement status of secret scanning validity checks
            secret_scanning_non_provider_patterns (string): The enablement status of secret scanning non provider patterns
            secret_scanning_generic_secrets (string): The enablement status of Copilot secret scanning
            secret_scanning_delegated_alert_dismissal (string): The enablement status of secret scanning delegated alert dismissal
            private_vulnerability_reporting (string): The enablement status of private vulnerability reporting
            enforcement (string): The enforcement status for a security configuration

        Returns:
            dict[str, Any]: Successfully created code security configuration

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-security
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'description': description,
            'advanced_security': advanced_security,
            'dependency_graph': dependency_graph,
            'dependency_graph_autosubmit_action': dependency_graph_autosubmit_action,
            'dependency_graph_autosubmit_action_options': dependency_graph_autosubmit_action_options,
            'dependabot_alerts': dependabot_alerts,
            'dependabot_security_updates': dependabot_security_updates,
            'code_scanning_default_setup': code_scanning_default_setup,
            'code_scanning_default_setup_options': code_scanning_default_setup_options,
            'code_scanning_delegated_alert_dismissal': code_scanning_delegated_alert_dismissal,
            'secret_scanning': secret_scanning,
            'secret_scanning_push_protection': secret_scanning_push_protection,
            'secret_scanning_delegated_bypass': secret_scanning_delegated_bypass,
            'secret_scanning_delegated_bypass_options': secret_scanning_delegated_bypass_options,
            'secret_scanning_validity_checks': secret_scanning_validity_checks,
            'secret_scanning_non_provider_patterns': secret_scanning_non_provider_patterns,
            'secret_scanning_generic_secrets': secret_scanning_generic_secrets,
            'secret_scanning_delegated_alert_dismissal': secret_scanning_delegated_alert_dismissal,
            'private_vulnerability_reporting': private_vulnerability_reporting,
            'enforcement': enforcement,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/code-security/configurations"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_code_security_defaults(self, org: str) -> list[Any]:
        """
        Retrieves the default code security configurations for an organization.

        Args:
            org (string): org

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-security
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/code-security/configurations/defaults"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def detach_code_security_config(self, org: str, selected_repository_ids: Optional[List[int]] = None) -> Any:
        """
        Detaches code security configurations from specified repositories while preserving their individual security settings.

        Args:
            org (string): org
            selected_repository_ids (array): An array of repository IDs to detach from configurations. Example: [32, 91].

        Returns:
            Any: A header with no content is returned.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-security
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = {
            'selected_repository_ids': selected_repository_ids,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/code-security/configurations/detach"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_config_by_id(self, org: str, configuration_id: str) -> dict[str, Any]:
        """
        Retrieves a specific code security configuration for an organization using its unique identifier.

        Args:
            org (string): org
            configuration_id (string): configuration_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-security
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if configuration_id is None:
            raise ValueError("Missing required parameter 'configuration_id'.")
        url = f"{self.base_url}/orgs/{org}/code-security/configurations/{configuration_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def patch_org_code_security_config(self, org: str, configuration_id: str, name: Optional[str] = None, description: Optional[str] = None, advanced_security: Optional[str] = None, dependency_graph: Optional[str] = None, dependency_graph_autosubmit_action: Optional[str] = None, dependency_graph_autosubmit_action_options: Optional[dict[str, Any]] = None, dependabot_alerts: Optional[str] = None, dependabot_security_updates: Optional[str] = None, code_scanning_default_setup: Optional[str] = None, code_scanning_default_setup_options: Optional[dict[str, Any]] = None, code_scanning_delegated_alert_dismissal: Optional[str] = None, secret_scanning: Optional[str] = None, secret_scanning_push_protection: Optional[str] = None, secret_scanning_delegated_bypass: Optional[str] = None, secret_scanning_delegated_bypass_options: Optional[dict[str, Any]] = None, secret_scanning_validity_checks: Optional[str] = None, secret_scanning_non_provider_patterns: Optional[str] = None, secret_scanning_generic_secrets: Optional[str] = None, secret_scanning_delegated_alert_dismissal: Optional[str] = None, private_vulnerability_reporting: Optional[str] = None, enforcement: Optional[str] = None) -> dict[str, Any]:
        """
        Updates a code security configuration for a GitHub organization via the GitHub API.

        Args:
            org (string): org
            configuration_id (string): configuration_id
            name (string): The name of the code security configuration. Must be unique within the organization. Example: 'octo-org recommended settings v2'.
            description (string): A description of the code security configuration
            advanced_security (string): The enablement status of GitHub Advanced Security features. `enabled` will enable both Code Security and Secret Protection features.
            dependency_graph (string): The enablement status of Dependency Graph
            dependency_graph_autosubmit_action (string): The enablement status of Automatic dependency submission
            dependency_graph_autosubmit_action_options (object): Feature options for Automatic dependency submission
            dependabot_alerts (string): The enablement status of Dependabot alerts
            dependabot_security_updates (string): The enablement status of Dependabot security updates
            code_scanning_default_setup (string): The enablement status of code scanning default setup Example: 'enabled'.
            code_scanning_default_setup_options (object): Feature options for code scanning default setup
            code_scanning_delegated_alert_dismissal (string): The enablement status of code scanning delegated alert dismissal
            secret_scanning (string): The enablement status of secret scanning Example: 'disabled'.
            secret_scanning_push_protection (string): The enablement status of secret scanning push protection
            secret_scanning_delegated_bypass (string): The enablement status of secret scanning delegated bypass
            secret_scanning_delegated_bypass_options (object): Feature options for secret scanning delegated bypass
            secret_scanning_validity_checks (string): The enablement status of secret scanning validity checks
            secret_scanning_non_provider_patterns (string): The enablement status of secret scanning non-provider patterns
            secret_scanning_generic_secrets (string): The enablement status of Copilot secret scanning
            secret_scanning_delegated_alert_dismissal (string): The enablement status of secret scanning delegated alert dismissal
            private_vulnerability_reporting (string): The enablement status of private vulnerability reporting
            enforcement (string): The enforcement status for a security configuration

        Returns:
            dict[str, Any]: Response when a configuration is updated

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-security
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if configuration_id is None:
            raise ValueError("Missing required parameter 'configuration_id'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'description': description,
            'advanced_security': advanced_security,
            'dependency_graph': dependency_graph,
            'dependency_graph_autosubmit_action': dependency_graph_autosubmit_action,
            'dependency_graph_autosubmit_action_options': dependency_graph_autosubmit_action_options,
            'dependabot_alerts': dependabot_alerts,
            'dependabot_security_updates': dependabot_security_updates,
            'code_scanning_default_setup': code_scanning_default_setup,
            'code_scanning_default_setup_options': code_scanning_default_setup_options,
            'code_scanning_delegated_alert_dismissal': code_scanning_delegated_alert_dismissal,
            'secret_scanning': secret_scanning,
            'secret_scanning_push_protection': secret_scanning_push_protection,
            'secret_scanning_delegated_bypass': secret_scanning_delegated_bypass,
            'secret_scanning_delegated_bypass_options': secret_scanning_delegated_bypass_options,
            'secret_scanning_validity_checks': secret_scanning_validity_checks,
            'secret_scanning_non_provider_patterns': secret_scanning_non_provider_patterns,
            'secret_scanning_generic_secrets': secret_scanning_generic_secrets,
            'secret_scanning_delegated_alert_dismissal': secret_scanning_delegated_alert_dismissal,
            'private_vulnerability_reporting': private_vulnerability_reporting,
            'enforcement': enforcement,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/code-security/configurations/{configuration_id}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_code_security_config(self, org: str, configuration_id: str) -> Any:
        """
        Deletes a code security configuration from an organization, detaching repositories while retaining their existing security settings.

        Args:
            org (string): org
            configuration_id (string): configuration_id

        Returns:
            Any: A header with no content is returned.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-security
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if configuration_id is None:
            raise ValueError("Missing required parameter 'configuration_id'.")
        url = f"{self.base_url}/orgs/{org}/code-security/configurations/{configuration_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def attach_code_config(self, org: str, configuration_id: str, scope: str, selected_repository_ids: Optional[List[int]] = None) -> dict[str, Any]:
        """
        Attaches a code security configuration to repositories in an organization via the GitHub API.

        Args:
            org (string): org
            configuration_id (string): configuration_id
            scope (string): The type of repositories to attach the configuration to. `selected` means the configuration will be attached to only the repositories specified by `selected_repository_ids` Example: 'selected'.
            selected_repository_ids (array): An array of repository IDs to attach the configuration to. You can only provide a list of repository ids when the `scope` is set to `selected`. Example: [32, 91].

        Returns:
            dict[str, Any]: Accepted

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-security
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if configuration_id is None:
            raise ValueError("Missing required parameter 'configuration_id'.")
        request_body_data = None
        request_body_data = {
            'scope': scope,
            'selected_repository_ids': selected_repository_ids,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/code-security/configurations/{configuration_id}/attach"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def set_default_code_security_config(self, org: str, configuration_id: str, default_for_new_repos: Optional[str] = None) -> dict[str, Any]:
        """
        Configures a specified code security configuration as the default for new repositories within an organization using the GitHub API.

        Args:
            org (string): org
            configuration_id (string): configuration_id
            default_for_new_repos (string): Specify which types of repository this security configuration should be applied to by default. Example: 'all'.

        Returns:
            dict[str, Any]: Default successfully changed.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-security
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if configuration_id is None:
            raise ValueError("Missing required parameter 'configuration_id'.")
        request_body_data = None
        request_body_data = {
            'default_for_new_repos': default_for_new_repos,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/code-security/configurations/{configuration_id}/defaults"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_repo_config(self, org: str, configuration_id: str, per_page: Optional[int] = None, before: Optional[str] = None, after: Optional[str] = None, status: Optional[str] = None) -> list[Any]:
        """
        Retrieves a list of repositories for a specific code security configuration in an organization using the GitHub API.

        Args:
            org (string): org
            configuration_id (string): configuration_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](
            before (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            after (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            status (string): A comma-separated list of statuses. If specified, only repositories with these attachment statuses will be returned. Can be: `all`, `attached`, `attaching`, `detached`, `removed`, `enforced`, `failed`, `updating`, `removed_by_enterprise`

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-security
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if configuration_id is None:
            raise ValueError("Missing required parameter 'configuration_id'.")
        url = f"{self.base_url}/orgs/{org}/code-security/configurations/{configuration_id}/repositories"
        query_params = {k: v for k, v in [('per_page', per_page), ('before', before), ('after', after), ('status', status)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_codespaces(self, org: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Lists all codespaces associated with a specified organization using the "GET" method.

        Args:
            org (string): org
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/codespaces"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_org_codespaces_access(self, org: str, visibility: str, selected_usernames: Optional[List[str]] = None) -> Any:
        """
        Updates access control for GitHub Codespaces in an organization, allowing you to manage which users can access codespaces within the specified organization.

        Args:
            org (string): org
            visibility (string): Which users can access codespaces in the organization. `disabled` means that no users can access codespaces in the organization. Example: 'selected_members'.
            selected_usernames (array): The usernames of the organization members who should have access to codespaces in the organization. Required when `visibility` is `selected_members`. The provided list of usernames will replace any existing value. Example: ['johnDoe', 'atomIO'].

        Returns:
            Any: Response when successfully modifying permissions.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'visibility': visibility,
            'selected_usernames': selected_usernames,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/codespaces/access"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def select_codespace_users(self, org: str, selected_usernames: List[str]) -> Any:
        """
        Adds selected users to access control for GitHub Codespaces within an organization using the GitHub API.

        Args:
            org (string): org
            selected_usernames (array): The usernames of the organization members whose codespaces be billed to the organization. Example: ['johnDoe', 'atomIO'].

        Returns:
            Any: Response when successfully modifying permissions.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'selected_usernames': selected_usernames,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/codespaces/access/selected_users"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_selected_users_access(self, org: str, selected_usernames: List[str]) -> Any:
        """
        Removes selected users from accessing Codespaces in an organization using the GitHub API.

        Args:
            org (string): org
            selected_usernames (array): The usernames of the organization members whose codespaces should not be billed to the organization. Example: ['johnDoe', 'atomIO'].

        Returns:
            Any: Response when successfully modifying permissions.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = {
            'selected_usernames': selected_usernames,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/codespaces/access/selected_users"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def codespaces_list_org_secrets(self, org: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of organization secrets for GitHub Codespaces using the "GET" method at the path "/orgs/{org}/codespaces/secrets".

        Args:
            org (string): org
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/codespaces/secrets"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def codespaces_get_org_public_key(self, org: str) -> dict[str, Any]:
        """
        Retrieves the public key for encrypting secrets in an organization's GitHub Codespaces.

        Args:
            org (string): org

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/codespaces/secrets/public-key"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def codespaces_get_org_secret(self, org: str, secret_name: str) -> dict[str, Any]:
        """
        Retrieves a specific organization-level Codespaces secret without exposing its encrypted value.

        Args:
            org (string): org
            secret_name (string): secret_name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        url = f"{self.base_url}/orgs/{org}/codespaces/secrets/{secret_name}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def put_org_codespace_secret(self, org: str, secret_name: str, visibility: str, encrypted_value: Optional[str] = None, key_id: Optional[str] = None, selected_repository_ids: Optional[List[int]] = None) -> dict[str, Any]:
        """
        Updates or creates a secret for an organization in GitHub Codespaces, specifying the organization and secret name, and returns a status indicating the outcome of the operation.

        Args:
            org (string): org
            secret_name (string): secret_name
            visibility (string): Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret. Example: 'selected'.
            encrypted_value (string): The value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/codespaces/organization-secrets#get-an-organization-public-key) endpoint. Example: 'c2VjcmV0'.
            key_id (string): The ID of the key you used to encrypt the secret. Example: '012345678912345678'.
            selected_repository_ids (array): An array of repository IDs that can access the organization secret. You can only provide a list of repository IDs when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#remove-selected-repository-from-an-organization-secret) endpoints. Example: [1296269, 1296280].

        Returns:
            dict[str, Any]: Response when creating a secret

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        request_body_data = None
        request_body_data = {
            'encrypted_value': encrypted_value,
            'key_id': key_id,
            'visibility': visibility,
            'selected_repository_ids': selected_repository_ids,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/codespaces/secrets/{secret_name}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def codespaces_delete_org_secret(self, org: str, secret_name: str) -> Any:
        """
        Deletes a Codespaces organization secret and removes access from all associated codespaces.

        Args:
            org (string): org
            secret_name (string): secret_name

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        url = f"{self.base_url}/orgs/{org}/codespaces/secrets/{secret_name}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_codespace_secret_repos(self, org: str, secret_name: str, page: Optional[int] = None, per_page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves the list of repositories that a GitHub organization Codespaces secret is configured to access.

        Args:
            org (string): org
            secret_name (string): secret_name
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        url = f"{self.base_url}/orgs/{org}/codespaces/secrets/{secret_name}/repositories"
        query_params = {k: v for k, v in [('page', page), ('per_page', per_page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def put_org_codespace_secret_repo(self, org: str, secret_name: str, selected_repository_ids: List[int]) -> Any:
        """
        Assigns a specific organization-level Codespaces secret to repositories using the GitHub API, returning an empty response on success.

        Args:
            org (string): org
            secret_name (string): secret_name
            selected_repository_ids (array): An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Set selected repositories for an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#set-selected-repositories-for-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#remove-selected-repository-from-an-organization-secret) endpoints. Example: [64780797].

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        request_body_data = None
        request_body_data = {
            'selected_repository_ids': selected_repository_ids,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/codespaces/secrets/{secret_name}/repositories"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_org_secret_repository(self, org: str, secret_name: str, repository_id: str) -> Any:
        """
        Assigns a GitHub Codespaces secret to a specified repository within an organization.

        Args:
            org (string): org
            secret_name (string): secret_name
            repository_id (string): repository_id

        Returns:
            Any: No Content when repository was added to the selected list

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        if repository_id is None:
            raise ValueError("Missing required parameter 'repository_id'.")
        request_body_data = None
        url = f"{self.base_url}/orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_org_secret_repo(self, org: str, secret_name: str, repository_id: str) -> Any:
        """
        Removes a repository from a GitHub organization's Codespaces secret access list when repository visibility is set to selected repositories.

        Args:
            org (string): org
            secret_name (string): secret_name
            repository_id (string): repository_id

        Returns:
            Any: Response when repository was removed from the selected list

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        if repository_id is None:
            raise ValueError("Missing required parameter 'repository_id'.")
        url = f"{self.base_url}/orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_billing(self, org: str) -> dict[str, Any]:
        """
        Retrieves the billing information for a GitHub Copilot subscription for a specified organization.

        Args:
            org (string): org

        Returns:
            dict[str, Any]: OK

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            copilot
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/copilot/billing"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def copilot_list_copilot_seats(self, org: str, page: Optional[int] = None, per_page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves Copilot seat information and billing settings for an organization, including seat breakdown and feature policies.

        Args:
            org (string): org
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            copilot
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/copilot/billing/seats"
        query_params = {k: v for k, v in [('page', page), ('per_page', per_page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def select_teams_for_billing(self, org: str, selected_teams: List[str]) -> dict[str, Any]:
        """
        Adds specified teams to an organization's GitHub Copilot subscription, provisioning seats for all members of those teams.

        Args:
            org (string): org
            selected_teams (array): List of team names within the organization to which to grant access to GitHub Copilot. Example: ['engteam1', 'engteam2', 'engteam3'].

        Returns:
            dict[str, Any]: OK

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            copilot
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'selected_teams': selected_teams,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/copilot/billing/selected_teams"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def unselect_teams(self, org: str, selected_teams: List[str]) -> dict[str, Any]:
        """
        Removes teams from the GitHub Copilot subscription for an organization, setting their seats to "pending cancellation" and ending their access at the end of the current billing cycle unless retained through another team.

        Args:
            org (string): org
            selected_teams (array): The names of teams from which to revoke access to GitHub Copilot. Example: ['engteam1', 'engteam2', 'engteam3'].

        Returns:
            dict[str, Any]: OK

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            copilot
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = {
            'selected_teams': selected_teams,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/copilot/billing/selected_teams"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def select_copilot_billing_users(self, org: str, selected_usernames: List[str]) -> dict[str, Any]:
        """
        Adds users to a GitHub Copilot subscription for an organization and returns the count of newly created and refreshed seats.

        Args:
            org (string): org
            selected_usernames (array): The usernames of the organization members to be granted access to GitHub Copilot. Example: ['cooluser1', 'hacker2', 'octocat'].

        Returns:
            dict[str, Any]: OK

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            copilot
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'selected_usernames': selected_usernames,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/copilot/billing/selected_users"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_selected_users(self, org: str, selected_usernames: List[str]) -> dict[str, Any]:
        """
        Removes specified users from an organization's Copilot subscription, scheduling cancellation of their access at the next billing cycle unless retained via team membership.

        Args:
            org (string): org
            selected_usernames (array): The usernames of the organization members for which to revoke access to GitHub Copilot. Example: ['cooluser1', 'hacker2', 'octocat'].

        Returns:
            dict[str, Any]: OK

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            copilot
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = {
            'selected_usernames': selected_usernames,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/copilot/billing/selected_users"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_metrics(self, org: str, since: Optional[str] = None, until: Optional[str] = None, page: Optional[int] = None, per_page: Optional[int] = None) -> list[Any]:
        """
        Retrieves aggregated Copilot usage metrics for an organization, including active and engaged user data, with optional date range filtering.

        Args:
            org (string): org
            since (string): Show usage metrics since this date. This is a timestamp in [ISO 8601]( format (`YYYY-MM-DDTHH:MM:SSZ`). Maximum value is 28 days ago.
            until (string): Show usage metrics until this date. This is a timestamp in [ISO 8601]( format (`YYYY-MM-DDTHH:MM:SSZ`) and should not preceed the `since` date if it is passed.
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of days of metrics to display per page (max 28). For more information, see "[Using pagination in the REST API](

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            copilot
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/copilot/metrics"
        query_params = {k: v for k, v in [('since', since), ('until', until), ('page', page), ('per_page', per_page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def dependabot_list_alerts_for_org(self, org: str, state: Optional[str] = None, severity: Optional[str] = None, ecosystem: Optional[str] = None, package: Optional[str] = None, epss_percentage: Optional[str] = None, has: Optional[Any] = None, scope: Optional[str] = None, sort: Optional[str] = None, direction: Optional[str] = None, before: Optional[str] = None, after: Optional[str] = None, first: Optional[int] = None, last: Optional[int] = None, per_page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of Dependabot alerts (filterable by state, severity, ecosystem, package, EPSS score, scope, and other parameters) for repositories within a specified GitHub organization.

        Args:
            org (string): org
            state (string): A comma-separated list of states. If specified, only alerts with these states will be returned.

        Can be: `auto_dismissed`, `dismissed`, `fixed`, `open`
            severity (string): A comma-separated list of severities. If specified, only alerts with these severities will be returned.

        Can be: `low`, `medium`, `high`, `critical`
            ecosystem (string): A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.

        Can be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`
            package (string): A comma-separated list of package names. If specified, only alerts for these packages will be returned.
            epss_percentage (string): CVE Exploit Prediction Scoring System (EPSS) percentage. Can be specified as:
        - An exact number (`n`)
        - Comparators such as `>n`, `<n`, `>=n`, `<=n`
        - A range like `n..n`, where `n` is a number from 0.0 to 1.0

        Filters the list of alerts based on EPSS percentages. If specified, only alerts with the provided EPSS percentages will be returned.
            has (string): Filters the list of alerts based on whether the alert has the given value. If specified, only alerts meeting this criterion will be returned.
        Multiple `has` filters can be passed to filter for alerts that have all of the values. Currently, only `patch` is supported.
            scope (string): The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.
            sort (string): The property by which to sort the results.
        `created` means when the alert was created.
        `updated` means when the alert's state last changed.
        `epss_percentage` sorts alerts by the Exploit Prediction Scoring System (EPSS) percentage.
            direction (string): The direction to sort the results by.
            before (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            after (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            first (integer): **Deprecated**. The number of results per page (max 100), starting from the first matching result.
        This parameter must not be used in combination with `last`.
        Instead, use `per_page` in combination with `after` to fetch the first page of results.
            last (integer): **Deprecated**. The number of results per page (max 100), starting from the last matching result.
        This parameter must not be used in combination with `first`.
        Instead, use `per_page` in combination with `before` to fetch the last page of results.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            dependabot
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/dependabot/alerts"
        query_params = {k: v for k, v in [('state', state), ('severity', severity), ('ecosystem', ecosystem), ('package', package), ('epss_percentage', epss_percentage), ('has', has), ('scope', scope), ('sort', sort), ('direction', direction), ('before', before), ('after', after), ('first', first), ('last', last), ('per_page', per_page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def dependabot_list_org_secrets(self, org: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of Dependabot secrets for an organization using the GitHub API.

        Args:
            org (string): org
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            dependabot
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/dependabot/secrets"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def dependabot_get_org_public_key(self, org: str) -> dict[str, Any]:
        """
        Retrieves the public key required to encrypt secrets for Dependabot in a GitHub organization before creating or updating secrets.

        Args:
            org (string): org

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            dependabot
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/dependabot/secrets/public-key"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def dependabot_get_org_secret(self, org: str, secret_name: str) -> dict[str, Any]:
        """
        Retrieves a specific Dependabot secret for an organization from the GitHub API.

        Args:
            org (string): org
            secret_name (string): secret_name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            dependabot
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        url = f"{self.base_url}/orgs/{org}/dependabot/secrets/{secret_name}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_dependabot_secret(self, org: str, secret_name: str, visibility: str, encrypted_value: Optional[str] = None, key_id: Optional[str] = None, selected_repository_ids: Optional[List[str]] = None) -> dict[str, Any]:
        """
        Creates or updates an organization-level Dependabot secret, encrypting and storing sensitive data for dependency updates.

        Args:
            org (string): org
            secret_name (string): secret_name
            visibility (string): Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret. Example: 'selected'.
            encrypted_value (string): Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/dependabot/secrets#get-an-organization-public-key) endpoint. Example: 'c2VjcmV0'.
            key_id (string): ID of the key you used to encrypt the secret. Example: '012345678912345678'.
            selected_repository_ids (array): An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/dependabot/secrets#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/dependabot/secrets#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/dependabot/secrets#remove-selected-repository-from-an-organization-secret) endpoints. Example: ['1296269', '1296280'].

        Returns:
            dict[str, Any]: Response when creating a secret

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            dependabot
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        request_body_data = None
        request_body_data = {
            'encrypted_value': encrypted_value,
            'key_id': key_id,
            'visibility': visibility,
            'selected_repository_ids': selected_repository_ids,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/dependabot/secrets/{secret_name}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def dependabot_delete_org_secret(self, org: str, secret_name: str) -> Any:
        """
        Deletes a specified Dependabot secret from a GitHub organization, returning a 204 status upon success.

        Args:
            org (string): org
            secret_name (string): secret_name

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            dependabot
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        url = f"{self.base_url}/orgs/{org}/dependabot/secrets/{secret_name}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_secret_repos(self, org: str, secret_name: str, page: Optional[int] = None, per_page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves the list of selected repositories for an organization's Dependabot secret, including pagination details.

        Args:
            org (string): org
            secret_name (string): secret_name
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            dependabot
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        url = f"{self.base_url}/orgs/{org}/dependabot/secrets/{secret_name}/repositories"
        query_params = {k: v for k, v in [('page', page), ('per_page', per_page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def put_dependabot_secret_repos(self, org: str, secret_name: str, selected_repository_ids: List[int]) -> Any:
        """
        Updates a list of repositories that have access to a specified Dependabot secret using the GitHub API.

        Args:
            org (string): org
            secret_name (string): secret_name
            selected_repository_ids (array): An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Set selected repositories for an organization secret](https://docs.github.com/rest/dependabot/secrets#set-selected-repositories-for-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/dependabot/secrets#remove-selected-repository-from-an-organization-secret) endpoints. Example: [64780797].

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            dependabot
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        request_body_data = None
        request_body_data = {
            'selected_repository_ids': selected_repository_ids,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/dependabot/secrets/{secret_name}/repositories"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def put_dependabot_secret_repo_access(self, org: str, secret_name: str, repository_id: str) -> Any:
        """
        Adds a repository to an organization Dependabot secret's selected repositories list, returning a 204 response on success.

        Args:
            org (string): org
            secret_name (string): secret_name
            repository_id (string): repository_id

        Returns:
            Any: No Content when repository was added to the selected list

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            dependabot
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        if repository_id is None:
            raise ValueError("Missing required parameter 'repository_id'.")
        request_body_data = None
        url = f"{self.base_url}/orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_dependabot_secret_repo(self, org: str, secret_name: str, repository_id: str) -> Any:
        """
        Removes a specified repository from the list of repositories that have access to a Dependabot secret within an organization using the GitHub API and returns a status message.

        Args:
            org (string): org
            secret_name (string): secret_name
            repository_id (string): repository_id

        Returns:
            Any: Response when repository was removed from the selected list

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            dependabot
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        if repository_id is None:
            raise ValueError("Missing required parameter 'repository_id'.")
        url = f"{self.base_url}/orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_docker_conflicts(self, org: str) -> list[Any]:
        """
        Lists packages in a GitHub organization that encountered conflicts during a Docker migration, requiring authentication with the `read:packages` scope for private resources.

        Args:
            org (string): org

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/docker/conflicts"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_events(self, org: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of public activity events for a specified GitHub organization.

        Args:
            org (string): org
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/events"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_list_failed_invitations(self, org: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Lists failed organization invitations for a specified organization using the GitHub API, returning details such as the time and reason for the failure.

        Args:
            org (string): org
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/failed_invitations"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_list_webhooks(self, org: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of organization webhooks configured to receive event payloads.

        Args:
            org (string): org
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/hooks"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_create_webhook(self, org: str, name: str, config: dict[str, Any], events: Optional[List[str]] = None, active: Optional[bool] = None) -> dict[str, Any]:
        """
        Creates an organization webhook in GitHub to receive HTTP POST payloads for specified events.

        Args:
            org (string): org
            name (string): Must be passed as "web". Example: 'web'.
            config (object): Key/value pairs to provide settings for this webhook. Example: {'url': 'http://example.com/webhook', 'content_type': 'json'}.
            events (array): Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for. Set to `["*"]` to receive all possible events. Example: ['push', 'pull_request'].
            active (boolean): Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications. Example: True.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'config': config,
            'events': events,
            'active': active,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/hooks"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_get_webhook(self, org: str, hook_id: str) -> dict[str, Any]:
        """
        Retrieves details about a specific organization webhook using the GitHub API by its ID.

        Args:
            org (string): org
            hook_id (string): hook_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if hook_id is None:
            raise ValueError("Missing required parameter 'hook_id'.")
        url = f"{self.base_url}/orgs/{org}/hooks/{hook_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_update_webhook(self, org: str, hook_id: str, config: Optional[dict[str, Any]] = None, events: Optional[List[str]] = None, active: Optional[bool] = None, name: Optional[str] = None) -> dict[str, Any]:
        """
        Updates a GitHub organization webhook specified by its ID, allowing modifications to its configuration and event subscriptions.

        Args:
            org (string): org
            hook_id (string): hook_id
            config (object): Key/value pairs to provide settings for this webhook.
            events (array): Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for. Example: ['pull_request'].
            active (boolean): Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications. Example: True.
            name (string): name Example: '"web"'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if hook_id is None:
            raise ValueError("Missing required parameter 'hook_id'.")
        request_body_data = None
        request_body_data = {
            'config': config,
            'events': events,
            'active': active,
            'name': name,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/hooks/{hook_id}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_delete_webhook(self, org: str, hook_id: str) -> Any:
        """
        Deletes an organization webhook using the GitHub API and returns a 204 status code upon successful deletion.

        Args:
            org (string): org
            hook_id (string): hook_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if hook_id is None:
            raise ValueError("Missing required parameter 'hook_id'.")
        url = f"{self.base_url}/orgs/{org}/hooks/{hook_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_hook_config(self, org: str, hook_id: str) -> dict[str, Any]:
        """
        Retrieves the configuration details for a specified organization webhook using the GitHub API.

        Args:
            org (string): org
            hook_id (string): hook_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if hook_id is None:
            raise ValueError("Missing required parameter 'hook_id'.")
        url = f"{self.base_url}/orgs/{org}/hooks/{hook_id}/config"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def patch_org_hook_config(self, org: str, hook_id: str, url: Optional[str] = None, content_type: Optional[str] = None, secret: Optional[str] = None, insecure_ssl: Optional[Any] = None) -> dict[str, Any]:
        """
        Updates the configuration settings for an organization webhook in GitHub and returns the updated configuration upon success.

        Args:
            org (string): org
            hook_id (string): hook_id
            url (string): The URL to which the payloads will be delivered. Example: 'https://example.com/webhook'.
            content_type (string): The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`. Example: '"json"'.
            secret (string): If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers). Example: '"********"'.
            insecure_ssl (string): insecure_ssl Example: '0'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if hook_id is None:
            raise ValueError("Missing required parameter 'hook_id'.")
        request_body_data = None
        request_body_data = {
            'url': url,
            'content_type': content_type,
            'secret': secret,
            'insecure_ssl': insecure_ssl,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/hooks/{hook_id}/config"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_list_webhook_deliveries(self, org: str, hook_id: str, per_page: Optional[int] = None, cursor: Optional[str] = None) -> list[Any]:
        """
        Retrieves a paginated list of webhook deliveries for a specified organization webhook, including details about each delivery's payload and status.

        Args:
            org (string): org
            hook_id (string): hook_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            cursor (string): Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if hook_id is None:
            raise ValueError("Missing required parameter 'hook_id'.")
        url = f"{self.base_url}/orgs/{org}/hooks/{hook_id}/deliveries"
        query_params = {k: v for k, v in [('per_page', per_page), ('cursor', cursor)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_get_webhook_delivery(self, org: str, hook_id: str, delivery_id: str) -> dict[str, Any]:
        """
        Retrieves details about a specific webhook delivery for an organization using the GitHub API.

        Args:
            org (string): org
            hook_id (string): hook_id
            delivery_id (string): delivery_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if hook_id is None:
            raise ValueError("Missing required parameter 'hook_id'.")
        if delivery_id is None:
            raise ValueError("Missing required parameter 'delivery_id'.")
        url = f"{self.base_url}/orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def retry_delivery_attempt(self, org: str, hook_id: str, delivery_id: str) -> dict[str, Any]:
        """
        Retries a failed webhook delivery attempt for an organization-level hook using the GitHub API.

        Args:
            org (string): org
            hook_id (string): hook_id
            delivery_id (string): delivery_id

        Returns:
            dict[str, Any]: Accepted

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if hook_id is None:
            raise ValueError("Missing required parameter 'hook_id'.")
        if delivery_id is None:
            raise ValueError("Missing required parameter 'delivery_id'.")
        request_body_data = None
        url = f"{self.base_url}/orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_ping_webhook(self, org: str, hook_id: str) -> Any:
        """
        Triggers a test ping to the specified organization webhook and returns an empty response on success.

        Args:
            org (string): org
            hook_id (string): hook_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if hook_id is None:
            raise ValueError("Missing required parameter 'hook_id'.")
        request_body_data = None
        url = f"{self.base_url}/orgs/{org}/hooks/{hook_id}/pings"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_route_stats_by_actor(self, org: str, actor_type: str, actor_id: str, min_timestamp: str, max_timestamp: Optional[str] = None, page: Optional[int] = None, per_page: Optional[int] = None, direction: Optional[str] = None, sort: Optional[List[str]] = None, api_route_substring: Optional[str] = None) -> list[Any]:
        """
        Retrieves API request statistics including total and rate-limited counts for a specific actor (user/app) broken down by routes within a specified timeframe[1].

        Args:
            org (string): org
            actor_type (string): actor_type
            actor_id (string): actor_id
            min_timestamp (string): The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            max_timestamp (string): The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            direction (string): The direction to sort the results by.
            sort (array): The property to sort the results by.
            api_route_substring (string): Providing a substring will filter results where the API route contains the substring. This is a case-insensitive search.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if actor_type is None:
            raise ValueError("Missing required parameter 'actor_type'.")
        if actor_id is None:
            raise ValueError("Missing required parameter 'actor_id'.")
        url = f"{self.base_url}/orgs/{org}/insights/api/route-stats/{actor_type}/{actor_id}"
        query_params = {k: v for k, v in [('min_timestamp', min_timestamp), ('max_timestamp', max_timestamp), ('page', page), ('per_page', per_page), ('direction', direction), ('sort', sort), ('api_route_substring', api_route_substring)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def api_insights_get_subject_stats(self, org: str, min_timestamp: str, max_timestamp: Optional[str] = None, page: Optional[int] = None, per_page: Optional[int] = None, direction: Optional[str] = None, sort: Optional[List[str]] = None, subject_name_substring: Optional[str] = None) -> list[Any]:
        """
        Retrieves API request statistics for all subjects (users or GitHub Apps) within an organization within a specified time frame using the GitHub API.

        Args:
            org (string): org
            min_timestamp (string): The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            max_timestamp (string): The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            direction (string): The direction to sort the results by.
            sort (array): The property to sort the results by.
            subject_name_substring (string): Providing a substring will filter results where the subject name contains the substring. This is a case-insensitive search.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/insights/api/subject-stats"
        query_params = {k: v for k, v in [('min_timestamp', min_timestamp), ('max_timestamp', max_timestamp), ('page', page), ('per_page', per_page), ('direction', direction), ('sort', sort), ('subject_name_substring', subject_name_substring)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def api_insights_get_summary_stats(self, org: str, min_timestamp: str, max_timestamp: Optional[str] = None) -> dict[str, Any]:
        """
        Retrieves overall statistics of API requests made within an organization by all users and apps within a specified time frame.

        Args:
            org (string): org
            min_timestamp (string): The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            max_timestamp (string): The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/insights/api/summary-stats"
        query_params = {k: v for k, v in [('min_timestamp', min_timestamp), ('max_timestamp', max_timestamp)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_user_summary_stats(self, org: str, user_id: str, min_timestamp: str, max_timestamp: Optional[str] = None) -> dict[str, Any]:
        """
        Retrieves API request statistics for a specific user within an organization during a specified time period.

        Args:
            org (string): org
            user_id (string): user_id
            min_timestamp (string): The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            max_timestamp (string): The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if user_id is None:
            raise ValueError("Missing required parameter 'user_id'.")
        url = f"{self.base_url}/orgs/{org}/insights/api/summary-stats/users/{user_id}"
        query_params = {k: v for k, v in [('min_timestamp', min_timestamp), ('max_timestamp', max_timestamp)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_summary_stats(self, org: str, actor_type: str, actor_id: str, min_timestamp: str, max_timestamp: Optional[str] = None) -> dict[str, Any]:
        """
        Retrieves summary statistics of API requests within an organization for a specified actor type and ID, allowing insights into API usage over a defined time period.

        Args:
            org (string): org
            actor_type (string): actor_type
            actor_id (string): actor_id
            min_timestamp (string): The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            max_timestamp (string): The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if actor_type is None:
            raise ValueError("Missing required parameter 'actor_type'.")
        if actor_id is None:
            raise ValueError("Missing required parameter 'actor_id'.")
        url = f"{self.base_url}/orgs/{org}/insights/api/summary-stats/{actor_type}/{actor_id}"
        query_params = {k: v for k, v in [('min_timestamp', min_timestamp), ('max_timestamp', max_timestamp)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def api_insights_get_time_stats(self, org: str, min_timestamp: str, timestamp_increment: str, max_timestamp: Optional[str] = None) -> list[Any]:
        """
        Retrieves the number of API requests and rate-limited requests made within an organization over a specified time period.

        Args:
            org (string): org
            min_timestamp (string): The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            timestamp_increment (string): The increment of time used to breakdown the query results (5m, 10m, 1h, etc.)
            max_timestamp (string): The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/insights/api/time-stats"
        query_params = {k: v for k, v in [('min_timestamp', min_timestamp), ('max_timestamp', max_timestamp), ('timestamp_increment', timestamp_increment)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_user_time_stats(self, org: str, user_id: str, min_timestamp: str, timestamp_increment: str, max_timestamp: Optional[str] = None) -> list[Any]:
        """
        Retrieves the number of API requests and rate-limited requests made by a specific user within an organization over a specified time period using the GitHub API.

        Args:
            org (string): org
            user_id (string): user_id
            min_timestamp (string): The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            timestamp_increment (string): The increment of time used to breakdown the query results (5m, 10m, 1h, etc.)
            max_timestamp (string): The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if user_id is None:
            raise ValueError("Missing required parameter 'user_id'.")
        url = f"{self.base_url}/orgs/{org}/insights/api/time-stats/users/{user_id}"
        query_params = {k: v for k, v in [('min_timestamp', min_timestamp), ('max_timestamp', max_timestamp), ('timestamp_increment', timestamp_increment)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_insights_time_stats_by_actor(self, org: str, actor_type: str, actor_id: str, min_timestamp: str, timestamp_increment: str, max_timestamp: Optional[str] = None) -> list[Any]:
        """
        Retrieves API request and rate-limited request counts for a specific actor (user or GitHub App) within an organization over a specified time period.

        Args:
            org (string): org
            actor_type (string): actor_type
            actor_id (string): actor_id
            min_timestamp (string): The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            timestamp_increment (string): The increment of time used to breakdown the query results (5m, 10m, 1h, etc.)
            max_timestamp (string): The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if actor_type is None:
            raise ValueError("Missing required parameter 'actor_type'.")
        if actor_id is None:
            raise ValueError("Missing required parameter 'actor_id'.")
        url = f"{self.base_url}/orgs/{org}/insights/api/time-stats/{actor_type}/{actor_id}"
        query_params = {k: v for k, v in [('min_timestamp', min_timestamp), ('max_timestamp', max_timestamp), ('timestamp_increment', timestamp_increment)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def api_insights_get_user_stats(self, org: str, user_id: str, min_timestamp: str, max_timestamp: Optional[str] = None, page: Optional[int] = None, per_page: Optional[int] = None, direction: Optional[str] = None, sort: Optional[List[str]] = None, actor_name_substring: Optional[str] = None) -> list[Any]:
        """
        Retrieves API request statistics for a specific user within an organization during a specified time period, including pagination and filtering options.

        Args:
            org (string): org
            user_id (string): user_id
            min_timestamp (string): The minimum timestamp to query for stats. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            max_timestamp (string): The maximum timestamp to query for stats. Defaults to the time 30 days ago. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            direction (string): The direction to sort the results by.
            sort (array): The property to sort the results by.
            actor_name_substring (string): Providing a substring will filter results where the actor name contains the substring. This is a case-insensitive search.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if user_id is None:
            raise ValueError("Missing required parameter 'user_id'.")
        url = f"{self.base_url}/orgs/{org}/insights/api/user-stats/{user_id}"
        query_params = {k: v for k, v in [('min_timestamp', min_timestamp), ('max_timestamp', max_timestamp), ('page', page), ('per_page', per_page), ('direction', direction), ('sort', sort), ('actor_name_substring', actor_name_substring)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def apps_get_org_installation(self, org: str) -> dict[str, Any]:
        """
        Retrieves installation details for a GitHub App associated with the specified organization.

        Args:
            org (string): org

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/installation"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_list_app_installations(self, org: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of GitHub App installations for a specified organization using the path "/orgs/{org}/installations" with the "GET" method.

        Args:
            org (string): org
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/installations"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_interaction_limits(self, org: str) -> Any:
        """
        Retrieves the interaction limits for an organization's public repositories using the GitHub API, showing which types of users are allowed to interact and when the restrictions expire.

        Args:
            org (string): org

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            interactions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/interaction-limits"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_interaction_limits(self, org: str, limit: str, expiry: Optional[str] = None) -> dict[str, Any]:
        """
        Temporarily restricts which type of user can comment, open issues, or create pull requests in an organization's public repositories, with restrictions that automatically expire.

        Args:
            org (string): org
            limit (string): The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect. Example: 'collaborators_only'.
            expiry (string): The duration of the interaction restriction. Default: `one_day`. Example: 'one_month'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            interactions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'limit': limit,
            'expiry': expiry,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/interaction-limits"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_org_interaction_limits(self, org: str) -> Any:
        """
        Removes all interaction restrictions for public repositories in a specified organization using the GitHub API.

        Args:
            org (string): org

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            interactions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/interaction-limits"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_list_pending_invitations(self, org: str, per_page: Optional[int] = None, page: Optional[int] = None, role: Optional[str] = None, invitation_source: Optional[str] = None) -> list[Any]:
        """
        Retrieves a list of pending invitations for an organization using the GitHub API, allowing for filtering by role and invitation source.

        Args:
            org (string): org
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            role (string): Filter invitations by their member role.
            invitation_source (string): Filter invitations by their invitation source.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/invitations"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page), ('role', role), ('invitation_source', invitation_source)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_create_invitation(self, org: str, invitee_id: Optional[int] = None, email: Optional[str] = None, role: Optional[str] = None, team_ids: Optional[List[int]] = None) -> dict[str, Any]:
        """
        Invites a user to join a specified GitHub organization using their GitHub user ID or email address via the POST method at the "/orgs/{org}/invitations" endpoint.

        Args:
            org (string): org
            invitee_id (integer): **Required unless you provide `email`**. GitHub user ID for the person you are inviting.
            email (string): **Required unless you provide `invitee_id`**. Email address of the person you are inviting, which can be an existing GitHub user. Example: 'octocat@github.com'.
            role (string): The role for the new member. 
         * `admin` - Organization owners with full administrative rights to the organization and complete access to all repositories and teams.  
         * `direct_member` - Non-owner organization members with ability to see other members and join teams by invitation.  
         * `billing_manager` - Non-owner organization members with ability to manage the billing settings of your organization. 
         * `reinstate` - The previous role assigned to the invitee before they were removed from your organization. Can be one of the roles listed above. Only works if the invitee was previously part of your organization. Example: 'direct_member'.
            team_ids (array): Specify IDs for the teams you want to invite new members to. Example: [12, 26].

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'invitee_id': invitee_id,
            'email': email,
            'role': role,
            'team_ids': team_ids,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/invitations"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_cancel_invitation(self, org: str, invitation_id: str) -> Any:
        """
        Cancels an organization invitation using the GitHub API by sending a DELETE request to the specified invitation ID within an organization.

        Args:
            org (string): org
            invitation_id (string): invitation_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if invitation_id is None:
            raise ValueError("Missing required parameter 'invitation_id'.")
        url = f"{self.base_url}/orgs/{org}/invitations/{invitation_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_list_invitation_teams(self, org: str, invitation_id: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves the list of teams associated with a specific organization invitation using GitHub's API.

        Args:
            org (string): org
            invitation_id (string): invitation_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if invitation_id is None:
            raise ValueError("Missing required parameter 'invitation_id'.")
        url = f"{self.base_url}/orgs/{org}/invitations/{invitation_id}/teams"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_list_issue_types(self, org: str) -> list[Any]:
        """
        Retrieves a list of all issue types configured for a GitHub organization.

        Args:
            org (string): org

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/issue-types"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_create_issue_type(self, org: str, name: str, is_enabled: bool, description: Optional[str] = None, color: Optional[str] = None) -> dict[str, Any]:
        """
        Creates a new issue type for a specified GitHub organization.

        Args:
            org (string): org
            name (string): Name of the issue type. Example: 'Epic'.
            is_enabled (boolean): Whether or not the issue type is enabled at the organization level. Example: True.
            description (string): Description of the issue type. Example: 'An issue type for a multi-week tracking of work'.
            color (string): Color for the issue type. Example: 'green'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'is_enabled': is_enabled,
            'description': description,
            'color': color,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/issue-types"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_update_issue_type(self, org: str, issue_type_id: str, name: str, is_enabled: bool, description: Optional[str] = None, color: Optional[str] = None) -> dict[str, Any]:
        """
        Updates an issue type for an organization using the GitHub API, including its name, description, and status.

        Args:
            org (string): org
            issue_type_id (string): issue_type_id
            name (string): Name of the issue type. Example: 'Epic'.
            is_enabled (boolean): Whether or not the issue type is enabled at the organization level. Example: True.
            description (string): Description of the issue type. Example: 'An issue type for a multi-week tracking of work'.
            color (string): Color for the issue type. Example: 'green'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if issue_type_id is None:
            raise ValueError("Missing required parameter 'issue_type_id'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'is_enabled': is_enabled,
            'description': description,
            'color': color,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/issue-types/{issue_type_id}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_delete_issue_type(self, org: str, issue_type_id: str) -> Any:
        """
        Deletes an issue type for a specified organization using the GitHub API.

        Args:
            org (string): org
            issue_type_id (string): issue_type_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if issue_type_id is None:
            raise ValueError("Missing required parameter 'issue_type_id'.")
        url = f"{self.base_url}/orgs/{org}/issue-types/{issue_type_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_list_for_org(self, org: str, filter: Optional[str] = None, state: Optional[str] = None, labels: Optional[str] = None, type: Optional[str] = None, sort: Optional[str] = None, direction: Optional[str] = None, since: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of issues for a specified GitHub organization using the "GET" method at the "/orgs/{org}/issues" path, allowing filtering by state, labels, type, and sorting options.

        Args:
            org (string): org
            filter (string): Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation.
            state (string): Indicates the state of the issues to return.
            labels (string): A list of comma separated label names. Example: `bug,ui,@high`
            type (string): Can be the name of an issue type.
            sort (string): What to sort results by.
            direction (string): The direction to sort the results by.
            since (string): Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/issues"
        query_params = {k: v for k, v in [('filter', filter), ('state', state), ('labels', labels), ('type', type), ('sort', sort), ('direction', direction), ('since', since), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_list_members(self, org: str, filter: Optional[str] = None, role: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of organization members optionally filtered by role and membership status.

        Args:
            org (string): org
            filter (string): Filter members returned in the list. `2fa_disabled` means that only members without [two-factor authentication]( enabled will be returned. `2fa_insecure` means that only members with [insecure 2FA methods]( will be returned. These options are only available for organization owners.
            role (string): Filter members returned by their role.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/members"
        query_params = {k: v for k, v in [('filter', filter), ('role', role), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_check_membership_for_user(self, org: str, username: str) -> Any:
        """
        Retrieves information about a specific GitHub organization member using the provided organization and username.

        Args:
            org (string): org
            username (string): username

        Returns:
            Any: Response if requester is an organization member and user is a member

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/orgs/{org}/members/{username}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_remove_member(self, org: str, username: str) -> Any:
        """
        Removes a user from an organization using the GitHub API.

        Args:
            org (string): org
            username (string): username

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/orgs/{org}/members/{username}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_member_codespaces(self, org: str, username: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of codespaces for a specified organization member using the "GET" method.

        Args:
            org (string): org
            username (string): username
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/orgs/{org}/members/{username}/codespaces"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_org_member_codespace(self, org: str, username: str, codespace_name: str) -> dict[str, Any]:
        """
        Deletes a GitHub Codespace for a specified member in an organization, identified by the organization name, member username, and codespace name.

        Args:
            org (string): org
            username (string): username
            codespace_name (string): codespace_name

        Returns:
            dict[str, Any]: Accepted

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        if codespace_name is None:
            raise ValueError("Missing required parameter 'codespace_name'.")
        url = f"{self.base_url}/orgs/{org}/members/{username}/codespaces/{codespace_name}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def stop_codespace(self, org: str, username: str, codespace_name: str) -> dict[str, Any]:
        """
        Stops a specific codespace for an organization member using the GitHub API and returns a status message.

        Args:
            org (string): org
            username (string): username
            codespace_name (string): codespace_name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        if codespace_name is None:
            raise ValueError("Missing required parameter 'codespace_name'.")
        request_body_data = None
        url = f"{self.base_url}/orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_member_copilot(self, org: str, username: str) -> dict[str, Any]:
        """
        Retrieves Copilot settings and seat information for a specified user within an organization using the GitHub API.

        Args:
            org (string): org
            username (string): username

        Returns:
            dict[str, Any]: The user's GitHub Copilot seat details, including usage.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            copilot
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/orgs/{org}/members/{username}/copilot"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_get_membership_for_user(self, org: str, username: str) -> dict[str, Any]:
        """
        Retrieves the membership details for a specified user within a GitHub organization using the GitHub API.

        Args:
            org (string): org
            username (string): username

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/orgs/{org}/memberships/{username}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_set_membership_for_user(self, org: str, username: str, role: Optional[str] = None) -> dict[str, Any]:
        """
        Sets or updates a user's organization membership (including role) with invitation handling and role-based permissions.

        Args:
            org (string): org
            username (string): username
            role (string): The role to give the user in the organization. Can be one of:  
         * `admin` - The user will become an owner of the organization.  
         * `member` - The user will become a non-owner member of the organization. Example: 'member'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        request_body_data = None
        request_body_data = {
            'role': role,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/memberships/{username}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_org_membership_by_username(self, org: str, username: str) -> Any:
        """
        Removes a user's membership from an organization using the GitHub API by canceling their invitation or deleting their active membership, requiring an authenticated organization admin.

        Args:
            org (string): org
            username (string): username

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/orgs/{org}/memberships/{username}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def migrations_list_for_org(self, org: str, per_page: Optional[int] = None, page: Optional[int] = None, exclude: Optional[List[str]] = None) -> list[Any]:
        """
        Retrieves a paginated list of organization migration archives, including repositories and user data, from GitHub.com to GitHub Enterprise Server.

        Args:
            org (string): org
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            exclude (array): Exclude attributes from the API response to improve performance

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            migrations
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/migrations"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page), ('exclude', exclude)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def migrations_start_for_org(self, org: str, repositories: List[str], lock_repositories: Optional[bool] = None, exclude_metadata: Optional[bool] = None, exclude_git_data: Optional[bool] = None, exclude_attachments: Optional[bool] = None, exclude_releases: Optional[bool] = None, exclude_owner_projects: Optional[bool] = None, org_metadata_only: Optional[bool] = None, exclude: Optional[List[str]] = None) -> dict[str, Any]:
        """
        Initiates an organization migration to export repositories from GitHub.com for transfer to GitHub Enterprise Server.

        Args:
            org (string): org
            repositories (array): A list of arrays indicating which repositories should be migrated. Example: ['github/Hello-World'].
            lock_repositories (boolean): Indicates whether repositories should be locked (to prevent manipulation) while migrating data. Example: 'True'.
            exclude_metadata (boolean): Indicates whether metadata should be excluded and only git source should be included for the migration.
            exclude_git_data (boolean): Indicates whether the repository git data should be excluded from the migration.
            exclude_attachments (boolean): Indicates whether attachments should be excluded from the migration (to reduce migration archive file size). Example: 'True'.
            exclude_releases (boolean): Indicates whether releases should be excluded from the migration (to reduce migration archive file size). Example: 'True'.
            exclude_owner_projects (boolean): Indicates whether projects owned by the organization or users should be excluded. from the migration. Example: 'True'.
            org_metadata_only (boolean): Indicates whether this should only include organization metadata (repositories array should be empty and will ignore other flags). Example: 'True'.
            exclude (array): Exclude related items from being returned in the response in order to improve performance of the request.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            migrations
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'repositories': repositories,
            'lock_repositories': lock_repositories,
            'exclude_metadata': exclude_metadata,
            'exclude_git_data': exclude_git_data,
            'exclude_attachments': exclude_attachments,
            'exclude_releases': exclude_releases,
            'exclude_owner_projects': exclude_owner_projects,
            'org_metadata_only': org_metadata_only,
            'exclude': exclude,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/migrations"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def migrations_get_status_for_org(self, org: str, migration_id: str, exclude: Optional[List[str]] = None) -> dict[str, Any]:
        """
        Retrieves the details of a specific organization migration by its ID, including optional exclusion parameters.

        Args:
            org (string): org
            migration_id (string): migration_id
            exclude (array): Exclude attributes from the API response to improve performance

        Returns:
            dict[str, Any]: *   `pending`, which means the migration hasn't started yet.
        *   `exporting`, which means the migration is in progress.
        *   `exported`, which means the migration finished successfully.
        *   `failed`, which means the migration failed.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            migrations
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if migration_id is None:
            raise ValueError("Missing required parameter 'migration_id'.")
        url = f"{self.base_url}/orgs/{org}/migrations/{migration_id}"
        query_params = {k: v for k, v in [('exclude', exclude)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_migration_archive(self, org: str, migration_id: str) -> Any:
        """
        Downloads a migration archive for a specified organization migration using the GitHub API, redirecting to the archive location if found.

        Args:
            org (string): org
            migration_id (string): migration_id

        Returns:
            Any: API response data.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            migrations
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if migration_id is None:
            raise ValueError("Missing required parameter 'migration_id'.")
        url = f"{self.base_url}/orgs/{org}/migrations/{migration_id}/archive"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_migration_archive_by_org(self, org: str, migration_id: str) -> Any:
        """
        Deletes a GitHub organization migration archive, which is automatically removed after seven days if not deleted manually.

        Args:
            org (string): org
            migration_id (string): migration_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            migrations
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if migration_id is None:
            raise ValueError("Missing required parameter 'migration_id'.")
        url = f"{self.base_url}/orgs/{org}/migrations/{migration_id}/archive"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def migrations_unlock_repo_for_org(self, org: str, migration_id: str, repo_name: str) -> Any:
        """
        Unlocks a repository locked during a GitHub organization migration using the GitHub API.

        Args:
            org (string): org
            migration_id (string): migration_id
            repo_name (string): repo_name

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            migrations
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if migration_id is None:
            raise ValueError("Missing required parameter 'migration_id'.")
        if repo_name is None:
            raise ValueError("Missing required parameter 'repo_name'.")
        url = f"{self.base_url}/orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def migrations_list_repos_for_org(self, org: str, migration_id: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves the list of repositories associated with a specific GitHub organization migration using the GitHub API.

        Args:
            org (string): org
            migration_id (string): migration_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            migrations
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if migration_id is None:
            raise ValueError("Missing required parameter 'migration_id'.")
        url = f"{self.base_url}/orgs/{org}/migrations/{migration_id}/repositories"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_list_org_roles(self, org: str) -> dict[str, Any]:
        """
        Retrieves all organization roles available in a specified GitHub organization.

        Args:
            org (string): org

        Returns:
            dict[str, Any]: Response - list of organization roles

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/organization-roles"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_revoke_all_org_roles_team(self, org: str, team_slug: str) -> Any:
        """
        Removes all organization roles assigned to a specific team in a GitHub organization.

        Args:
            org (string): org
            team_slug (string): team_slug

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        url = f"{self.base_url}/orgs/{org}/organization-roles/teams/{team_slug}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_assign_team_to_org_role(self, org: str, team_slug: str, role_id: str) -> Any:
        """
        Assigns an organization role to a team using the GitHub API, updating the team's permissions within the specified organization.

        Args:
            org (string): org
            team_slug (string): team_slug
            role_id (string): role_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        if role_id is None:
            raise ValueError("Missing required parameter 'role_id'.")
        request_body_data = None
        url = f"{self.base_url}/orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_revoke_org_role_team(self, org: str, team_slug: str, role_id: str) -> Any:
        """
        Removes a specific organization role from a team using the GitHub API and returns a successful status upon completion.

        Args:
            org (string): org
            team_slug (string): team_slug
            role_id (string): role_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        if role_id is None:
            raise ValueError("Missing required parameter 'role_id'.")
        url = f"{self.base_url}/orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_revoke_all_org_roles_user(self, org: str, username: str) -> Any:
        """
        Removes all assigned organization roles from a user via the GitHub API.

        Args:
            org (string): org
            username (string): username

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/orgs/{org}/organization-roles/users/{username}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_assign_user_to_org_role(self, org: str, username: str, role_id: str) -> Any:
        """
        Assigns a specified organization role to a user in a GitHub organization using the PUT method.

        Args:
            org (string): org
            username (string): username
            role_id (string): role_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        if role_id is None:
            raise ValueError("Missing required parameter 'role_id'.")
        request_body_data = None
        url = f"{self.base_url}/orgs/{org}/organization-roles/users/{username}/{role_id}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_revoke_org_role_user(self, org: str, username: str, role_id: str) -> Any:
        """
        Removes a specific organization role from a user using the GitHub API.

        Args:
            org (string): org
            username (string): username
            role_id (string): role_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        if role_id is None:
            raise ValueError("Missing required parameter 'role_id'.")
        url = f"{self.base_url}/orgs/{org}/organization-roles/users/{username}/{role_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_get_org_role(self, org: str, role_id: str) -> dict[str, Any]:
        """
        Retrieves a specific organization role's details for a GitHub organization using the provided role ID.

        Args:
            org (string): org
            role_id (string): role_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if role_id is None:
            raise ValueError("Missing required parameter 'role_id'.")
        url = f"{self.base_url}/orgs/{org}/organization-roles/{role_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_list_org_role_teams(self, org: str, role_id: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Lists the teams that are assigned to a specific organization role using the GitHub API, returning a list of teams with the provided role.

        Args:
            org (string): org
            role_id (string): role_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response - List of assigned teams

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if role_id is None:
            raise ValueError("Missing required parameter 'role_id'.")
        url = f"{self.base_url}/orgs/{org}/organization-roles/{role_id}/teams"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_list_org_role_users(self, org: str, role_id: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of users assigned to a specific organization role within a GitHub organization using the "GET" method.

        Args:
            org (string): org
            role_id (string): role_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response - List of assigned users

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if role_id is None:
            raise ValueError("Missing required parameter 'role_id'.")
        url = f"{self.base_url}/orgs/{org}/organization-roles/{role_id}/users"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_outside_collaborators(self, org: str, filter: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of outside collaborators for a specified GitHub organization using the "GET" method at the "/orgs/{org}/outside_collaborators" path.

        Args:
            org (string): org
            filter (string): Filter the list of outside collaborators. `2fa_disabled` means that only outside collaborators without [two-factor authentication]( enabled will be returned. `2fa_insecure` means that only outside collaborators with [insecure 2FA methods]( will be returned.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/outside_collaborators"
        query_params = {k: v for k, v in [('filter', filter), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_outside_collaborator(self, org: str, username: str, async_: Optional[bool] = None) -> dict[str, Any]:
        """
        Converts an organization member to an outside collaborator asynchronously and returns a status message.

        Args:
            org (string): org
            username (string): username
            async_ (boolean): When set to `true`, the request will be performed asynchronously. Returns a 202 status code when the job is successfully queued. Example: True.

        Returns:
            dict[str, Any]: User is getting converted asynchronously

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        request_body_data = None
        request_body_data = {
            'async': async_,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/outside_collaborators/{username}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_outside_collaborator(self, org: str, username: str) -> Any:
        """
        Removes a specified outside collaborator from all repositories in a GitHub organization.

        Args:
            org (string): org
            username (string): username

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/orgs/{org}/outside_collaborators/{username}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_org_packages(self, org: str, package_type: str, visibility: Optional[str] = None, page: Optional[int] = None, per_page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of packages for a specified organization, filtered by package type and visibility.

        Args:
            org (string): org
            package_type (string): The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
            visibility (string): The selected visibility of the packages.  This parameter is optional and only filters an existing result set.

        The `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`.
        For the list of GitHub Packages registries that support granular permissions, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/packages"
        query_params = {k: v for k, v in [('package_type', package_type), ('visibility', visibility), ('page', page), ('per_page', per_page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_package_details(self, org: str, package_type: str, package_name: str) -> dict[str, Any]:
        """
        Retrieves package details for a specified organization and package type using the GitHub API.

        Args:
            org (string): org
            package_type (string): package_type
            package_name (string): package_name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if package_type is None:
            raise ValueError("Missing required parameter 'package_type'.")
        if package_name is None:
            raise ValueError("Missing required parameter 'package_name'.")
        url = f"{self.base_url}/orgs/{org}/packages/{package_type}/{package_name}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_package(self, org: str, package_type: str, package_name: str) -> Any:
        """
        Deletes a specific package from an organization's GitHub Packages registry.

        Args:
            org (string): org
            package_type (string): package_type
            package_name (string): package_name

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if package_type is None:
            raise ValueError("Missing required parameter 'package_type'.")
        if package_name is None:
            raise ValueError("Missing required parameter 'package_name'.")
        url = f"{self.base_url}/orgs/{org}/packages/{package_type}/{package_name}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def restore_package(self, org: str, package_type: str, package_name: str, token: Optional[str] = None) -> Any:
        """
        Restores a deleted package for an organization using the GitHub API.

        Args:
            org (string): org
            package_type (string): package_type
            package_name (string): package_name
            token (string): package token

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if package_type is None:
            raise ValueError("Missing required parameter 'package_type'.")
        if package_name is None:
            raise ValueError("Missing required parameter 'package_name'.")
        request_body_data = None
        url = f"{self.base_url}/orgs/{org}/packages/{package_type}/{package_name}/restore"
        query_params = {k: v for k, v in [('token', token)] if v is not None}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_package_versions(self, org: str, package_type: str, package_name: str, page: Optional[int] = None, per_page: Optional[int] = None, state: Optional[str] = None) -> list[Any]:
        """
        Retrieves a list of versions for a specified package within an organization's package registry, including pagination and optional state filtering.

        Args:
            org (string): org
            package_type (string): package_type
            package_name (string): package_name
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            state (string): The state of the package, either active or deleted.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if package_type is None:
            raise ValueError("Missing required parameter 'package_type'.")
        if package_name is None:
            raise ValueError("Missing required parameter 'package_name'.")
        url = f"{self.base_url}/orgs/{org}/packages/{package_type}/{package_name}/versions"
        query_params = {k: v for k, v in [('page', page), ('per_page', per_page), ('state', state)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_package_version(self, org: str, package_type: str, package_name: str, package_version_id: str) -> dict[str, Any]:
        """
        Retrieves a specific version of a package from an organization's registry using the GitHub API.

        Args:
            org (string): org
            package_type (string): package_type
            package_name (string): package_name
            package_version_id (string): package_version_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if package_type is None:
            raise ValueError("Missing required parameter 'package_type'.")
        if package_name is None:
            raise ValueError("Missing required parameter 'package_name'.")
        if package_version_id is None:
            raise ValueError("Missing required parameter 'package_version_id'.")
        url = f"{self.base_url}/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_package_version(self, org: str, package_type: str, package_name: str, package_version_id: str) -> Any:
        """
        Deletes a specific version of a GitHub package using the provided organization, package type, package name, and package version ID.

        Args:
            org (string): org
            package_type (string): package_type
            package_name (string): package_name
            package_version_id (string): package_version_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if package_type is None:
            raise ValueError("Missing required parameter 'package_type'.")
        if package_name is None:
            raise ValueError("Missing required parameter 'package_name'.")
        if package_version_id is None:
            raise ValueError("Missing required parameter 'package_version_id'.")
        url = f"{self.base_url}/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def restore_package_versionfrombin(self, org: str, package_type: str, package_name: str, package_version_id: str) -> Any:
        """
        Restores a package version from the recycle bin back into the active feed for a specified package type and name within an organization.

        Args:
            org (string): org
            package_type (string): package_type
            package_name (string): package_name
            package_version_id (string): package_version_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if package_type is None:
            raise ValueError("Missing required parameter 'package_type'.")
        if package_name is None:
            raise ValueError("Missing required parameter 'package_name'.")
        if package_version_id is None:
            raise ValueError("Missing required parameter 'package_version_id'.")
        request_body_data = None
        url = f"{self.base_url}/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_list_pat_grant_requests(self, org: str, per_page: Optional[int] = None, page: Optional[int] = None, sort: Optional[str] = None, direction: Optional[str] = None, owner: Optional[List[str]] = None, repository: Optional[str] = None, permission: Optional[str] = None, last_used_before: Optional[str] = None, last_used_after: Optional[str] = None, token_id: Optional[List[str]] = None) -> list[Any]:
        """
        Lists organization members' requests to access organization resources using fine-grained personal access tokens and returns paginated results.

        Args:
            org (string): org
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            sort (string): The property by which to sort the results.
            direction (string): The direction to sort the results by.
            owner (array): A list of owner usernames to use to filter the results. Example: 'owner[]=octocat1,owner[]=octocat2'.
            repository (string): The name of the repository to use to filter the results. Example: 'Hello-World'.
            permission (string): The permission to use to filter the results. Example: 'issues_read'.
            last_used_before (string): Only show fine-grained personal access tokens used before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            last_used_after (string): Only show fine-grained personal access tokens used after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            token_id (array): The ID of the token Example: 'token_id[]=1,token_id[]=2'.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/personal-access-token-requests"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page), ('sort', sort), ('direction', direction), ('owner', owner), ('repository', repository), ('permission', permission), ('last_used_before', last_used_before), ('last_used_after', last_used_after), ('token_id', token_id)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_org_pat_request(self, org: str, action: str, pat_request_ids: Optional[List[int]] = None, reason: Optional[str] = None) -> dict[str, Any]:
        """
        Submits a request from an organization member to access organization resources using a fine-grained personal access token, allowing GitHub Apps to manage access to specific resources.

        Args:
            org (string): org
            action (string): Action to apply to the requests. Example: 'deny'.
            pat_request_ids (array): Unique identifiers of the requests for access via fine-grained personal access token. Must be formed of between 1 and 100 `pat_request_id` values. Example: [42, 73].
            reason (string): Reason for approving or denying the requests. Max 1024 characters. Example: 'Access is too broad.'.

        Returns:
            dict[str, Any]: Accepted

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'pat_request_ids': pat_request_ids,
            'action': action,
            'reason': reason,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/personal-access-token-requests"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_review_pat_grant_request(self, org: str, pat_request_id: str, action: str, reason: Optional[str] = None) -> Any:
        """
        Approves or processes an organization member's request to access organization resources with a fine-grained personal access token via the GitHub API.

        Args:
            org (string): org
            pat_request_id (string): pat_request_id
            action (string): Action to apply to the request. Example: 'deny'.
            reason (string): Reason for approving or denying the request. Max 1024 characters. Example: 'This request is denied because the access is too broad.'.

        Returns:
            Any: A header with no content is returned.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if pat_request_id is None:
            raise ValueError("Missing required parameter 'pat_request_id'.")
        request_body_data = None
        request_body_data = {
            'action': action,
            'reason': reason,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/personal-access-token-requests/{pat_request_id}"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_pat_request_repositories(self, org: str, pat_request_id: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of repositories associated with a specific personal access token request in a GitHub organization using the specified ID.

        Args:
            org (string): org
            pat_request_id (string): pat_request_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if pat_request_id is None:
            raise ValueError("Missing required parameter 'pat_request_id'.")
        url = f"{self.base_url}/orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_list_pat_grants(self, org: str, per_page: Optional[int] = None, page: Optional[int] = None, sort: Optional[str] = None, direction: Optional[str] = None, owner: Optional[List[str]] = None, repository: Optional[str] = None, permission: Optional[str] = None, last_used_before: Optional[str] = None, last_used_after: Optional[str] = None, token_id: Optional[List[str]] = None) -> list[Any]:
        """
        Lists requests from organization members to access organization resources using fine-grained personal access tokens, allowing filtering by various parameters such as repository, permission, and token usage time.

        Args:
            org (string): org
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            sort (string): The property by which to sort the results.
            direction (string): The direction to sort the results by.
            owner (array): A list of owner usernames to use to filter the results. Example: 'owner[]=octocat1,owner[]=octocat2'.
            repository (string): The name of the repository to use to filter the results. Example: 'Hello-World'.
            permission (string): The permission to use to filter the results. Example: 'issues_read'.
            last_used_before (string): Only show fine-grained personal access tokens used before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            last_used_after (string): Only show fine-grained personal access tokens used after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            token_id (array): The ID of the token Example: 'token_id[]=1,token_id[]=2'.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/personal-access-tokens"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page), ('sort', sort), ('direction', direction), ('owner', owner), ('repository', repository), ('permission', permission), ('last_used_before', last_used_before), ('last_used_after', last_used_after), ('token_id', token_id)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_update_pat_accesses(self, org: str, action: str, pat_ids: List[int]) -> dict[str, Any]:
        """
        Creates a new personal access token for an organization member to access organization resources using the GitHub API.

        Args:
            org (string): org
            action (string): Action to apply to the fine-grained personal access token. Example: 'revoke'.
            pat_ids (array): The IDs of the fine-grained personal access tokens. Example: [1296269, 1296280].

        Returns:
            dict[str, Any]: Accepted

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'action': action,
            'pat_ids': pat_ids,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/personal-access-tokens"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_update_pat_access(self, org: str, pat_id: str, action: str) -> Any:
        """
        Approves or processes a fine-grained personal access token request for accessing organization resources via the GitHub API.

        Args:
            org (string): org
            pat_id (string): pat_id
            action (string): Action to apply to the fine-grained personal access token. Example: 'revoke'.

        Returns:
            Any: A header with no content is returned.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if pat_id is None:
            raise ValueError("Missing required parameter 'pat_id'.")
        request_body_data = None
        request_body_data = {
            'action': action,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/personal-access-tokens/{pat_id}"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_pat_repositories(self, org: str, pat_id: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of repositories accessible by a specified personal access token within a GitHub organization.

        Args:
            org (string): org
            pat_id (string): pat_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if pat_id is None:
            raise ValueError("Missing required parameter 'pat_id'.")
        url = f"{self.base_url}/orgs/{org}/personal-access-tokens/{pat_id}/repositories"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_private_registries(self, org: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves paginated list of organization's private container registries with optional pagination parameters.

        Args:
            org (string): org
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            private-registries
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/private-registries"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_private_registry(self, org: str, registry_type: str, encrypted_value: str, key_id: str, visibility: str, username: Optional[str] = None, selected_repository_ids: Optional[List[int]] = None) -> dict[str, Any]:
        """
        Creates a private registry configuration for a specified organization using the POST method, allowing for the setup of an encrypted private registry with controlled access.

        Args:
            org (string): org
            registry_type (string): The registry type. Example: 'maven_repository'.
            encrypted_value (string): The value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get private registries public key for an organization](https://docs.github.com/rest/private-registries/organization-configurations#get-private-registries-public-key-for-an-organization) endpoint. Example: 'c2VjcmV0'.
            key_id (string): The ID of the key you used to encrypt the secret. Example: '012345678912345678'.
            visibility (string): Which type of organization repositories have access to the private registry. `selected` means only the repositories specified by `selected_repository_ids` can access the private registry. Example: 'private'.
            username (string): The username to use when authenticating with the private registry. This field should be omitted if the private registry does not require a username for authentication. Example: 'monalisa'.
            selected_repository_ids (array): An array of repository IDs that can access the organization private registry. You can only provide a list of repository IDs when `visibility` is set to `selected`. You can manage the list of selected repositories using the [Update a private registry for an organization](https://docs.github.com/rest/private-registries/organization-configurations#update-a-private-registry-for-an-organization) endpoint. This field should be omitted if `visibility` is set to `all` or `private`.

        Returns:
            dict[str, Any]: The organization private registry configuration

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            private-registries
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'registry_type': registry_type,
            'username': username,
            'encrypted_value': encrypted_value,
            'key_id': key_id,
            'visibility': visibility,
            'selected_repository_ids': selected_repository_ids,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/private-registries"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_private_registry_public_key(self, org: str) -> dict[str, Any]:
        """
        Retrieves the public key required to encrypt secrets for an organization's private GitHub registries.

        Args:
            org (string): org

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            private-registries
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/private-registries/public-key"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_private_registry_secret(self, org: str, secret_name: str) -> dict[str, Any]:
        """
        Retrieves details of a specific private registry configuration for an organization by its secret name.

        Args:
            org (string): org
            secret_name (string): secret_name

        Returns:
            dict[str, Any]: The specified private registry configuration for the organization

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            private-registries
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        url = f"{self.base_url}/orgs/{org}/private-registries/{secret_name}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_secret_registry(self, org: str, secret_name: str, registry_type: Optional[str] = None, username: Optional[str] = None, encrypted_value: Optional[str] = None, key_id: Optional[str] = None, visibility: Optional[str] = None, selected_repository_ids: Optional[List[int]] = None) -> Any:
        """
        Updates a private registry secret for an organization using the PATCH method and returns a status code indicating the outcome.

        Args:
            org (string): org
            secret_name (string): secret_name
            registry_type (string): The registry type.
            username (string): The username to use when authenticating with the private registry. This field should be omitted if the private registry does not require a username for authentication. Example: 'monalisa'.
            encrypted_value (string): The value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get private registries public key for an organization](https://docs.github.com/rest/private-registries/organization-configurations#get-private-registries-public-key-for-an-organization) endpoint. Example: 'c2VjcmV0'.
            key_id (string): The ID of the key you used to encrypt the secret. Example: '012345678912345678'.
            visibility (string): Which type of organization repositories have access to the private registry. `selected` means only the repositories specified by `selected_repository_ids` can access the private registry.
            selected_repository_ids (array): An array of repository IDs that can access the organization private registry. You can only provide a list of repository IDs when `visibility` is set to `selected`. This field should be omitted if `visibility` is set to `all` or `private`.

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            private-registries
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        request_body_data = None
        request_body_data = {
            'registry_type': registry_type,
            'username': username,
            'encrypted_value': encrypted_value,
            'key_id': key_id,
            'visibility': visibility,
            'selected_repository_ids': selected_repository_ids,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/private-registries/{secret_name}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_secret_registry(self, org: str, secret_name: str) -> Any:
        """
        Deletes a specified private registry secret associated with an organization.

        Args:
            org (string): org
            secret_name (string): secret_name

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            private-registries
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        url = f"{self.base_url}/orgs/{org}/private-registries/{secret_name}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def projects_list_for_org(self, org: str, state: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of projects for a specified GitHub organization using the "GET" method, allowing filtering by project state and pagination.

        Args:
            org (string): org
            state (string): Indicates the state of the projects to return.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            projects
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/projects"
        query_params = {k: v for k, v in [('state', state), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def projects_create_for_org(self, org: str, name: str, body: Optional[str] = None) -> dict[str, Any]:
        """
        Creates a new project for an organization using the GitHub API and returns a status message upon success.

        Args:
            org (string): org
            name (string): The name of the project. Example: 'Organization Roadmap'.
            body (string): The description of the project. Example: 'High-level roadmap for the upcoming year.'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            projects
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'body': body,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/projects"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_get_all_custom_properties(self, org: str) -> list[Any]:
        """
        Retrieves a custom property schema defined for a specified GitHub organization using the "GET" method, returning details like property name, value type, and allowed values.

        Args:
            org (string): org

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/properties/schema"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_org_schema(self, org: str, properties: List[dict[str, Any]]) -> list[Any]:
        """
        Updates custom properties for an organization in bulk by creating or replacing existing property definitions.

        Args:
            org (string): org
            properties (array): The array of custom properties to create or update. Example: [{'property_name': 'environment', 'value_type': 'single_select', 'required': True, 'default_value': 'production', 'description': 'Prod or dev environment', 'allowed_values': ['production', 'development'], 'values_editable_by': 'org_actors'}, {'property_name': 'service', 'value_type': 'string'}, {'property_name': 'team', 'value_type': 'string', 'description': 'Team owning the repository'}].

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'properties': properties,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/properties/schema"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_get_custom_property(self, org: str, custom_property_name: str) -> dict[str, Any]:
        """
        Retrieves the schema of a specified custom property for an organization.

        Args:
            org (string): org
            custom_property_name (string): custom_property_name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if custom_property_name is None:
            raise ValueError("Missing required parameter 'custom_property_name'.")
        url = f"{self.base_url}/orgs/{org}/properties/schema/{custom_property_name}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_custom_property_schema(self, org: str, custom_property_name: str, value_type: str, required: Optional[bool] = None, default_value: Optional[Any] = None, description: Optional[str] = None, allowed_values: Optional[List[str]] = None, values_editable_by: Optional[str] = None) -> dict[str, Any]:
        """
        Updates the schema for a custom property of an organization using the specified property name and returns the updated schema.

        Args:
            org (string): org
            custom_property_name (string): custom_property_name
            value_type (string): The type of the value for the property Example: 'single_select'.
            required (boolean): Whether the property is required. Example: True.
            default_value (string): Default value of the property Example: 'production'.
            description (string): Short description of the property Example: 'Prod or dev environment'.
            allowed_values (array): An ordered list of the allowed values of the property.
        The property can have up to 200 allowed values. Example: ['production', 'development'].
            values_editable_by (string): Who can edit the values of the property Example: 'org_actors'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if custom_property_name is None:
            raise ValueError("Missing required parameter 'custom_property_name'.")
        request_body_data = None
        request_body_data = {
            'value_type': value_type,
            'required': required,
            'default_value': default_value,
            'description': description,
            'allowed_values': allowed_values,
            'values_editable_by': values_editable_by,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/properties/schema/{custom_property_name}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_remove_custom_property(self, org: str, custom_property_name: str) -> Any:
        """
        Deletes a custom property from an organization's schema using the DELETE method.

        Args:
            org (string): org
            custom_property_name (string): custom_property_name

        Returns:
            Any: A header with no content is returned.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if custom_property_name is None:
            raise ValueError("Missing required parameter 'custom_property_name'.")
        url = f"{self.base_url}/orgs/{org}/properties/schema/{custom_property_name}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_property_values(self, org: str, per_page: Optional[int] = None, page: Optional[int] = None, repository_query: Optional[str] = None) -> list[Any]:
        """
        Retrieves custom property values for all organization repositories, optionally filtered by a search query.

        Args:
            org (string): org
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            repository_query (string): Finds repositories in the organization with a query containing one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query]( See "[Searching for repositories]( for a detailed list of qualifiers.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/properties/values"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page), ('repository_query', repository_query)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def patch_org_properties_values(self, org: str, repository_names: List[str], properties: List[dict[str, Any]]) -> Any:
        """
        Updates custom property values for an organization using the GitHub API, allowing creation or modification of existing properties for the specified organization.

        Args:
            org (string): org
            repository_names (array): The names of repositories that the custom property values will be applied to. Example: ['Hello-World', 'octo-repo'].
            properties (array): List of custom property names and associated values to apply to the repositories. Example: [{'property_name': 'environment', 'value': 'production'}, {'property_name': 'service', 'value': 'web'}, {'property_name': 'team', 'value': 'octocat'}].

        Returns:
            Any: No Content when custom property values are successfully created or updated

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'repository_names': repository_names,
            'properties': properties,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/properties/values"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_list_public_members(self, org: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of public members of a specified GitHub organization using the "GET" method.

        Args:
            org (string): org
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/public_members"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_public_member_by_username(self, org: str, username: str) -> Any:
        """
        Checks if a specified user's membership in an organization is publicly visible and returns a status code indicating visibility or absence.

        Args:
            org (string): org
            username (string): username

        Returns:
            Any: Response if user is a public member

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/orgs/{org}/public_members/{username}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_org_member(self, org: str, username: str) -> Any:
        """
        Publicizes a GitHub user's membership in a specified organization using the GitHub API and returns a status message.

        Args:
            org (string): org
            username (string): username

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        request_body_data = None
        url = f"{self.base_url}/orgs/{org}/public_members/{username}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_org_public_member(self, org: str, username: str) -> Any:
        """
        Removes a user's public membership visibility for a specified organization using the GitHub API, returning no content on success.

        Args:
            org (string): org
            username (string): username

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/orgs/{org}/public_members/{username}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_list_for_org(self, org: str, type: Optional[str] = None, sort: Optional[str] = None, direction: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Lists all repositories for a specified GitHub organization, with optional filtering and sorting parameters.

        Args:
            org (string): org
            type (string): Specifies the types of repositories you want returned.
            sort (string): The property to sort the results by.
            direction (string): The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/repos"
        query_params = {k: v for k, v in [('type', type), ('sort', sort), ('direction', direction), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_create_in_org(self, org: str, name: str, description: Optional[str] = None, homepage: Optional[str] = None, private: Optional[bool] = None, visibility: Optional[str] = None, has_issues: Optional[bool] = None, has_projects: Optional[bool] = None, has_wiki: Optional[bool] = None, has_downloads: Optional[bool] = None, is_template: Optional[bool] = None, team_id: Optional[int] = None, auto_init: Optional[bool] = None, gitignore_template: Optional[str] = None, license_template: Optional[str] = None, allow_squash_merge: Optional[bool] = None, allow_merge_commit: Optional[bool] = None, allow_rebase_merge: Optional[bool] = None, allow_auto_merge: Optional[bool] = None, delete_branch_on_merge: Optional[bool] = None, use_squash_pr_title_as_default: Optional[bool] = None, squash_merge_commit_title: Optional[str] = None, squash_merge_commit_message: Optional[str] = None, merge_commit_title: Optional[str] = None, merge_commit_message: Optional[str] = None, custom_properties: Optional[dict[str, Any]] = None) -> dict[str, Any]:
        """
        Creates a new GitHub repository under a specified organization and returns a 201 status code upon success.

        Args:
            org (string): org
            name (string): The name of the repository. Example: 'Hello-World'.
            description (string): A short description of the repository. Example: 'This is your first repository'.
            homepage (string): A URL with more information about the repository. Example: 'https://github.com'.
            private (boolean): Whether the repository is private. Example: False.
            visibility (string): The visibility of the repository.
            has_issues (boolean): Either `true` to enable issues for this repository or `false` to disable them. Example: True.
            has_projects (boolean): Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error. Example: True.
            has_wiki (boolean): Either `true` to enable the wiki for this repository or `false` to disable it. Example: True.
            has_downloads (boolean): Whether downloads are enabled. Example: 'True'.
            is_template (boolean): Either `true` to make this repo available as a template repository or `false` to prevent it.
            team_id (integer): The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.
            auto_init (boolean): Pass `true` to create an initial commit with empty README.
            gitignore_template (string): Desired language or platform [.gitignore template](https://github.com/github/gitignore) to apply. Use the name of the template without the extension. For example, "Haskell".
            license_template (string): Choose an [open source license template](https://choosealicense.com/) that best suits your needs, and then use the [license keyword](https://docs.github.com/articles/licensing-a-repository/#searching-github-by-license-type) as the `license_template` string. For example, "mit" or "mpl-2.0".
            allow_squash_merge (boolean): Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.
            allow_merge_commit (boolean): Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.
            allow_rebase_merge (boolean): Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.
            allow_auto_merge (boolean): Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.
            delete_branch_on_merge (boolean): Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion. **The authenticated user must be an organization owner to set this property to `true`.**
            use_squash_pr_title_as_default (boolean): Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property is closing down. Please use `squash_merge_commit_title` instead.
            squash_merge_commit_title (string): Required when using `squash_merge_commit_message`.

        The default value for a squash merge commit title:

        - `PR_TITLE` - default to the pull request's title.
        - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
            squash_merge_commit_message (string): The default value for a squash merge commit message:

        - `PR_BODY` - default to the pull request's body.
        - `COMMIT_MESSAGES` - default to the branch's commit messages.
        - `BLANK` - default to a blank commit message.
            merge_commit_title (string): Required when using `merge_commit_message`.

        The default value for a merge commit title.

        - `PR_TITLE` - default to the pull request's title.
        - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
            merge_commit_message (string): The default value for a merge commit message.

        - `PR_TITLE` - default to the pull request's title.
        - `PR_BODY` - default to the pull request's body.
        - `BLANK` - default to a blank commit message.
            custom_properties (object): The custom properties for the new repository. The keys are the custom property names, and the values are the corresponding custom property values.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'description': description,
            'homepage': homepage,
            'private': private,
            'visibility': visibility,
            'has_issues': has_issues,
            'has_projects': has_projects,
            'has_wiki': has_wiki,
            'has_downloads': has_downloads,
            'is_template': is_template,
            'team_id': team_id,
            'auto_init': auto_init,
            'gitignore_template': gitignore_template,
            'license_template': license_template,
            'allow_squash_merge': allow_squash_merge,
            'allow_merge_commit': allow_merge_commit,
            'allow_rebase_merge': allow_rebase_merge,
            'allow_auto_merge': allow_auto_merge,
            'delete_branch_on_merge': delete_branch_on_merge,
            'use_squash_pr_title_as_default': use_squash_pr_title_as_default,
            'squash_merge_commit_title': squash_merge_commit_title,
            'squash_merge_commit_message': squash_merge_commit_message,
            'merge_commit_title': merge_commit_title,
            'merge_commit_message': merge_commit_message,
            'custom_properties': custom_properties,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/repos"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_org_rulesets(self, org: str, per_page: Optional[int] = None, page: Optional[int] = None, targets: Optional[str] = None) -> list[Any]:
        """
        Retrieves all repository rulesets for an organization, including configurable filters for targets and pagination.

        Args:
            org (string): org
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            targets (string): A comma-separated list of rule targets to filter by.
        If provided, only rulesets that apply to the specified targets will be returned.
        For example, `branch,tag,push`.
         Example: 'branch,tag,push'.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/rulesets"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page), ('targets', targets)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_create_org_ruleset(self, org: str, name: str, enforcement: str, target: Optional[str] = None, bypass_actors: Optional[List[dict[str, Any]]] = None, conditions: Optional[dict[str, Any]] = None, rules: Optional[List[dict[str, Any]]] = None) -> dict[str, Any]:
        """
        Creates a new ruleset for an organization using the GitHub API, allowing the management of custom rules to control interactions with repository branches and tags.

        Args:
            org (string): org
            name (string): The name of the ruleset. Example: 'super cool ruleset'.
            enforcement (string): The enforcement level of the ruleset. `evaluate` allows admins to test rules before enforcing them. Admins can view insights on the Rule Insights page (`evaluate` is only available with GitHub Enterprise). Example: 'active'.
            target (string): The target of the ruleset Example: 'branch'.
            bypass_actors (array): The actors that can bypass the rules in this ruleset Example: [{'actor_id': 234, 'actor_type': 'Team', 'bypass_mode': 'always'}].
            conditions (object): Conditions for an organization ruleset.
        The branch and tag rulesets conditions object should contain both `repository_name` and `ref_name` properties, or both `repository_id` and `ref_name` properties, or both `repository_property` and `ref_name` properties.
        The push rulesets conditions object does not require the `ref_name` property.
        For repository policy rulesets, the conditions object should only contain the `repository_name`, the `repository_id`, or the `repository_property`. Example: {'ref_name': {'include': ['refs/heads/main', 'refs/heads/master'], 'exclude': ['refs/heads/dev*']}, 'repository_name': {'include': ['important_repository', 'another_important_repository'], 'exclude': ['unimportant_repository'], 'protected': True}}.
            rules (array): An array of rules within the ruleset. Example: [{'type': 'commit_author_email_pattern', 'parameters': {'operator': 'contains', 'pattern': 'github'}}].

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'target': target,
            'enforcement': enforcement,
            'bypass_actors': bypass_actors,
            'conditions': conditions,
            'rules': rules,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/rulesets"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_org_rule_suites(self, org: str, ref: Optional[str] = None, repository_name: Optional[str] = None, time_period: Optional[str] = None, actor_name: Optional[str] = None, rule_suite_result: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a filtered list of organization repository rule evaluation suites, including parameters for result type, repository name, time period, and pagination.

        Args:
            org (string): org
            ref (string): The name of the ref. Cannot contain wildcard characters. Optionally prefix with `refs/heads/` to limit to branches or `refs/tags/` to limit to tags. Omit the prefix to search across all refs. When specified, only rule evaluations triggered for this ref will be returned.
            repository_name (string): The name of the repository to filter on.
            time_period (string): The time period to filter by.

        For example, `day` will filter for rule suites that occurred in the past 24 hours, and `week` will filter for insights that occurred in the past 7 days (168 hours).
            actor_name (string): The handle for the GitHub user account to filter on. When specified, only rule evaluations triggered by this actor will be returned.
            rule_suite_result (string): The rule results to filter on. When specified, only suites with this result will be returned.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/rulesets/rule-suites"
        query_params = {k: v for k, v in [('ref', ref), ('repository_name', repository_name), ('time_period', time_period), ('actor_name', actor_name), ('rule_suite_result', rule_suite_result), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_org_rule_suite(self, org: str, rule_suite_id: str) -> dict[str, Any]:
        """
        Retrieves a specific rule suite for an organization on GitHub using the "GET" method, returning details about the rule suite with the specified identifier.

        Args:
            org (string): org
            rule_suite_id (string): rule_suite_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if rule_suite_id is None:
            raise ValueError("Missing required parameter 'rule_suite_id'.")
        url = f"{self.base_url}/orgs/{org}/rulesets/rule-suites/{rule_suite_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_org_ruleset(self, org: str, ruleset_id: str) -> dict[str, Any]:
        """
        Retrieves a specific ruleset by its ID from a GitHub organization using the "GET" method at the "/orgs/{org}/rulesets/{ruleset_id}" path.

        Args:
            org (string): org
            ruleset_id (string): ruleset_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if ruleset_id is None:
            raise ValueError("Missing required parameter 'ruleset_id'.")
        url = f"{self.base_url}/orgs/{org}/rulesets/{ruleset_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_update_org_ruleset(self, org: str, ruleset_id: str, name: Optional[str] = None, target: Optional[str] = None, enforcement: Optional[str] = None, bypass_actors: Optional[List[dict[str, Any]]] = None, conditions: Optional[dict[str, Any]] = None, rules: Optional[List[dict[str, Any]]] = None) -> dict[str, Any]:
        """
        Updates an organization's ruleset configuration in GitHub using the specified ruleset ID.

        Args:
            org (string): org
            ruleset_id (string): ruleset_id
            name (string): The name of the ruleset. Example: 'super cool ruleset'.
            target (string): The target of the ruleset Example: 'branch'.
            enforcement (string): The enforcement level of the ruleset. `evaluate` allows admins to test rules before enforcing them. Admins can view insights on the Rule Insights page (`evaluate` is only available with GitHub Enterprise). Example: 'active'.
            bypass_actors (array): The actors that can bypass the rules in this ruleset Example: [{'actor_id': 234, 'actor_type': 'Team', 'bypass_mode': 'always'}].
            conditions (object): Conditions for an organization ruleset.
        The branch and tag rulesets conditions object should contain both `repository_name` and `ref_name` properties, or both `repository_id` and `ref_name` properties, or both `repository_property` and `ref_name` properties.
        The push rulesets conditions object does not require the `ref_name` property.
        For repository policy rulesets, the conditions object should only contain the `repository_name`, the `repository_id`, or the `repository_property`. Example: {'ref_name': {'include': ['refs/heads/main', 'refs/heads/master'], 'exclude': ['refs/heads/dev*']}, 'repository_name': {'include': ['important_repository', 'another_important_repository'], 'exclude': ['unimportant_repository'], 'protected': True}}.
            rules (array): An array of rules within the ruleset. Example: [{'type': 'commit_author_email_pattern', 'parameters': {'operator': 'contains', 'pattern': 'github'}}].

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if ruleset_id is None:
            raise ValueError("Missing required parameter 'ruleset_id'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'target': target,
            'enforcement': enforcement,
            'bypass_actors': bypass_actors,
            'conditions': conditions,
            'rules': rules,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/rulesets/{ruleset_id}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_delete_org_ruleset(self, org: str, ruleset_id: str) -> Any:
        """
        Deletes a specific ruleset from an organization using the GitHub API, returning a status code indicating the result of the operation.

        Args:
            org (string): org
            ruleset_id (string): ruleset_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if ruleset_id is None:
            raise ValueError("Missing required parameter 'ruleset_id'.")
        url = f"{self.base_url}/orgs/{org}/rulesets/{ruleset_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_get_org_ruleset_history(self, org: str, ruleset_id: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves the history of a specific ruleset for an organization using the GitHub API and returns relevant information about past changes.

        Args:
            org (string): org
            ruleset_id (string): ruleset_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if ruleset_id is None:
            raise ValueError("Missing required parameter 'ruleset_id'.")
        url = f"{self.base_url}/orgs/{org}/rulesets/{ruleset_id}/history"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_get_org_ruleset_version(self, org: str, ruleset_id: str, version_id: str) -> Any:
        """
        Retrieves a specific historical version of an organization's repository ruleset from the GitHub API based on the provided ruleset ID and version ID.

        Args:
            org (string): org
            ruleset_id (string): ruleset_id
            version_id (string): version_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if ruleset_id is None:
            raise ValueError("Missing required parameter 'ruleset_id'.")
        if version_id is None:
            raise ValueError("Missing required parameter 'version_id'.")
        url = f"{self.base_url}/orgs/{org}/rulesets/{ruleset_id}/history/{version_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_org_secret_scanning_alerts(self, org: str, state: Optional[str] = None, secret_type: Optional[str] = None, resolution: Optional[str] = None, sort: Optional[str] = None, direction: Optional[str] = None, page: Optional[int] = None, per_page: Optional[int] = None, before: Optional[str] = None, after: Optional[str] = None, validity: Optional[str] = None, is_publicly_leaked: Optional[bool] = None, is_multi_repo: Optional[bool] = None) -> list[Any]:
        """
        Retrieves a paginated list of secret scanning alerts for an organization, filtered by state, secret type, resolution, and other criteria.

        Args:
            org (string): org
            state (string): Set to `open` or `resolved` to only list secret scanning alerts in a specific state.
            secret_type (string): A comma-separated list of secret types to return. All default secret patterns are returned. To return generic patterns, pass the token name(s) in the parameter. See "[Supported secret scanning patterns](https://docs.github.com/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)" for a complete list of secret types.
            resolution (string): A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.
            sort (string): The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.
            direction (string): The direction to sort the results by.
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            before (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events before this cursor. To receive an initial cursor on your first request, include an empty "before" query string.
            after (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events after this cursor.  To receive an initial cursor on your first request, include an empty "after" query string.
            validity (string): A comma-separated list of validities that, when present, will return alerts that match the validities in this list. Valid options are `active`, `inactive`, and `unknown`.
            is_publicly_leaked (boolean): A boolean value representing whether or not to filter alerts by the publicly-leaked tag being present.
            is_multi_repo (boolean): A boolean value representing whether or not to filter alerts by the multi-repo tag being present.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            secret-scanning
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/secret-scanning/alerts"
        query_params = {k: v for k, v in [('state', state), ('secret_type', secret_type), ('resolution', resolution), ('sort', sort), ('direction', direction), ('page', page), ('per_page', per_page), ('before', before), ('after', after), ('validity', validity), ('is_publicly_leaked', is_publicly_leaked), ('is_multi_repo', is_multi_repo)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_security_advisories(self, org: str, direction: Optional[str] = None, sort: Optional[str] = None, before: Optional[str] = None, after: Optional[str] = None, per_page: Optional[int] = None, state: Optional[str] = None) -> list[Any]:
        """
        Lists repository security advisories for a specified organization, including details like advisory status and pagination parameters.

        Args:
            org (string): org
            direction (string): The direction to sort the results by.
            sort (string): The property to sort the results by.
            before (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            after (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of advisories to return per page. For more information, see "[Using pagination in the REST API](
            state (string): Filter by the state of the repository advisories. Only advisories of this state will be returned.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            security-advisories
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/security-advisories"
        query_params = {k: v for k, v in [('direction', direction), ('sort', sort), ('before', before), ('after', after), ('per_page', per_page), ('state', state)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_security_managers(self, org: str) -> list[Any]:
        """
        Retrieves a list of security managers for a specified GitHub organization using the "GET" method.

        Args:
            org (string): org

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/security-managers"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_add_security_manager_team(self, org: str, team_slug: str) -> Any:
        """
        Adds a specified team as a security manager for an organization using the GitHub API, requiring appropriate permissions and returning a successful no-content response if completed.

        Args:
            org (string): org
            team_slug (string): team_slug

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        request_body_data = None
        url = f"{self.base_url}/orgs/{org}/security-managers/teams/{team_slug}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_security_manager_team(self, org: str, team_slug: str) -> Any:
        """
        Removes the security manager role from a team in a GitHub organization.

        Args:
            org (string): org
            team_slug (string): team_slug

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        url = f"{self.base_url}/orgs/{org}/security-managers/teams/{team_slug}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_billing_actions(self, org: str) -> dict[str, Any]:
        """
        Retrieves GitHub Actions billing details for an organization including total minutes used, breakdown by operating system, and included minutes.

        Args:
            org (string): org

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            billing
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/settings/billing/actions"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_billing_packages(self, org: str) -> dict[str, Any]:
        """
        Retrieves the billing information for GitHub Packages in an organization, including free and paid storage usage in gigabytes.

        Args:
            org (string): org

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            billing
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/settings/billing/packages"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_billing_shared_storage(self, org: str) -> dict[str, Any]:
        """
        Retrieves an organization's shared storage billing details including estimated usage and remaining billing cycle days.

        Args:
            org (string): org

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            billing
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/settings/billing/shared-storage"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_network_configurations(self, org: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of hosted compute network configurations for a GitHub organization.

        Args:
            org (string): org
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            hosted-compute
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/settings/network-configurations"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_org_network_configurations(self, org: str, name: str, network_settings_ids: List[str], compute_service: Optional[str] = None) -> dict[str, Any]:
        """
        Creates a hosted compute network configuration for a specified organization using the GitHub API.

        Args:
            org (string): org
            name (string): Name of the network configuration. Must be between 1 and 100 characters and may only contain upper and lowercase letters a-z, numbers 0-9, '.', '-', and '_'. Example: 'my-network-configuration'.
            network_settings_ids (array): The identifier of the network settings to use for the network configuration. Exactly one network settings must be specified. Example: ['23456789ABDCEF1'].
            compute_service (string): The hosted compute service to use for the network configuration. Example: 'actions'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            hosted-compute
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'compute_service': compute_service,
            'network_settings_ids': network_settings_ids,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/settings/network-configurations"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_network_config_by_id(self, org: str, network_configuration_id: str) -> dict[str, Any]:
        """
        Retrieves a specific hosted compute network configuration for an organization using the provided identifier.

        Args:
            org (string): org
            network_configuration_id (string): network_configuration_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            hosted-compute
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if network_configuration_id is None:
            raise ValueError("Missing required parameter 'network_configuration_id'.")
        url = f"{self.base_url}/orgs/{org}/settings/network-configurations/{network_configuration_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_network_configuration(self, org: str, network_configuration_id: str, name: Optional[str] = None, compute_service: Optional[str] = None, network_settings_ids: Optional[List[str]] = None) -> dict[str, Any]:
        """
        Updates a hosted compute network configuration for a GitHub organization using specified network settings and compute service.

        Args:
            org (string): org
            network_configuration_id (string): network_configuration_id
            name (string): Name of the network configuration. Must be between 1 and 100 characters and may only contain upper and lowercase letters a-z, numbers 0-9, '.', '-', and '_'. Example: 'my-network-configuration'.
            compute_service (string): The hosted compute service to use for the network configuration. Example: 'actions'.
            network_settings_ids (array): The identifier of the network settings to use for the network configuration. Exactly one network settings must be specified. Example: ['23456789ABDCEF1'].

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            hosted-compute
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if network_configuration_id is None:
            raise ValueError("Missing required parameter 'network_configuration_id'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'compute_service': compute_service,
            'network_settings_ids': network_settings_ids,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/settings/network-configurations/{network_configuration_id}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_network_configuration_by_id(self, org: str, network_configuration_id: str) -> Any:
        """
        Deletes a hosted compute network configuration from a GitHub organization.

        Args:
            org (string): org
            network_configuration_id (string): network_configuration_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            hosted-compute
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if network_configuration_id is None:
            raise ValueError("Missing required parameter 'network_configuration_id'.")
        url = f"{self.base_url}/orgs/{org}/settings/network-configurations/{network_configuration_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_network_settings_by_id(self, org: str, network_settings_id: str) -> dict[str, Any]:
        """
        Retrieves a specific hosted compute network settings resource for the specified organization using the GitHub API.

        Args:
            org (string): org
            network_settings_id (string): network_settings_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            hosted-compute
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if network_settings_id is None:
            raise ValueError("Missing required parameter 'network_settings_id'.")
        url = f"{self.base_url}/orgs/{org}/settings/network-settings/{network_settings_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_team_metrics(self, org: str, team_slug: str, since: Optional[str] = None, until: Optional[str] = None, page: Optional[int] = None, per_page: Optional[int] = None) -> list[Any]:
        """
        Retrieves aggregated GitHub Copilot usage metrics for a specific team within an organization, including parameters for date ranges and pagination.

        Args:
            org (string): org
            team_slug (string): team_slug
            since (string): Show usage metrics since this date. This is a timestamp in [ISO 8601]( format (`YYYY-MM-DDTHH:MM:SSZ`). Maximum value is 28 days ago.
            until (string): Show usage metrics until this date. This is a timestamp in [ISO 8601]( format (`YYYY-MM-DDTHH:MM:SSZ`) and should not preceed the `since` date if it is passed.
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of days of metrics to display per page (max 28). For more information, see "[Using pagination in the REST API](

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            copilot
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        url = f"{self.base_url}/orgs/{org}/team/{team_slug}/copilot/metrics"
        query_params = {k: v for k, v in [('since', since), ('until', until), ('page', page), ('per_page', per_page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_list(self, org: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of teams in a GitHub organization.

        Args:
            org (string): org
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/orgs/{org}/teams"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_create(self, org: str, name: str, description: Optional[str] = None, maintainers: Optional[List[str]] = None, repo_names: Optional[List[str]] = None, privacy: Optional[str] = None, notification_setting: Optional[str] = None, permission: Optional[str] = None, parent_team_id: Optional[int] = None) -> dict[str, Any]:
        """
        Creates a new team within a specified GitHub organization using the "POST" method at the "/orgs/{org}/teams" path.

        Args:
            org (string): org
            name (string): The name of the team. Example: 'Justice League'.
            description (string): The description of the team. Example: 'A great team'.
            maintainers (array): List GitHub IDs for organization members who will become team maintainers.
            repo_names (array): The full name (e.g., "organization-name/repository-name") of repositories to add the team to.
            privacy (string): The level of privacy this team should have. The options are:  
        **For a non-nested team:**  
         * `secret` - only visible to organization owners and members of this team.  
         * `closed` - visible to all members of this organization.  
        Default: `secret`  
        **For a parent or child team:**  
         * `closed` - visible to all members of this organization.  
        Default for child team: `closed` Example: 'closed'.
            notification_setting (string): The notification setting the team has chosen. The options are:  
         * `notifications_enabled` - team members receive notifications when the team is @mentioned.  
         * `notifications_disabled` - no one receives notifications.  
        Default: `notifications_enabled` Example: 'notifications_enabled'.
            permission (string): **Closing down notice**. The permission that new repositories will be added to the team with when none is specified. Example: 'push'.
            parent_team_id (integer): The ID of a team to set as the parent team.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'description': description,
            'maintainers': maintainers,
            'repo_names': repo_names,
            'privacy': privacy,
            'notification_setting': notification_setting,
            'permission': permission,
            'parent_team_id': parent_team_id,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/teams"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_get_by_name(self, org: str, team_slug: str) -> dict[str, Any]:
        """
        Retrieves details of a specific team in a GitHub organization using the team's slug for identification.

        Args:
            org (string): org
            team_slug (string): team_slug

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_update_in_org(self, org: str, team_slug: str, name: Optional[str] = None, description: Optional[str] = None, privacy: Optional[str] = None, notification_setting: Optional[str] = None, permission: Optional[str] = None, parent_team_id: Optional[int] = None) -> dict[str, Any]:
        """
        Updates the details of a GitHub organization team, such as its name, description, or privacy settings, using the given organization and team slug.

        Args:
            org (string): org
            team_slug (string): team_slug
            name (string): The name of the team. Example: 'new team name'.
            description (string): The description of the team. Example: 'new team description'.
            privacy (string): The level of privacy this team should have. Editing teams without specifying this parameter leaves `privacy` intact. When a team is nested, the `privacy` for parent teams cannot be `secret`. The options are:  
        **For a non-nested team:**  
         * `secret` - only visible to organization owners and members of this team.  
         * `closed` - visible to all members of this organization.  
        **For a parent or child team:**  
         * `closed` - visible to all members of this organization. Example: 'closed'.
            notification_setting (string): The notification setting the team has chosen. Editing teams without specifying this parameter leaves `notification_setting` intact. The options are: 
         * `notifications_enabled` - team members receive notifications when the team is @mentioned.  
         * `notifications_disabled` - no one receives notifications. Example: 'notifications_enabled'.
            permission (string): **Closing down notice**. The permission that new repositories will be added to the team with when none is specified.
            parent_team_id (integer): The ID of a team to set as the parent team.

        Returns:
            dict[str, Any]: Response when the updated information already exists

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'description': description,
            'privacy': privacy,
            'notification_setting': notification_setting,
            'permission': permission,
            'parent_team_id': parent_team_id,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_delete_in_org(self, org: str, team_slug: str) -> Any:
        """
        Deletes a GitHub team using the GitHub API, requiring the organization name and team slug, and returns a status code indicating successful deletion.

        Args:
            org (string): org
            team_slug (string): team_slug

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_list_discussions_in_org(self, org: str, team_slug: str, direction: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None, pinned: Optional[str] = None) -> list[Any]:
        """
        Retrieves a list of discussions from a specified team's page in a GitHub organization.

        Args:
            org (string): org
            team_slug (string): team_slug
            direction (string): The direction to sort the results by.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            pinned (string): Pinned discussions only filter

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/discussions"
        query_params = {k: v for k, v in [('direction', direction), ('per_page', per_page), ('page', page), ('pinned', pinned)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_create_discussion_in_org(self, org: str, team_slug: str, title: str, body: str, private: Optional[bool] = None) -> dict[str, Any]:
        """
        Creates a new discussion post on a specified team's page within an organization using the GitHub API.

        Args:
            org (string): org
            team_slug (string): team_slug
            title (string): The discussion post's title. Example: 'Our first team post'.
            body (string): The discussion post's body text. Example: 'Hi! This is an area for us to collaborate as a team.'.
            private (boolean): Private posts are only visible to team members, organization owners, and team maintainers. Public posts are visible to all members of the organization. Set to `true` to create a private post.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        request_body_data = None
        request_body_data = {
            'title': title,
            'body': body,
            'private': private,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/discussions"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_get_discussion_in_org(self, org: str, team_slug: str, discussion_number: str) -> dict[str, Any]:
        """
        Retrieves a specific GitHub team discussion by organization, team slug, and discussion number, using the "GET" method.

        Args:
            org (string): org
            team_slug (string): team_slug
            discussion_number (string): discussion_number

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        if discussion_number is None:
            raise ValueError("Missing required parameter 'discussion_number'.")
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_update_discussion_in_org(self, org: str, team_slug: str, discussion_number: str, title: Optional[str] = None, body: Optional[str] = None) -> dict[str, Any]:
        """
        Edits a GitHub team discussion post using the specified organization, team, and discussion details, updating its title and body text through the `PATCH` method.

        Args:
            org (string): org
            team_slug (string): team_slug
            discussion_number (string): discussion_number
            title (string): The discussion post's title. Example: 'Welcome to our first team post'.
            body (string): The discussion post's body text.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        if discussion_number is None:
            raise ValueError("Missing required parameter 'discussion_number'.")
        request_body_data = None
        request_body_data = {
            'title': title,
            'body': body,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_delete_discussion_in_org(self, org: str, team_slug: str, discussion_number: str) -> Any:
        """
        Deletes a GitHub team discussion using the specified organization, team, and discussion number, returning a "204 No Content" status upon successful deletion.

        Args:
            org (string): org
            team_slug (string): team_slug
            discussion_number (string): discussion_number

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        if discussion_number is None:
            raise ValueError("Missing required parameter 'discussion_number'.")
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_discussion_comments_org(self, org: str, team_slug: str, discussion_number: str, direction: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves comments from a specific team discussion in a GitHub organization.

        Args:
            org (string): org
            team_slug (string): team_slug
            discussion_number (string): discussion_number
            direction (string): The direction to sort the results by.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        if discussion_number is None:
            raise ValueError("Missing required parameter 'discussion_number'.")
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
        query_params = {k: v for k, v in [('direction', direction), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_comment(self, org: str, team_slug: str, discussion_number: str, body: str) -> dict[str, Any]:
        """
        Creates a new comment on a team discussion post in a GitHub organization.

        Args:
            org (string): org
            team_slug (string): team_slug
            discussion_number (string): discussion_number
            body (string): The discussion comment's body text. Example: 'Do you like apples?'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        if discussion_number is None:
            raise ValueError("Missing required parameter 'discussion_number'.")
        request_body_data = None
        request_body_data = {
            'body': body,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_comment_details(self, org: str, team_slug: str, discussion_number: str, comment_number: str) -> dict[str, Any]:
        """
        Retrieves a specific comment from a team discussion in a GitHub organization using the GitHub API.

        Args:
            org (string): org
            team_slug (string): team_slug
            discussion_number (string): discussion_number
            comment_number (string): comment_number

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        if discussion_number is None:
            raise ValueError("Missing required parameter 'discussion_number'.")
        if comment_number is None:
            raise ValueError("Missing required parameter 'comment_number'.")
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_comment(self, org: str, team_slug: str, discussion_number: str, comment_number: str, body: str) -> dict[str, Any]:
        """
        Updates a specific comment on a team discussion post within a GitHub organization using the GitHub API.

        Args:
            org (string): org
            team_slug (string): team_slug
            discussion_number (string): discussion_number
            comment_number (string): comment_number
            body (string): The discussion comment's body text. Example: 'Do you like pineapples?'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        if discussion_number is None:
            raise ValueError("Missing required parameter 'discussion_number'.")
        if comment_number is None:
            raise ValueError("Missing required parameter 'comment_number'.")
        request_body_data = None
        request_body_data = {
            'body': body,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_team_discussion_comment(self, org: str, team_slug: str, discussion_number: str, comment_number: str) -> Any:
        """
        Deletes a specified comment from a team discussion in a GitHub organization using the GitHub API.

        Args:
            org (string): org
            team_slug (string): team_slug
            discussion_number (string): discussion_number
            comment_number (string): comment_number

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        if discussion_number is None:
            raise ValueError("Missing required parameter 'discussion_number'.")
        if comment_number is None:
            raise ValueError("Missing required parameter 'comment_number'.")
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_comment_reactions(self, org: str, team_slug: str, discussion_number: str, comment_number: str, content: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Lists reactions for a specific comment in a team discussion within a GitHub organization, allowing filtering by reaction content.

        Args:
            org (string): org
            team_slug (string): team_slug
            discussion_number (string): discussion_number
            comment_number (string): comment_number
            content (string): Returns a single [reaction type]( Omit this parameter to list all reactions to a team discussion comment.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            reactions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        if discussion_number is None:
            raise ValueError("Missing required parameter 'discussion_number'.")
        if comment_number is None:
            raise ValueError("Missing required parameter 'comment_number'.")
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
        query_params = {k: v for k, v in [('content', content), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def add_comment_reaction(self, org: str, team_slug: str, discussion_number: str, comment_number: str, content: str) -> dict[str, Any]:
        """
        Adds a reaction to a team discussion comment using specified emoji types and returns success status.

        Args:
            org (string): org
            team_slug (string): team_slug
            discussion_number (string): discussion_number
            comment_number (string): comment_number
            content (string): The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion comment. Example: 'heart'.

        Returns:
            dict[str, Any]: Response when the reaction type has already been added to this team discussion comment

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            reactions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        if discussion_number is None:
            raise ValueError("Missing required parameter 'discussion_number'.")
        if comment_number is None:
            raise ValueError("Missing required parameter 'comment_number'.")
        request_body_data = None
        request_body_data = {
            'content': content,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_reaction(self, org: str, team_slug: str, discussion_number: str, comment_number: str, reaction_id: str) -> Any:
        """
        Deletes a specific reaction from a team discussion comment within an organization using the GitHub API.

        Args:
            org (string): org
            team_slug (string): team_slug
            discussion_number (string): discussion_number
            comment_number (string): comment_number
            reaction_id (string): reaction_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            reactions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        if discussion_number is None:
            raise ValueError("Missing required parameter 'discussion_number'.")
        if comment_number is None:
            raise ValueError("Missing required parameter 'comment_number'.")
        if reaction_id is None:
            raise ValueError("Missing required parameter 'reaction_id'.")
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_discussion_reactions(self, org: str, team_slug: str, discussion_number: str, content: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of reactions (, , , etc.) for a team discussion via the GitHub API.

        Args:
            org (string): org
            team_slug (string): team_slug
            discussion_number (string): discussion_number
            content (string): Returns a single [reaction type]( Omit this parameter to list all reactions to a team discussion.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            reactions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        if discussion_number is None:
            raise ValueError("Missing required parameter 'discussion_number'.")
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
        query_params = {k: v for k, v in [('content', content), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_team_discussion_reaction(self, org: str, team_slug: str, discussion_number: str, content: str) -> dict[str, Any]:
        """
        Creates a new reaction to a team discussion comment on GitHub using the POST method.

        Args:
            org (string): org
            team_slug (string): team_slug
            discussion_number (string): discussion_number
            content (string): The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion. Example: 'heart'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            reactions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        if discussion_number is None:
            raise ValueError("Missing required parameter 'discussion_number'.")
        request_body_data = None
        request_body_data = {
            'content': content,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_reaction_by_id(self, org: str, team_slug: str, discussion_number: str, reaction_id: str) -> Any:
        """
        Deletes a reaction to a team discussion comment on GitHub using the API.

        Args:
            org (string): org
            team_slug (string): team_slug
            discussion_number (string): discussion_number
            reaction_id (string): reaction_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            reactions
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        if discussion_number is None:
            raise ValueError("Missing required parameter 'discussion_number'.")
        if reaction_id is None:
            raise ValueError("Missing required parameter 'reaction_id'.")
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_invitations(self, org: str, team_slug: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of pending invitations for a specific team within a GitHub organization, including invitee details and invitation status.

        Args:
            org (string): org
            team_slug (string): team_slug
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/invitations"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_list_members_in_org(self, org: str, team_slug: str, role: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of members for a specific team in an organization using the GitHub API.

        Args:
            org (string): org
            team_slug (string): team_slug
            role (string): Filters members returned by their role in the team.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/members"
        query_params = {k: v for k, v in [('role', role), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_team_membership_by_username(self, org: str, team_slug: str, username: str) -> dict[str, Any]:
        """
        Retrieves a user's membership status with a team in a GitHub organization using the "GET" method.

        Args:
            org (string): org
            team_slug (string): team_slug
            username (string): username

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/memberships/{username}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_team_membership(self, org: str, team_slug: str, username: str, role: Optional[str] = None) -> dict[str, Any]:
        """
        Adds or updates a user's team membership in a GitHub organization, sending an invitation if unaffiliated, and requires organization owner or team maintainer permissions.

        Args:
            org (string): org
            team_slug (string): team_slug
            username (string): username
            role (string): The role that this user should have in the team. Example: 'maintainer'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        request_body_data = None
        request_body_data = {
            'role': role,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/memberships/{username}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_team_membership(self, org: str, team_slug: str, username: str) -> Any:
        """
        Removes a user's membership from a team in a GitHub organization.

        Args:
            org (string): org
            team_slug (string): team_slug
            username (string): username

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/memberships/{username}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_list_projects_in_org(self, org: str, team_slug: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of projects for a specified team within an organization using the GitHub API.

        Args:
            org (string): org
            team_slug (string): team_slug
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/projects"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_team_project(self, org: str, team_slug: str, project_id: str) -> dict[str, Any]:
        """
        Retrieves a specific project associated with a team in a GitHub organization using the provided organization name, team slug, and project ID.

        Args:
            org (string): org
            team_slug (string): team_slug
            project_id (string): project_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        if project_id is None:
            raise ValueError("Missing required parameter 'project_id'.")
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/projects/{project_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_project(self, org: str, team_slug: str, project_id: str, permission: Optional[str] = None) -> Any:
        """
        Updates a GitHub project for a specified team using the "PUT" method, modifying its details at the path "/orgs/{org}/teams/{team_slug}/projects/{project_id}".

        Args:
            org (string): org
            team_slug (string): team_slug
            project_id (string): project_id
            permission (string): The permission to grant to the team for this project. Default: the team's `permission` attribute will be used to determine what permission to grant the team on this project. Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)." Example: 'write'.

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        if project_id is None:
            raise ValueError("Missing required parameter 'project_id'.")
        request_body_data = None
        request_body_data = {
            'permission': permission,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/projects/{project_id}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_remove_project_in_org(self, org: str, team_slug: str, project_id: str) -> Any:
        """
        Deletes a GitHub project associated with a specified team in an organization using the "DELETE" method, as identified by the project ID.

        Args:
            org (string): org
            team_slug (string): team_slug
            project_id (string): project_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        if project_id is None:
            raise ValueError("Missing required parameter 'project_id'.")
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/projects/{project_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_list_repos_in_org(self, org: str, team_slug: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Checks a team's repository permissions and returns the list of repositories accessible to the team within an organization.

        Args:
            org (string): org
            team_slug (string): team_slug
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/repos"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_team_repo_details(self, org: str, team_slug: str, owner: str, repo: str) -> dict[str, Any]:
        """
        Retrieves information about a specific repository owned by an organization team, using the GitHub API by providing parameters for the organization, team slug, repository owner, and repository name.

        Args:
            org (string): org
            team_slug (string): team_slug
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Alternative response with repository permissions

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def add_team_repo_to_org(self, org: str, team_slug: str, owner: str, repo: str, permission: Optional[str] = None) -> Any:
        """
        Updates a team's repository permissions for a specified repository and returns a success status (204).

        Args:
            org (string): org
            team_slug (string): team_slug
            owner (string): owner
            repo (string): repo
            permission (string): The permission to grant the team on this repository. We accept the following permissions to be set: `pull`, `triage`, `push`, `maintain`, `admin` and you can also specify a custom repository role name, if the owning organization has defined any. If no permission is specified, the team's `permission` attribute will be used to determine what permission to grant the team on this repository. Example: 'push'.

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'permission': permission,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_remove_repo_in_org(self, org: str, team_slug: str, owner: str, repo: str) -> Any:
        """
        Removes a repository from a team's permissions in a GitHub organization.

        Args:
            org (string): org
            team_slug (string): team_slug
            owner (string): owner
            repo (string): repo

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_list_child_in_org(self, org: str, team_slug: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of child teams belonging to a parent team within a GitHub organization using the specified organization name and team slug.

        Args:
            org (string): org
            team_slug (string): team_slug
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: if child teams exist

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if team_slug is None:
            raise ValueError("Missing required parameter 'team_slug'.")
        url = f"{self.base_url}/orgs/{org}/teams/{team_slug}/teams"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def enable_security_product(self, org: str, security_product: str, enablement: str, query_suite: Optional[str] = None) -> Any:
        """
        Enables a security product for an organization using the specified API and returns a status message.

        Args:
            org (string): org
            security_product (string): security_product
            enablement (string): enablement
            query_suite (string): CodeQL query suite to be used. If you specify the `query_suite` parameter, the default setup will be configured with this query suite only on all repositories that didn't have default setup already configured. It will not change the query suite on repositories that already have default setup configured.
        If you don't specify any `query_suite` in your request, the preferred query suite of the organization will be applied.

        Returns:
            Any: Action started

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        if security_product is None:
            raise ValueError("Missing required parameter 'security_product'.")
        if enablement is None:
            raise ValueError("Missing required parameter 'enablement'.")
        request_body_data = None
        request_body_data = {
            'query_suite': query_suite,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/orgs/{org}/{security_product}/{enablement}"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def projects_get_card(self, card_id: str) -> dict[str, Any]:
        """
        Retrieves information about a specific card in a project column using the project API.

        Args:
            card_id (string): card_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            projects
        """
        if card_id is None:
            raise ValueError("Missing required parameter 'card_id'.")
        url = f"{self.base_url}/projects/columns/cards/{card_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def projects_update_card(self, card_id: str, note: Optional[str] = None, archived: Optional[bool] = None) -> dict[str, Any]:
        """
        Updates a specific project card's details using the "PATCH" method at the "/projects/columns/cards/{card_id}" endpoint and returns a status message.

        Args:
            card_id (string): card_id
            note (string): The project card's note Example: 'Update all gems'.
            archived (boolean): Whether or not the card is archived Example: 'False'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            projects
        """
        if card_id is None:
            raise ValueError("Missing required parameter 'card_id'.")
        request_body_data = None
        request_body_data = {
            'note': note,
            'archived': archived,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/projects/columns/cards/{card_id}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def projects_delete_card(self, card_id: str) -> Any:
        """
        Deletes a specific card from a project's column using the provided card ID and returns relevant status codes.

        Args:
            card_id (string): card_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            projects
        """
        if card_id is None:
            raise ValueError("Missing required parameter 'card_id'.")
        url = f"{self.base_url}/projects/columns/cards/{card_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def projects_move_card(self, card_id: str, position: str, column_id: Optional[int] = None) -> dict[str, Any]:
        """
        Moves a GitHub project card to a specified location and returns an operation status.

        Args:
            card_id (string): card_id
            position (string): The position of the card in a column. Can be one of: `top`, `bottom`, or `after:<card_id>` to place after the specified card. Example: 'bottom'.
            column_id (integer): The unique identifier of the column the card should be moved to Example: '42'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            projects
        """
        if card_id is None:
            raise ValueError("Missing required parameter 'card_id'.")
        request_body_data = None
        request_body_data = {
            'position': position,
            'column_id': column_id,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/projects/columns/cards/{card_id}/moves"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def projects_get_column(self, column_id: str) -> dict[str, Any]:
        """
        Retrieves details for a specific project column identified by the column ID.

        Args:
            column_id (string): column_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            projects
        """
        if column_id is None:
            raise ValueError("Missing required parameter 'column_id'.")
        url = f"{self.base_url}/projects/columns/{column_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def projects_update_column(self, column_id: str, name: str) -> dict[str, Any]:
        """
        Updates a project column identified by `{column_id}` using partial data, returning a success status on completion.

        Args:
            column_id (string): column_id
            name (string): Name of the project column Example: 'Remaining tasks'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            projects
        """
        if column_id is None:
            raise ValueError("Missing required parameter 'column_id'.")
        request_body_data = None
        request_body_data = {
            'name': name,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/projects/columns/{column_id}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def projects_delete_column(self, column_id: str) -> Any:
        """
        Deletes a project column by its specified ID using the GitHub API and returns a success status upon completion.

        Args:
            column_id (string): column_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            projects
        """
        if column_id is None:
            raise ValueError("Missing required parameter 'column_id'.")
        url = f"{self.base_url}/projects/columns/{column_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def projects_list_cards(self, column_id: str, archived_state: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of cards from a specified project column in GitHub, supporting pagination and filtering by archived status.

        Args:
            column_id (string): column_id
            archived_state (string): Filters the project cards that are returned by the card's state.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            projects
        """
        if column_id is None:
            raise ValueError("Missing required parameter 'column_id'.")
        url = f"{self.base_url}/projects/columns/{column_id}/cards"
        query_params = {k: v for k, v in [('archived_state', archived_state), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def projects_create_card(self, column_id: str, note: Optional[str] = None, content_id: Optional[int] = None, content_type: Optional[str] = None) -> dict[str, Any]:
        """
        Creates a new card in a GitHub project column and returns the created resource.

        Args:
            column_id (string): column_id
            note (string): The project card's note Example: 'Update all gems'.
            content_id (integer): The unique identifier of the content associated with the card Example: '42'.
            content_type (string): The piece of content associated with the card Example: 'PullRequest'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            projects
        """
        if column_id is None:
            raise ValueError("Missing required parameter 'column_id'.")
        request_body_data = None
        request_body_data = {
            'note': note,
            'content_id': content_id,
            'content_type': content_type,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/projects/columns/{column_id}/cards"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def projects_move_column(self, column_id: str, position: str) -> dict[str, Any]:
        """
        Moves a project column to a specified position using the GitHub API and returns a status message.

        Args:
            column_id (string): column_id
            position (string): The position of the column in a project. Can be one of: `first`, `last`, or `after:<column_id>` to place after the specified column. Example: 'last'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            projects
        """
        if column_id is None:
            raise ValueError("Missing required parameter 'column_id'.")
        request_body_data = None
        request_body_data = {
            'position': position,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/projects/columns/{column_id}/moves"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def projects_get(self, project_id: str) -> dict[str, Any]:
        """
        Retrieves information for a specific project using the project ID provided in the path.

        Args:
            project_id (string): project_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            projects
        """
        if project_id is None:
            raise ValueError("Missing required parameter 'project_id'.")
        url = f"{self.base_url}/projects/{project_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def projects_update(self, project_id: str, name: Optional[str] = None, body: Optional[str] = None, state: Optional[str] = None, organization_permission: Optional[str] = None, private: Optional[bool] = None) -> dict[str, Any]:
        """
        Updates the specified project's properties using partial modifications and returns a success response upon completion.

        Args:
            project_id (string): project_id
            name (string): Name of the project Example: 'Week One Sprint'.
            body (string): Body of the project Example: 'This project represents the sprint of the first week in January'.
            state (string): State of the project; either 'open' or 'closed' Example: 'open'.
            organization_permission (string): The baseline permission that all organization members have on this project Example: 'write'.
            private (boolean): Whether or not this project can be seen by everyone.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            projects
        """
        if project_id is None:
            raise ValueError("Missing required parameter 'project_id'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'body': body,
            'state': state,
            'organization_permission': organization_permission,
            'private': private,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/projects/{project_id}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def projects_delete(self, project_id: str) -> Any:
        """
        Deletes the specified project by its ID and returns no content upon successful deletion.

        Args:
            project_id (string): project_id

        Returns:
            Any: Delete Success

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            projects
        """
        if project_id is None:
            raise ValueError("Missing required parameter 'project_id'.")
        url = f"{self.base_url}/projects/{project_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def projects_list_collaborators(self, project_id: str, affiliation: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of collaborators for a specific project, optionally filtered by affiliation and paginated by page size.

        Args:
            project_id (string): project_id
            affiliation (string): Filters the collaborators by their affiliation. `outside` means outside collaborators of a project that are not a member of the project's organization. `direct` means collaborators with permissions to a project, regardless of organization membership status. `all` means all collaborators the authenticated user can see.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            projects
        """
        if project_id is None:
            raise ValueError("Missing required parameter 'project_id'.")
        url = f"{self.base_url}/projects/{project_id}/collaborators"
        query_params = {k: v for k, v in [('affiliation', affiliation), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def projects_add_collaborator(self, project_id: str, username: str, permission: Optional[str] = None) -> Any:
        """
        Adds a collaborator to a specified project (classic) using their username and returns a success status upon completion.

        Args:
            project_id (string): project_id
            username (string): username
            permission (string): The permission to grant the collaborator. Example: 'write'.

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            projects
        """
        if project_id is None:
            raise ValueError("Missing required parameter 'project_id'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        request_body_data = None
        request_body_data = {
            'permission': permission,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/projects/{project_id}/collaborators/{username}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def projects_remove_collaborator(self, project_id: str, username: str) -> Any:
        """
        Removes a collaborator with the specified username from a project identified by its ID using the DELETE method.

        Args:
            project_id (string): project_id
            username (string): username

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            projects
        """
        if project_id is None:
            raise ValueError("Missing required parameter 'project_id'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/projects/{project_id}/collaborators/{username}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_collaborator_permission(self, project_id: str, username: str) -> dict[str, Any]:
        """
        Retrieves the permission level for a specific collaborator in a project.

        Args:
            project_id (string): project_id
            username (string): username

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            projects
        """
        if project_id is None:
            raise ValueError("Missing required parameter 'project_id'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/projects/{project_id}/collaborators/{username}/permission"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def projects_list_columns(self, project_id: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of columns for a specific project using the "GET" method at the path "/projects/{project_id}/columns", with optional pagination parameters.

        Args:
            project_id (string): project_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            projects
        """
        if project_id is None:
            raise ValueError("Missing required parameter 'project_id'.")
        url = f"{self.base_url}/projects/{project_id}/columns"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def projects_create_column(self, project_id: str, name: str) -> dict[str, Any]:
        """
        Creates a new column within a specified project structure.

        Args:
            project_id (string): project_id
            name (string): Name of the project column Example: 'Remaining tasks'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            projects
        """
        if project_id is None:
            raise ValueError("Missing required parameter 'project_id'.")
        request_body_data = None
        request_body_data = {
            'name': name,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/projects/{project_id}/columns"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def rate_limit_get(self) -> dict[str, Any]:
        """
        Retrieves information about rate limits, providing details on usage constraints for API access.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            rate-limit
        """
        url = f"{self.base_url}/rate_limit"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Retrieves detailed information about a specific GitHub repository, including its configuration and metadata.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_update(self, owner: str, repo: str, name: Optional[str] = None, description: Optional[str] = None, homepage: Optional[str] = None, private: Optional[bool] = None, visibility: Optional[str] = None, security_and_analysis: Optional[dict[str, Any]] = None, has_issues: Optional[bool] = None, has_projects: Optional[bool] = None, has_wiki: Optional[bool] = None, is_template: Optional[bool] = None, default_branch: Optional[str] = None, allow_squash_merge: Optional[bool] = None, allow_merge_commit: Optional[bool] = None, allow_rebase_merge: Optional[bool] = None, allow_auto_merge: Optional[bool] = None, delete_branch_on_merge: Optional[bool] = None, allow_update_branch: Optional[bool] = None, use_squash_pr_title_as_default: Optional[bool] = None, squash_merge_commit_title: Optional[str] = None, squash_merge_commit_message: Optional[str] = None, merge_commit_title: Optional[str] = None, merge_commit_message: Optional[str] = None, archived: Optional[bool] = None, allow_forking: Optional[bool] = None, web_commit_signoff_required: Optional[bool] = None) -> dict[str, Any]:
        """
        Updates an existing GitHub repository's configuration and returns the modified repository details.

        Args:
            owner (string): owner
            repo (string): repo
            name (string): The name of the repository. Example: 'Hello-World'.
            description (string): A short description of the repository. Example: 'This is your first repository'.
            homepage (string): A URL with more information about the repository. Example: 'https://github.com'.
            private (boolean): Either `true` to make the repository private or `false` to make it public. Default: `false`.  
        **Note**: You will get a `422` error if the organization restricts [changing repository visibility](https://docs.github.com/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories) to organization owners and a non-owner tries to change the value of private. Example: True.
            visibility (string): The visibility of the repository.
            security_and_analysis (object): Specify which security and analysis features to enable or disable for the repository.

        To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."

        For example, to enable GitHub Advanced Security, use this data in the body of the `PATCH` request:
        `{ "security_and_analysis": {"advanced_security": { "status": "enabled" } } }`.

        You can check which security and analysis features are currently enabled by using a `GET /repos/{owner}/{repo}` request.
            has_issues (boolean): Either `true` to enable issues for this repository or `false` to disable them. Example: True.
            has_projects (boolean): Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error. Example: True.
            has_wiki (boolean): Either `true` to enable the wiki for this repository or `false` to disable it. Example: True.
            is_template (boolean): Either `true` to make this repo available as a template repository or `false` to prevent it.
            default_branch (string): Updates the default branch for this repository.
            allow_squash_merge (boolean): Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.
            allow_merge_commit (boolean): Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.
            allow_rebase_merge (boolean): Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.
            allow_auto_merge (boolean): Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.
            delete_branch_on_merge (boolean): Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion.
            allow_update_branch (boolean): Either `true` to always allow a pull request head branch that is behind its base branch to be updated even if it is not required to be up to date before merging, or false otherwise.
            use_squash_pr_title_as_default (boolean): Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property is closing down. Please use `squash_merge_commit_title` instead.
            squash_merge_commit_title (string): Required when using `squash_merge_commit_message`.

        The default value for a squash merge commit title:

        - `PR_TITLE` - default to the pull request's title.
        - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
            squash_merge_commit_message (string): The default value for a squash merge commit message:

        - `PR_BODY` - default to the pull request's body.
        - `COMMIT_MESSAGES` - default to the branch's commit messages.
        - `BLANK` - default to a blank commit message.
            merge_commit_title (string): Required when using `merge_commit_message`.

        The default value for a merge commit title.

        - `PR_TITLE` - default to the pull request's title.
        - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
            merge_commit_message (string): The default value for a merge commit message.

        - `PR_TITLE` - default to the pull request's title.
        - `PR_BODY` - default to the pull request's body.
        - `BLANK` - default to a blank commit message.
            archived (boolean): Whether to archive this repository. `false` will unarchive a previously archived repository.
            allow_forking (boolean): Either `true` to allow private forks, or `false` to prevent private forks.
            web_commit_signoff_required (boolean): Either `true` to require contributors to sign off on web-based commits, or `false` to not require contributors to sign off on web-based commits.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'description': description,
            'homepage': homepage,
            'private': private,
            'visibility': visibility,
            'security_and_analysis': security_and_analysis,
            'has_issues': has_issues,
            'has_projects': has_projects,
            'has_wiki': has_wiki,
            'is_template': is_template,
            'default_branch': default_branch,
            'allow_squash_merge': allow_squash_merge,
            'allow_merge_commit': allow_merge_commit,
            'allow_rebase_merge': allow_rebase_merge,
            'allow_auto_merge': allow_auto_merge,
            'delete_branch_on_merge': delete_branch_on_merge,
            'allow_update_branch': allow_update_branch,
            'use_squash_pr_title_as_default': use_squash_pr_title_as_default,
            'squash_merge_commit_title': squash_merge_commit_title,
            'squash_merge_commit_message': squash_merge_commit_message,
            'merge_commit_title': merge_commit_title,
            'merge_commit_message': merge_commit_message,
            'archived': archived,
            'allow_forking': allow_forking,
            'web_commit_signoff_required': web_commit_signoff_required,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_delete(self, owner: str, repo: str) -> Any:
        """
        Deletes a specified GitHub repository using the repository owner and name, but this endpoint does not exist in the standard GitHub API, as deletion is typically done through the UI or other specific endpoints not defined at "/repos/{owner}/{repo}" with the "DELETE" method.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_artifacts(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None, name: Optional[str] = None) -> dict[str, Any]:
        """
        Retrieves a list of artifacts for a specified GitHub repository using the GitHub Actions API, allowing access to artifact metadata such as names, sizes, and creation dates.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            name (string): The name field of an artifact. When specified, only artifacts with this name will be returned.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/artifacts"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page), ('name', name)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_get_artifact(self, owner: str, repo: str, artifact_id: str) -> dict[str, Any]:
        """
        Retrieves metadata for a specific GitHub Actions artifact within a repository using the provided artifact ID.

        Args:
            owner (string): owner
            repo (string): repo
            artifact_id (string): artifact_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if artifact_id is None:
            raise ValueError("Missing required parameter 'artifact_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_delete_artifact(self, owner: str, repo: str, artifact_id: str) -> Any:
        """
        Deletes a GitHub Actions artifact identified by its ID within a specified repository.

        Args:
            owner (string): owner
            repo (string): repo
            artifact_id (string): artifact_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if artifact_id is None:
            raise ValueError("Missing required parameter 'artifact_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_download_artifact(self, owner: str, repo: str, artifact_id: str, archive_format: str) -> Any:
        """
        Downloads a GitHub Actions workflow artifact in the specified archive format (e.g., zip) from a repository.

        Args:
            owner (string): owner
            repo (string): repo
            artifact_id (string): artifact_id
            archive_format (string): archive_format

        Returns:
            Any: API response data.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if artifact_id is None:
            raise ValueError("Missing required parameter 'artifact_id'.")
        if archive_format is None:
            raise ValueError("Missing required parameter 'archive_format'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_repo_actions_cache_usage(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Retrieves the GitHub Actions cache usage for a specified repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/cache/usage"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_get_actions_cache_list(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None, ref: Optional[str] = None, key: Optional[str] = None, sort: Optional[str] = None, direction: Optional[str] = None) -> dict[str, Any]:
        """
        Retrieves a list of GitHub Actions caches for a specified repository, including cache size, key, and creation time, with optional filtering by reference, key, and sorting parameters.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            ref (string): The full Git reference for narrowing down the cache. The `ref` for a branch should be formatted as `refs/heads/<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.
            key (string): An explicit key or prefix for identifying the cache
            sort (string): The property to sort the results by. `created_at` means when the cache was created. `last_accessed_at` means when the cache was last accessed. `size_in_bytes` is the size of the cache in bytes.
            direction (string): The direction to sort the results by.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/caches"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page), ('ref', ref), ('key', key), ('sort', sort), ('direction', direction)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_cache(self, owner: str, repo: str, key: str, ref: Optional[str] = None) -> dict[str, Any]:
        """
        Deletes GitHub Actions caches for a repository using a cache key, optionally filtering by a Git reference, to manage and clear cache entries.

        Args:
            owner (string): owner
            repo (string): repo
            key (string): A key for identifying the cache.
            ref (string): The full Git reference for narrowing down the cache. The `ref` for a branch should be formatted as `refs/heads/<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/caches"
        query_params = {k: v for k, v in [('key', key), ('ref', ref)] if v is not None}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_cache_id(self, owner: str, repo: str, cache_id: str) -> Any:
        """
        Deletes a GitHub Actions cache for a specified repository using a cache ID, returning a successful status without content when the operation is completed.

        Args:
            owner (string): owner
            repo (string): repo
            cache_id (string): cache_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if cache_id is None:
            raise ValueError("Missing required parameter 'cache_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/caches/{cache_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_repo_action_job_by_id(self, owner: str, repo: str, job_id: str) -> dict[str, Any]:
        """
        Retrieves details about a specific GitHub Actions job identified by its ID within a repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            job_id (string): job_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if job_id is None:
            raise ValueError("Missing required parameter 'job_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/jobs/{job_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_repo_actions_job_logs(self, owner: str, repo: str, job_id: str) -> Any:
        """
        Retrieves the download URL for logs of a specific GitHub Actions workflow job.

        Args:
            owner (string): owner
            repo (string): repo
            job_id (string): job_id

        Returns:
            Any: API response data.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if job_id is None:
            raise ValueError("Missing required parameter 'job_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/jobs/{job_id}/logs"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def rerun_job(self, owner: str, repo: str, job_id: str, enable_debug_logging: Optional[bool] = None) -> dict[str, Any]:
        """
        Re-runs a specific GitHub Actions job and returns a success status upon job re-run initiation.

        Args:
            owner (string): owner
            repo (string): repo
            job_id (string): job_id
            enable_debug_logging (boolean): Whether to enable debug logging for the re-run.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if job_id is None:
            raise ValueError("Missing required parameter 'job_id'.")
        request_body_data = None
        request_body_data = {
            'enable_debug_logging': enable_debug_logging,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_customization_sub(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Retrieves the customization template for an OpenID Connect (OIDC) subject claim for a specified GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Status response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/oidc/customization/sub"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def custom_sub_oidc(self, owner: str, repo: str, use_default: bool, include_claim_keys: Optional[List[str]] = None) -> dict[str, Any]:
        """
        Sets the customization template and opt-in or opt-out flag for an OpenID Connect (OIDC) subject claim for a specific GitHub repository using the PUT method.

        Args:
            owner (string): owner
            repo (string): repo
            use_default (boolean): Whether to use the default template or not. If `true`, the `include_claim_keys` field is ignored. Example: False.
            include_claim_keys (array): Array of unique strings. Each claim key can only contain alphanumeric characters and underscores. Example: ['repo', 'context'].

        Returns:
            dict[str, Any]: Empty response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'use_default': use_default,
            'include_claim_keys': include_claim_keys,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/oidc/customization/sub"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_secrets(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a paginated list of organization-level GitHub Actions secrets accessible to the specified repository without exposing encrypted values.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/organization-secrets"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_organization_variables(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of organization variables associated with a GitHub repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/organization-variables"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_repo_permissions(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Retrieves the GitHub Actions permissions configuration for a specified repository.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/permissions"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_repo_actions_permissions(self, owner: str, repo: str, enabled: bool, allowed_actions: Optional[str] = None) -> Any:
        """
        Configures GitHub Actions permissions for a specified repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            enabled (boolean): Whether GitHub Actions is enabled on the repository. Example: True.
            allowed_actions (string): The permissions policy that controls the actions and reusable workflows that are allowed to run. Example: 'selected'.

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'enabled': enabled,
            'allowed_actions': allowed_actions,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/permissions"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_repo_access(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Retrieves GitHub Actions permissions settings for accessing repositories and allowed actions.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/permissions/access"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_repo_access(self, owner: str, repo: str, access_level: str) -> Any:
        """
        Configures access permissions for GitHub Actions within a specified repository using the "PUT" method.

        Args:
            owner (string): owner
            repo (string): repo
            access_level (string): Defines the level of access that workflows outside of the repository have to actions and reusable workflows within the
        repository.

        `none` means the access is only possible from workflows in this repository. `user` level access allows sharing across user owned private repositories only. `organization` level access allows sharing across the organization. Example: 'organization'.

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'access_level': access_level,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/permissions/access"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_selected_actions_permissions(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Retrieves the selected actions allowed for a GitHub repository using the "GET" method at the "/repos/{owner}/{repo}/actions/permissions/selected-actions" path.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/permissions/selected-actions"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_actions_permissions(self, owner: str, repo: str, github_owned_allowed: Optional[bool] = None, verified_allowed: Optional[bool] = None, patterns_allowed: Optional[List[str]] = None) -> Any:
        """
        Sets the selected actions for GitHub Actions permissions in a specified repository using the `PUT` method.

        Args:
            owner (string): owner
            repo (string): repo
            github_owned_allowed (boolean): Whether GitHub-owned actions are allowed. For example, this includes the actions in the `actions` organization. Example: True.
            verified_allowed (boolean): Whether actions from GitHub Marketplace verified creators are allowed. Set to `true` to allow all actions by GitHub Marketplace verified creators. Example: False.
            patterns_allowed (array): Specifies a list of string-matching patterns to allow specific action(s) and reusable workflow(s). Wildcards, tags, and SHAs are allowed. For example, `monalisa/octocat@*`, `monalisa/octocat@v2`, `monalisa/*`.

        > [!NOTE]
        > The `patterns_allowed` setting only applies to public repositories. Example: ['monalisa/octocat@*', 'docker/*'].

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'github_owned_allowed': github_owned_allowed,
            'verified_allowed': verified_allowed,
            'patterns_allowed': patterns_allowed,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/permissions/selected-actions"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_workflow_permissions(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Retrieves the default workflow permissions for the GitHub Actions GITHUB_TOKEN in a repository, including pull request review approval capabilities.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/permissions/workflow"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_workflow_permissions(self, owner: str, repo: str, default_workflow_permissions: Optional[str] = None, can_approve_pull_request_reviews: Optional[bool] = None) -> Any:
        """
        Updates the default workflow permissions and pull request review approval settings for a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            default_workflow_permissions (string): The default workflow permissions granted to the GITHUB_TOKEN when running workflows. Example: 'read'.
            can_approve_pull_request_reviews (boolean): Whether GitHub Actions can approve pull requests. Enabling this can be a security risk. Example: True.

        Returns:
            Any: Success response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'default_workflow_permissions': default_workflow_permissions,
            'can_approve_pull_request_reviews': can_approve_pull_request_reviews,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/permissions/workflow"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_repo_actions_runners(self, owner: str, repo: str, name: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Lists all self-hosted runners configured in a GitHub repository, including their status and configuration details.

        Args:
            owner (string): owner
            repo (string): repo
            name (string): The name of a self-hosted runner.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runners"
        query_params = {k: v for k, v in [('name', name), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_runner_downloads(self, owner: str, repo: str) -> list[Any]:
        """
        Retrieves a list of available runner applications for a specific GitHub repository, which can be used to set up self-hosted runners in GitHub Actions workflows.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runners/downloads"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def generate_runner_jit_config(self, owner: str, repo: str, name: str, runner_group_id: int, labels: List[str], work_folder: Optional[str] = None) -> dict[str, Any]:
        """
        Generates a configuration for a just-in-time (JIT) runner in a GitHub repository, allowing dynamic setup for specific workflows.

        Args:
            owner (string): owner
            repo (string): repo
            name (string): The name of the new runner. Example: 'New runner'.
            runner_group_id (integer): The ID of the runner group to register the runner to. Example: 1.
            labels (array): The names of the custom labels to add to the runner. **Minimum items**: 1. **Maximum items**: 100. Example: ['self-hosted', 'X64', 'macOS', 'no-gpu'].
            work_folder (string): The working directory to be used for job execution, relative to the runner install directory. Example: '_work'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'runner_group_id': runner_group_id,
            'labels': labels,
            'work_folder': work_folder,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runners/generate-jitconfig"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_runner_registration_token(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Creates a registration token for a repository using the GitHub Actions API, allowing the configuration of self-hosted runners to execute workflows on custom infrastructure.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runners/registration-token"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def remove_runner_token(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Generates a remove token for a repository using the GitHub API, allowing the secure removal of a self-hosted runner.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runners/remove-token"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_repo_runner_by_id(self, owner: str, repo: str, runner_id: str) -> dict[str, Any]:
        """
        Retrieves the details of a specific GitHub Actions runner for a repository using the "GET" method at the "/repos/{owner}/{repo}/actions/runners/{runner_id}" path.

        Args:
            owner (string): owner
            repo (string): repo
            runner_id (string): runner_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if runner_id is None:
            raise ValueError("Missing required parameter 'runner_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runners/{runner_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_repo_runner_by_id(self, owner: str, repo: str, runner_id: str) -> Any:
        """
        Removes a self-hosted runner from a GitHub repository via the GitHub API and returns a 204 No Content response on success.

        Args:
            owner (string): owner
            repo (string): repo
            runner_id (string): runner_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if runner_id is None:
            raise ValueError("Missing required parameter 'runner_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runners/{runner_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_runner_labels_by_id(self, owner: str, repo: str, runner_id: str) -> dict[str, Any]:
        """
        Retrieves a list of labels associated with a specific self-hosted runner in a GitHub repository using the API.

        Args:
            owner (string): owner
            repo (string): repo
            runner_id (string): runner_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if runner_id is None:
            raise ValueError("Missing required parameter 'runner_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def add_runner_label(self, owner: str, repo: str, runner_id: str, labels: List[str]) -> dict[str, Any]:
        """
        Adds custom labels to a self-hosted runner in a GitHub repository and returns the updated labels.

        Args:
            owner (string): owner
            repo (string): repo
            runner_id (string): runner_id
            labels (array): The names of the custom labels to add to the runner. Example: ['gpu', 'accelerated'].

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if runner_id is None:
            raise ValueError("Missing required parameter 'runner_id'.")
        request_body_data = None
        request_body_data = {
            'labels': labels,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def set_runner_labels(self, owner: str, repo: str, runner_id: str, labels: List[str]) -> dict[str, Any]:
        """
        Updates labels for a self-hosted runner in a GitHub repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            runner_id (string): runner_id
            labels (array): The names of the custom labels to set for the runner. You can pass an empty array to remove all custom labels. Example: ['gpu', 'accelerated'].

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if runner_id is None:
            raise ValueError("Missing required parameter 'runner_id'.")
        request_body_data = None
        request_body_data = {
            'labels': labels,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_runner_labels(self, owner: str, repo: str, runner_id: str) -> dict[str, Any]:
        """
        Removes a custom label from a specific self-hosted runner for a repository using the GitHub API and returns a status message.

        Args:
            owner (string): owner
            repo (string): repo
            runner_id (string): runner_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if runner_id is None:
            raise ValueError("Missing required parameter 'runner_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_runner_label_by_name(self, owner: str, repo: str, runner_id: str, name: str) -> dict[str, Any]:
        """
        Removes a custom label from a self-hosted runner in a GitHub repository using the GitHub API and returns the updated labels.

        Args:
            owner (string): owner
            repo (string): repo
            runner_id (string): runner_id
            name (string): name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if runner_id is None:
            raise ValueError("Missing required parameter 'runner_id'.")
        if name is None:
            raise ValueError("Missing required parameter 'name'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_repo_actions_runs(self, owner: str, repo: str, actor: Optional[str] = None, branch: Optional[str] = None, event: Optional[str] = None, status: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None, created: Optional[str] = None, exclude_pull_requests: Optional[bool] = None, check_suite_id: Optional[int] = None, head_sha: Optional[str] = None) -> dict[str, Any]:
        """
        Retrieves a list of workflow runs for a specified GitHub repository, allowing filtering by various criteria such as actor, branch, event, status, and more.

        Args:
            owner (string): owner
            repo (string): repo
            actor (string): Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run.
            branch (string): Returns workflow runs associated with a branch. Use the name of the branch of the `push`.
            event (string): Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see "[Events that trigger workflows](https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."
            status (string): Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            created (string): Returns workflow runs created within the given date-time range. For more information on the syntax, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."
            exclude_pull_requests (boolean): If `true` pull requests are omitted from the response (empty array).
            check_suite_id (integer): Returns workflow runs with the `check_suite_id` that you specify.
            head_sha (string): Only returns workflow runs that are associated with the specified `head_sha`.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runs"
        query_params = {k: v for k, v in [('actor', actor), ('branch', branch), ('event', event), ('status', status), ('per_page', per_page), ('page', page), ('created', created), ('exclude_pull_requests', exclude_pull_requests), ('check_suite_id', check_suite_id), ('head_sha', head_sha)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_get_workflow_run(self, owner: str, repo: str, run_id: str, exclude_pull_requests: Optional[bool] = None) -> dict[str, Any]:
        """
        Retrieves detailed information about a specific GitHub Actions workflow run, including its status, conclusion, and logs, using the "GET" method at the "/repos/{owner}/{repo}/actions/runs/{run_id}" endpoint.

        Args:
            owner (string): owner
            repo (string): repo
            run_id (string): run_id
            exclude_pull_requests (boolean): If `true` pull requests are omitted from the response (empty array).

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if run_id is None:
            raise ValueError("Missing required parameter 'run_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runs/{run_id}"
        query_params = {k: v for k, v in [('exclude_pull_requests', exclude_pull_requests)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_delete_workflow_run(self, owner: str, repo: str, run_id: str) -> Any:
        """
        Deletes a specific GitHub Actions workflow run from a repository.

        Args:
            owner (string): owner
            repo (string): repo
            run_id (string): run_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if run_id is None:
            raise ValueError("Missing required parameter 'run_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runs/{run_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_get_reviews_for_run(self, owner: str, repo: str, run_id: str) -> list[Any]:
        """
        Retrieves approval details for a specific GitHub Actions workflow run.

        Args:
            owner (string): owner
            repo (string): repo
            run_id (string): run_id

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if run_id is None:
            raise ValueError("Missing required parameter 'run_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runs/{run_id}/approvals"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_approve_workflow_run(self, owner: str, repo: str, run_id: str) -> dict[str, Any]:
        """
        Approves a GitHub Actions workflow run for a pull request from a public fork, typically used for first-time contributors, using the GitHub API and returns a success status.

        Args:
            owner (string): owner
            repo (string): repo
            run_id (string): run_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if run_id is None:
            raise ValueError("Missing required parameter 'run_id'.")
        request_body_data = None
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runs/{run_id}/approve"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_run_artifacts(self, owner: str, repo: str, run_id: str, per_page: Optional[int] = None, page: Optional[int] = None, name: Optional[str] = None) -> dict[str, Any]:
        """
        Retrieves a list of workflow run artifacts for a specific GitHub repository and run ID.

        Args:
            owner (string): owner
            repo (string): repo
            run_id (string): run_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            name (string): The name field of an artifact. When specified, only artifacts with this name will be returned.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if run_id is None:
            raise ValueError("Missing required parameter 'run_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page), ('name', name)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_attempt_run_details(self, owner: str, repo: str, run_id: str, attempt_number: str, exclude_pull_requests: Optional[bool] = None) -> dict[str, Any]:
        """
        Retrieves information about a specific workflow run attempt in GitHub Actions, allowing users to view details about the run instance, including its execution status and associated jobs, using the "GET" method.

        Args:
            owner (string): owner
            repo (string): repo
            run_id (string): run_id
            attempt_number (string): attempt_number
            exclude_pull_requests (boolean): If `true` pull requests are omitted from the response (empty array).

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if run_id is None:
            raise ValueError("Missing required parameter 'run_id'.")
        if attempt_number is None:
            raise ValueError("Missing required parameter 'attempt_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"
        query_params = {k: v for k, v in [('exclude_pull_requests', exclude_pull_requests)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_jobs_by_run_attempt(self, owner: str, repo: str, run_id: str, attempt_number: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of jobs for a specific attempt of a workflow run in a GitHub repository using the GitHub Actions API.

        Args:
            owner (string): owner
            repo (string): repo
            run_id (string): run_id
            attempt_number (string): attempt_number
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if run_id is None:
            raise ValueError("Missing required parameter 'run_id'.")
        if attempt_number is None:
            raise ValueError("Missing required parameter 'attempt_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_action_log(self, owner: str, repo: str, run_id: str, attempt_number: str) -> Any:
        """
        Retrieves the logs for a specific workflow run attempt using the GitHub Actions API.

        Args:
            owner (string): owner
            repo (string): repo
            run_id (string): run_id
            attempt_number (string): attempt_number

        Returns:
            Any: API response data.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if run_id is None:
            raise ValueError("Missing required parameter 'run_id'.")
        if attempt_number is None:
            raise ValueError("Missing required parameter 'attempt_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_cancel_workflow_run(self, owner: str, repo: str, run_id: str) -> dict[str, Any]:
        """
        Cancels a workflow run in a GitHub repository using the GitHub API and returns a status indicating success or conflict.

        Args:
            owner (string): owner
            repo (string): repo
            run_id (string): run_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if run_id is None:
            raise ValueError("Missing required parameter 'run_id'.")
        request_body_data = None
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runs/{run_id}/cancel"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_deployment_rule(self, owner: str, repo: str, run_id: str, environment_name: Optional[str] = None, comment: Optional[str] = None, state: Optional[str] = None) -> Any:
        """
        Associates a deployment protection rule with a GitHub Actions workflow run using the provided repository, owner, and run ID details.

        Args:
            owner (string): owner
            repo (string): repo
            run_id (string): run_id
            environment_name (string): The name of the environment to approve or reject. Example: 'prod-eus'.
            comment (string): Optional comment to include with the review. Example: 'All health checks passed.'.
            state (string): Whether to approve or reject deployment to the specified environments. Example: 'approved'.

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if run_id is None:
            raise ValueError("Missing required parameter 'run_id'.")
        request_body_data = None
        request_body_data = {
            'environment_name': environment_name,
            'comment': comment,
            'state': state,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def force_cancel_action_run(self, owner: str, repo: str, run_id: str) -> dict[str, Any]:
        """
        Forcibly cancels a GitHub Actions workflow run, bypassing conditional checks that would normally prevent cancellation.

        Args:
            owner (string): owner
            repo (string): repo
            run_id (string): run_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if run_id is None:
            raise ValueError("Missing required parameter 'run_id'.")
        request_body_data = None
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_job_runs(self, owner: str, repo: str, run_id: str, filter: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of jobs associated with a specific workflow run in a GitHub repository, including their status and execution details.

        Args:
            owner (string): owner
            repo (string): repo
            run_id (string): run_id
            filter (string): Filters jobs by their `completed_at` timestamp. `latest` returns jobs from the most recent execution of the workflow run. `all` returns all jobs for a workflow run, including from old executions of the workflow run.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if run_id is None:
            raise ValueError("Missing required parameter 'run_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
        query_params = {k: v for k, v in [('filter', filter), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_repo_actions_run_logs(self, owner: str, repo: str, run_id: str) -> Any:
        """
        Retrieves the logs for a specific GitHub Actions workflow run using the "GET" method, allowing users to access and analyze the execution details of a workflow by providing the repository owner, repository name, and workflow run ID.

        Args:
            owner (string): owner
            repo (string): repo
            run_id (string): run_id

        Returns:
            Any: API response data.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if run_id is None:
            raise ValueError("Missing required parameter 'run_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runs/{run_id}/logs"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_repo_actions_run_logs(self, owner: str, repo: str, run_id: str) -> Any:
        """
        Deletes logs associated with a specific workflow run in a GitHub repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            run_id (string): run_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if run_id is None:
            raise ValueError("Missing required parameter 'run_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runs/{run_id}/logs"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_pending_deployments(self, owner: str, repo: str, run_id: str) -> list[Any]:
        """
        Retrieves a list of pending deployments for a specified GitHub Actions workflow run.

        Args:
            owner (string): owner
            repo (string): repo
            run_id (string): run_id

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if run_id is None:
            raise ValueError("Missing required parameter 'run_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_deployment(self, owner: str, repo: str, run_id: str, environment_ids: List[int], state: str, comment: str) -> list[Any]:
        """
        Sends a request to create or manage pending deployments for a specific workflow run in a GitHub repository, using the provided parameters to identify the repository and workflow run.

        Args:
            owner (string): owner
            repo (string): repo
            run_id (string): run_id
            environment_ids (array): The list of environment ids to approve or reject Example: '[161171787, 161171795]'.
            state (string): Whether to approve or reject deployment to the specified environments. Example: 'approved'.
            comment (string): A comment to accompany the deployment review Example: 'Ship it!'.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if run_id is None:
            raise ValueError("Missing required parameter 'run_id'.")
        request_body_data = None
        request_body_data = {
            'environment_ids': environment_ids,
            'state': state,
            'comment': comment,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_re_run_workflow(self, owner: str, repo: str, run_id: str, enable_debug_logging: Optional[bool] = None) -> dict[str, Any]:
        """
        Re-runs a specific GitHub Actions workflow run using the POST method at "/repos/{owner}/{repo}/actions/runs/{run_id}/rerun", allowing for the re-execution of a workflow instance.

        Args:
            owner (string): owner
            repo (string): repo
            run_id (string): run_id
            enable_debug_logging (boolean): Whether to enable debug logging for the re-run.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if run_id is None:
            raise ValueError("Missing required parameter 'run_id'.")
        request_body_data = None
        request_body_data = {
            'enable_debug_logging': enable_debug_logging,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runs/{run_id}/rerun"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def rerun_failed_jobs(self, owner: str, repo: str, run_id: str, enable_debug_logging: Optional[bool] = None) -> dict[str, Any]:
        """
        Re-runs failed jobs for a specific GitHub Actions workflow run via the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            run_id (string): run_id
            enable_debug_logging (boolean): Whether to enable debug logging for the re-run.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if run_id is None:
            raise ValueError("Missing required parameter 'run_id'.")
        request_body_data = None
        request_body_data = {
            'enable_debug_logging': enable_debug_logging,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_get_workflow_run_usage(self, owner: str, repo: str, run_id: str) -> dict[str, Any]:
        """
        Retrieves timing metrics for a specific GitHub Actions workflow run, including duration and billable execution details.

        Args:
            owner (string): owner
            repo (string): repo
            run_id (string): run_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if run_id is None:
            raise ValueError("Missing required parameter 'run_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/runs/{run_id}/timing"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_list_repo_secrets(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a paginated list of repository secrets for GitHub Actions workflows.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/secrets"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_get_repo_public_key(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Retrieves the public key for encrypting secrets in a GitHub repository using the "GET" method at the "/repos/{owner}/{repo}/actions/secrets/public-key" endpoint.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/secrets/public-key"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_get_repo_secret(self, owner: str, repo: str, secret_name: str) -> dict[str, Any]:
        """
        Retrieves a specific GitHub Actions repository secret's metadata (excluding the encrypted value) using authenticated access.

        Args:
            owner (string): owner
            repo (string): repo
            secret_name (string): secret_name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/secrets/{secret_name}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_repo_secret_by_name(self, owner: str, repo: str, secret_name: str, encrypted_value: str, key_id: str) -> dict[str, Any]:
        """
        Creates or updates a repository secret for GitHub Actions workflows and returns a success status.

        Args:
            owner (string): owner
            repo (string): repo
            secret_name (string): secret_name
            encrypted_value (string): Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/actions/secrets#get-a-repository-public-key) endpoint. Example: 'c2VjcmV0'.
            key_id (string): ID of the key you used to encrypt the secret. Example: '012345678912345678'.

        Returns:
            dict[str, Any]: Response when creating a secret

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        request_body_data = None
        request_body_data = {
            'encrypted_value': encrypted_value,
            'key_id': key_id,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/secrets/{secret_name}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_delete_repo_secret(self, owner: str, repo: str, secret_name: str) -> Any:
        """
        Deletes a repository secret for use in GitHub Actions workflows by specifying the repository owner, repository name, and secret name, returning a successful status upon removal.

        Args:
            owner (string): owner
            repo (string): repo
            secret_name (string): secret_name

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/secrets/{secret_name}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_list_repo_variables(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of variables configured in a GitHub repository's Actions workflows, including their names and values.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/variables"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_create_repo_variable(self, owner: str, repo: str, name: str, value: str) -> dict[str, Any]:
        """
        Creates a repository variable for use in GitHub Actions workflows, allowing for the storage of configuration settings or sensitive information, by sending a POST request to the specified path with required parameters including owner, repository, variable name, and value.

        Args:
            owner (string): owner
            repo (string): repo
            name (string): The name of the variable. Example: 'USERNAME'.
            value (string): The value of the variable. Example: 'octocat'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'value': value,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/variables"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_get_repo_variable(self, owner: str, repo: str, name: str) -> dict[str, Any]:
        """
        Retrieves a specific variable from a GitHub repository using the GitHub API and returns its details.

        Args:
            owner (string): owner
            repo (string): repo
            name (string): name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if name is None:
            raise ValueError("Missing required parameter 'name'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/variables/{name}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_update_repo_variable(self, owner: str, repo: str, name: str, name_body: Optional[str] = None, value: Optional[str] = None) -> Any:
        """
        Updates a repository variable in GitHub Actions using the PATCH method, allowing for modification of the variable's value in a specified repository.

        Args:
            owner (string): owner
            repo (string): repo
            name (string): name
            name_body (string): The name of the variable. Example: 'USERNAME'.
            value (string): The value of the variable. Example: 'octocat'.

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if name is None:
            raise ValueError("Missing required parameter 'name'.")
        request_body_data = None
        request_body_data = {
            'name': name_body,
            'value': value,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/variables/{name}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_delete_repo_variable(self, owner: str, repo: str, name: str) -> Any:
        """
        Deletes a specified repository variable for GitHub Actions workflows using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            name (string): name

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if name is None:
            raise ValueError("Missing required parameter 'name'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/variables/{name}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_list_repo_workflows(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of GitHub Actions workflows configured in a repository.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/workflows"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_get_workflow(self, owner: str, repo: str, workflow_id: str) -> dict[str, Any]:
        """
        Retrieves details about a specific GitHub Actions workflow in a repository using the "GET" method.

        Args:
            owner (string): owner
            repo (string): repo
            workflow_id (string): workflow_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if workflow_id is None:
            raise ValueError("Missing required parameter 'workflow_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/workflows/{workflow_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_disable_workflow(self, owner: str, repo: str, workflow_id: str) -> Any:
        """
        Disables a GitHub Actions workflow, setting its state to "disabled_manually", using the PUT method via the API endpoint "/repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable".

        Args:
            owner (string): owner
            repo (string): repo
            workflow_id (string): workflow_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if workflow_id is None:
            raise ValueError("Missing required parameter 'workflow_id'.")
        request_body_data = None
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def dispatch_workflow(self, owner: str, repo: str, workflow_id: str, ref: str, inputs: Optional[dict[str, Any]] = None) -> Any:
        """
        Triggers a GitHub Actions workflow run manually using a dispatch event by sending a POST request to the specified workflow endpoint, allowing for controlled execution of workflows.

        Args:
            owner (string): owner
            repo (string): repo
            workflow_id (string): workflow_id
            ref (string): The git reference for the workflow. The reference can be a branch or tag name. Example: 'topic-branch'.
            inputs (object): Input keys and values configured in the workflow file. The maximum number of properties is 10. Any default properties configured in the workflow file will be used when `inputs` are omitted. Example: {'name': 'Mona the Octocat', 'home': 'San Francisco, CA'}.

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if workflow_id is None:
            raise ValueError("Missing required parameter 'workflow_id'.")
        request_body_data = None
        request_body_data = {
            'ref': ref,
            'inputs': inputs,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_enable_workflow(self, owner: str, repo: str, workflow_id: str) -> Any:
        """
        Enables a GitHub Actions workflow in a specified repository and returns no content upon success.

        Args:
            owner (string): owner
            repo (string): repo
            workflow_id (string): workflow_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if workflow_id is None:
            raise ValueError("Missing required parameter 'workflow_id'.")
        request_body_data = None
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_list_workflow_runs(self, owner: str, repo: str, workflow_id: str, actor: Optional[str] = None, branch: Optional[str] = None, event: Optional[str] = None, status: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None, created: Optional[str] = None, exclude_pull_requests: Optional[bool] = None, check_suite_id: Optional[int] = None, head_sha: Optional[str] = None) -> dict[str, Any]:
        """
        Retrieves a filtered list of workflow runs for a specific GitHub Actions workflow in a repository, supporting parameters like actor, branch, event type, and status.

        Args:
            owner (string): owner
            repo (string): repo
            workflow_id (string): workflow_id
            actor (string): Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run.
            branch (string): Returns workflow runs associated with a branch. Use the name of the branch of the `push`.
            event (string): Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see "[Events that trigger workflows](https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."
            status (string): Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            created (string): Returns workflow runs created within the given date-time range. For more information on the syntax, see "[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."
            exclude_pull_requests (boolean): If `true` pull requests are omitted from the response (empty array).
            check_suite_id (integer): Returns workflow runs with the `check_suite_id` that you specify.
            head_sha (string): Only returns workflow runs that are associated with the specified `head_sha`.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if workflow_id is None:
            raise ValueError("Missing required parameter 'workflow_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"
        query_params = {k: v for k, v in [('actor', actor), ('branch', branch), ('event', event), ('status', status), ('per_page', per_page), ('page', page), ('created', created), ('exclude_pull_requests', exclude_pull_requests), ('check_suite_id', check_suite_id), ('head_sha', head_sha)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_get_workflow_usage(self, owner: str, repo: str, workflow_id: str) -> dict[str, Any]:
        """
        Retrieves timing information for a GitHub Actions workflow using the "GET" method.

        Args:
            owner (string): owner
            repo (string): repo
            workflow_id (string): workflow_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if workflow_id is None:
            raise ValueError("Missing required parameter 'workflow_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_list_activities(self, owner: str, repo: str, direction: Optional[str] = None, per_page: Optional[int] = None, before: Optional[str] = None, after: Optional[str] = None, ref: Optional[str] = None, actor: Optional[str] = None, time_period: Optional[str] = None, activity_type: Optional[str] = None) -> list[Any]:
        """
        Retrieves and formats activity events for a GitHub repository, including filtering by actor, reference, time period, and activity type.

        Args:
            owner (string): owner
            repo (string): repo
            direction (string): The direction to sort the results by.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            before (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            after (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            ref (string): The Git reference for the activities you want to list. The `ref` for a branch can be formatted either as `refs/heads/BRANCH_NAME` or `BRANCH_NAME`, where `BRANCH_NAME` is the name of your branch.
            actor (string): The GitHub username to use to filter by the actor who performed the activity.
            time_period (string): The time period to filter by. For example, `day` will filter for activity that occurred in the past 24 hours, and `week` will filter for activity that occurred in the past 7 days (168 hours).
            activity_type (string): The activity type to filter by. For example, you can choose to filter by "force_push", to see all force pushes to the repository.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/activity"
        query_params = {k: v for k, v in [('direction', direction), ('per_page', per_page), ('before', before), ('after', after), ('ref', ref), ('actor', actor), ('time_period', time_period), ('activity_type', activity_type)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_list_assignees(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of available assignees for issues and pull requests in a specified GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/assignees"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_assignee(self, owner: str, repo: str, assignee: str) -> Any:
        """
        Retrieves information about a specific assignee in a GitHub repository using the GET method on the "/repos/{owner}/{repo}/assignees/{assignee}" path.

        Args:
            owner (string): owner
            repo (string): repo
            assignee (string): assignee

        Returns:
            Any: If the `assignee` can be assigned to issues in the repository, a `204` header with no content is returned.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if assignee is None:
            raise ValueError("Missing required parameter 'assignee'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/assignees/{assignee}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_create_attestation(self, owner: str, repo: str, bundle: dict[str, Any]) -> dict[str, Any]:
        """
        Creates and stores an artifact attestation for a repository, associating it with the specified subject and predicate.

        Args:
            owner (string): owner
            repo (string): repo
            bundle (object): The attestation's Sigstore Bundle.
        Refer to the [Sigstore Bundle Specification](https://github.com/sigstore/protobuf-specs/blob/main/protos/sigstore_bundle.proto) for more information.

        Returns:
            dict[str, Any]: response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'bundle': bundle,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/attestations"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_list_attestations(self, owner: str, repo: str, subject_digest: str, per_page: Optional[int] = None, before: Optional[str] = None, after: Optional[str] = None, predicate_type: Optional[str] = None) -> dict[str, Any]:
        """
        Retrieves artifact attestations associated with a specific subject digest for a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            subject_digest (string): subject_digest
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            before (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            after (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            predicate_type (string): Optional filter for fetching attestations with a given predicate type.
        This option accepts `provenance`, `sbom`, or freeform text for custom predicate types.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if subject_digest is None:
            raise ValueError("Missing required parameter 'subject_digest'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/attestations/{subject_digest}"
        query_params = {k: v for k, v in [('per_page', per_page), ('before', before), ('after', after), ('predicate_type', predicate_type)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_list_autolinks(self, owner: str, repo: str) -> list[Any]:
        """
        Retrieves a list of autolink references configured for a GitHub repository to link external resources like issue trackers.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/autolinks"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_create_autolink(self, owner: str, repo: str, key_prefix: str, url_template: str, is_alphanumeric: Optional[bool] = None) -> dict[str, Any]:
        """
        Creates an autolink reference for a GitHub repository, allowing users to link external resources like JIRA issues or Zendesk tickets directly from their repository.

        Args:
            owner (string): owner
            repo (string): repo
            key_prefix (string): This prefix appended by certain characters will generate a link any time it is found in an issue, pull request, or commit. Example: 'TICKET-'.
            url_template (string): The URL must contain `<num>` for the reference number. `<num>` matches different characters depending on the value of `is_alphanumeric`. Example: 'https://example.com/TICKET?query=<num>'.
            is_alphanumeric (boolean): Whether this autolink reference matches alphanumeric characters. If true, the `<num>` parameter of the `url_template` matches alphanumeric characters `A-Z` (case insensitive), `0-9`, and `-`. If false, this autolink reference only matches numeric characters. Example: True.

        Returns:
            dict[str, Any]: response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'key_prefix': key_prefix,
            'url_template': url_template,
            'is_alphanumeric': is_alphanumeric,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/autolinks"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_autolink(self, owner: str, repo: str, autolink_id: str) -> dict[str, Any]:
        """
        Retrieves a specific autolink for a GitHub repository using the "GET" method, allowing access to the details of the autolink identified by the provided autolink ID.

        Args:
            owner (string): owner
            repo (string): repo
            autolink_id (string): autolink_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if autolink_id is None:
            raise ValueError("Missing required parameter 'autolink_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/autolinks/{autolink_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_delete_autolink(self, owner: str, repo: str, autolink_id: str) -> Any:
        """
        Deletes an autolink reference from a GitHub repository using the repository's owner, name, and the autolink ID.

        Args:
            owner (string): owner
            repo (string): repo
            autolink_id (string): autolink_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if autolink_id is None:
            raise ValueError("Missing required parameter 'autolink_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/autolinks/{autolink_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_security_fixes(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Retrieves the status of automated security fixes for a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Response if Dependabot is enabled

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/automated-security-fixes"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def enable_automated_security_fixes(self, owner: str, repo: str) -> Any:
        """
        Enables or disables automated security fixes for a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        url = f"{self.base_url}/repos/{owner}/{repo}/automated-security-fixes"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_security_fixes(self, owner: str, repo: str) -> Any:
        """
        Deletes automated security fixes for a specified GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/automated-security-fixes"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_list_branches(self, owner: str, repo: str, protected: Optional[bool] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of branches for a specified GitHub repository, optionally filtering by protected status and pagination.

        Args:
            owner (string): owner
            repo (string): repo
            protected (boolean): Setting to `true` returns only branches protected by branch protections or rulesets. When set to `false`, only unprotected branches are returned. Omitting this parameter returns all branches.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/branches"
        query_params = {k: v for k, v in [('protected', protected), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_branch(self, owner: str, repo: str, branch: str) -> dict[str, Any]:
        """
        Retrieves all active rules that apply to a specific branch in a GitHub repository, including repository and organization-level rules.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_branch_protection(self, owner: str, repo: str, branch: str) -> dict[str, Any]:
        """
        Retrieves the branch protection settings for a specific branch in a GitHub repository using the "GET" method.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_update_branch_protection(self, owner: str, repo: str, branch: str, required_status_checks: dict[str, Any], enforce_admins: bool, required_pull_request_reviews: dict[str, Any], restrictions: dict[str, Any], required_linear_history: Optional[bool] = None, allow_force_pushes: Optional[bool] = None, allow_deletions: Optional[bool] = None, block_creations: Optional[bool] = None, required_conversation_resolution: Optional[bool] = None, lock_branch: Optional[bool] = None, allow_fork_syncing: Optional[bool] = None) -> dict[str, Any]:
        """
        Updates branch protection rules for the specified branch in a GitHub repository using the GitHub REST API.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch
            required_status_checks (object): Require status checks to pass before merging. Set to `null` to disable. Example: {'strict': True, 'contexts': ['continuous-integration/travis-ci']}.
            enforce_admins (boolean): Enforce all configured restrictions for administrators. Set to `true` to enforce required status checks for repository administrators. Set to `null` to disable. Example: True.
            required_pull_request_reviews (object): Require at least one approving review on a pull request, before merging. Set to `null` to disable. Example: {'dismissal_restrictions': {'users': ['octocat'], 'teams': ['justice-league']}, 'dismiss_stale_reviews': True, 'require_code_owner_reviews': True, 'required_approving_review_count': 2, 'require_last_push_approval': True, 'bypass_pull_request_allowances': {'users': ['octocat'], 'teams': ['justice-league']}}.
            restrictions (object): Restrict who can push to the protected branch. User, app, and team `restrictions` are only available for organization-owned repositories. Set to `null` to disable. Example: {'users': ['octocat'], 'teams': ['justice-league'], 'apps': ['super-ci']}.
            required_linear_history (boolean): Enforces a linear commit Git history, which prevents anyone from pushing merge commits to a branch. Set to `true` to enforce a linear commit history. Set to `false` to disable a linear commit Git history. Your repository must allow squash merging or rebase merging before you can enable a linear commit history. Default: `false`. For more information, see "[Requiring a linear commit history](https://docs.github.com/github/administering-a-repository/requiring-a-linear-commit-history)" in the GitHub Help documentation. Example: True.
            allow_force_pushes (boolean): Permits force pushes to the protected branch by anyone with write access to the repository. Set to `true` to allow force pushes. Set to `false` or `null` to block force pushes. Default: `false`. For more information, see "[Enabling force pushes to a protected branch](https://docs.github.com/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)" in the GitHub Help documentation." Example: True.
            allow_deletions (boolean): Allows deletion of the protected branch by anyone with write access to the repository. Set to `false` to prevent deletion of the protected branch. Default: `false`. For more information, see "[Enabling force pushes to a protected branch](https://docs.github.com/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)" in the GitHub Help documentation. Example: True.
            block_creations (boolean): If set to `true`, the `restrictions` branch protection settings which limits who can push will also block pushes which create new branches, unless the push is initiated by a user, team, or app which has the ability to push. Set to `true` to restrict new branch creation. Default: `false`. Example: True.
            required_conversation_resolution (boolean): Requires all conversations on code to be resolved before a pull request can be merged into a branch that matches this rule. Set to `false` to disable. Default: `false`. Example: True.
            lock_branch (boolean): Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. Default: `false`. Example: True.
            allow_fork_syncing (boolean): Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing. Default: `false`. Example: True.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        request_body_data = None
        request_body_data = {
            'required_status_checks': required_status_checks,
            'enforce_admins': enforce_admins,
            'required_pull_request_reviews': required_pull_request_reviews,
            'restrictions': restrictions,
            'required_linear_history': required_linear_history,
            'allow_force_pushes': allow_force_pushes,
            'allow_deletions': allow_deletions,
            'block_creations': block_creations,
            'required_conversation_resolution': required_conversation_resolution,
            'lock_branch': lock_branch,
            'allow_fork_syncing': allow_fork_syncing,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_delete_branch_protection(self, owner: str, repo: str, branch: str) -> Any:
        """
        Removes branch protection rules for the specified branch in a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_branch_protection(self, owner: str, repo: str, branch: str) -> dict[str, Any]:
        """
        Retrieves information about whether admin enforcement is enabled for a branch protection rule in a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def enforce_admins_protection(self, owner: str, repo: str, branch: str) -> dict[str, Any]:
        """
        Updates branch protection to enforce restrictions on administrators using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        request_body_data = None
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def unprotect_branch_admins(self, owner: str, repo: str, branch: str) -> Any:
        """
        Removes the enforcement of branch protection rules that require administrators to approve changes to a specified branch in a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_required_reviews(self, owner: str, repo: str, branch: str) -> dict[str, Any]:
        """
        Retrieves the required pull request review protection settings for a specific branch in a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_branch_protection(self, owner: str, repo: str, branch: str, dismissal_restrictions: Optional[dict[str, Any]] = None, dismiss_stale_reviews: Optional[bool] = None, require_code_owner_reviews: Optional[bool] = None, required_approving_review_count: Optional[int] = None, require_last_push_approval: Optional[bool] = None, bypass_pull_request_allowances: Optional[dict[str, Any]] = None) -> dict[str, Any]:
        """
        Updates the required pull request review protection rules for a specified repository branch.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch
            dismissal_restrictions (object): Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories. Example: {'users': ['octocat'], 'teams': ['justice-league'], 'apps': ['octoapp']}.
            dismiss_stale_reviews (boolean): Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit. Example: True.
            require_code_owner_reviews (boolean): Blocks merging pull requests until [code owners](https://docs.github.com/articles/about-code-owners/) have reviewed. Example: True.
            required_approving_review_count (integer): Specifies the number of reviewers required to approve pull requests. Use a number between 1 and 6 or 0 to not require reviewers. Example: 2.
            require_last_push_approval (boolean): Whether the most recent push must be approved by someone other than the person who pushed it. Default: `false` Example: True.
            bypass_pull_request_allowances (object): Allow specific users, teams, or apps to bypass pull request requirements. Example: {'users': ['octocat'], 'teams': ['justice-league'], 'apps': ['octoapp']}.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        request_body_data = None
        request_body_data = {
            'dismissal_restrictions': dismissal_restrictions,
            'dismiss_stale_reviews': dismiss_stale_reviews,
            'require_code_owner_reviews': require_code_owner_reviews,
            'required_approving_review_count': required_approving_review_count,
            'require_last_push_approval': require_last_push_approval,
            'bypass_pull_request_allowances': bypass_pull_request_allowances,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_pull_request_reviews(self, owner: str, repo: str, branch: str) -> Any:
        """
        Removes required pull request review protections from a branch in a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_required_signatures(self, owner: str, repo: str, branch: str) -> dict[str, Any]:
        """
        Retrieves commit signature protection status for a specific branch in a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def enable_branch_signatures(self, owner: str, repo: str, branch: str) -> dict[str, Any]:
        """
        Enables required commit signatures for a specific branch in a GitHub repository, ensuring only signed and verified commits can be pushed to the branch.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        request_body_data = None
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_branch_protection(self, owner: str, repo: str, branch: str) -> Any:
        """
        Removes required commit signature verification for a protected branch on GitHub.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_branch_status_checks(self, owner: str, repo: str, branch: str) -> dict[str, Any]:
        """
        Retrieves the required status checks configuration for a protected branch in a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_branch_protection_checks(self, owner: str, repo: str, branch: str, strict: Optional[bool] = None, contexts: Optional[List[str]] = None, checks: Optional[List[dict[str, Any]]] = None) -> dict[str, Any]:
        """
        Updates the required status checks configuration for a protected branch in a GitHub repository, enforcing specific checks and strictness rules.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch
            strict (boolean): Require branches to be up to date before merging. Example: True.
            contexts (array): **Closing down notice**: The list of status checks to require in order to merge into this branch. If any of these checks have recently been set by a particular GitHub App, they will be required to come from that app in future for the branch to merge. Use `checks` instead of `contexts` for more fine-grained control. Example: ['continuous-integration/travis-ci'].
            checks (array): The list of status checks to require in order to merge into this branch.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        request_body_data = None
        request_body_data = {
            'strict': strict,
            'contexts': contexts,
            'checks': checks,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_required_status_checks(self, owner: str, repo: str, branch: str) -> Any:
        """
        Removes required status checks protection from a protected branch in a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_branch_protection_contexts(self, owner: str, repo: str, branch: str) -> list[Any]:
        """
        Retrieves the list of required status check contexts configured for a protected branch's merge restrictions.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_status_context(self, owner: str, repo: str, branch: str, contexts: Optional[List[str]] = None) -> list[Any]:
        """
        Updates the list of required status check contexts for a GitHub repository's protected branch, defining which checks must pass before merging.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch
            contexts (array): The name of the status checks Example: ['continuous-integration/travis-ci', 'continuous-integration/jenkins'].

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        request_body_data = None
        request_body_data = {
            'contexts': contexts,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_status_check_contexts(self, owner: str, repo: str, branch: str, contexts: Optional[List[str]] = None) -> list[Any]:
        """
        Updates the list of required status check contexts for a protected branch in a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch
            contexts (array): The name of the status checks Example: ['continuous-integration/travis-ci'].

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        request_body_data = None
        request_body_data = {
            'contexts': contexts,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_status_check_contexts(self, owner: str, repo: str, branch: str, contexts: Optional[List[str]] = None) -> list[Any]:
        """
        Removes required status check contexts for a protected branch in a GitHub repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch
            contexts (array): The name of the status checks Example: ['continuous-integration/jenkins'].

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        request_body_data = {
            'contexts': contexts,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_access_restrictions(self, owner: str, repo: str, branch: str) -> dict[str, Any]:
        """
        Retrieves access restriction settings (users, teams, and apps) for a protected branch.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_branch_restrictions(self, owner: str, repo: str, branch: str) -> Any:
        """
        Deletes branch protection restrictions for a specific branch in a GitHub repository, effectively removing access limitations for users, teams, or apps from that branch.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_repo_branch_protection_apps(self, owner: str, repo: str, branch: str) -> list[Any]:
        """
        Retrieves restrictions on GitHub Apps for a specific branch protection rule, using the specified repository and branch details.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def add_branch_protection_app(self, owner: str, repo: str, branch: str, apps: List[str]) -> list[Any]:
        """
        Adds app access restrictions to a protected branch in a GitHub repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch
            apps (array): The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items. Example: ['octoapp'].

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        request_body_data = None
        request_body_data = {
            'apps': apps,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_branch_restrictions_apps(self, owner: str, repo: str, branch: str, apps: List[str]) -> list[Any]:
        """
        Sets the list of apps with push access to a protected branch, replacing any previous apps in the restrictions list.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch
            apps (array): The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items. Example: ['octoapp'].

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        request_body_data = None
        request_body_data = {
            'apps': apps,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_branch_protection_apps(self, owner: str, repo: str, branch: str, apps: List[str]) -> list[Any]:
        """
        Removes app access restrictions from a GitHub repository's protected branch, disallowing specified apps to push changes.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch
            apps (array): The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items. Example: ['my-app'].

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        request_body_data = {
            'apps': apps,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_branch_protection_teams(self, owner: str, repo: str, branch: str) -> list[Any]:
        """
        Retrieves the list of teams with push access to a protected branch in a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def add_branch_protection_teams(self, owner: str, repo: str, branch: str, teams: Optional[List[str]] = None) -> list[Any]:
        """
        Adds team access restrictions to a protected branch in a GitHub repository using the "POST" method.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch
            teams (array): The slug values for teams Example: ['justice-league'].

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        request_body_data = None
        request_body_data = {
            'teams': teams,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_branch_protection_teams(self, owner: str, repo: str, branch: str, teams: Optional[List[str]] = None) -> list[Any]:
        """
        Sets the list of teams with push access to a protected branch in a GitHub repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch
            teams (array): The slug values for teams Example: ['justice-league'].

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        request_body_data = None
        request_body_data = {
            'teams': teams,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_branch_protection_teams(self, owner: str, repo: str, branch: str, teams: Optional[List[str]] = None) -> list[Any]:
        """
        Removes team access restrictions from a protected branch in a GitHub repository using the "DELETE" method.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch
            teams (array): The slug values for teams Example: ['octocats'].

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        request_body_data = {
            'teams': teams,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_branch_users(self, owner: str, repo: str, branch: str) -> list[Any]:
        """
        Retrieves a list of users with permission to push to a protected branch in a GitHub repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def add_branch_protection_users(self, owner: str, repo: str, branch: str, users: List[str]) -> list[Any]:
        """
        Adds restrictions to a GitHub repository branch by specifying users who are allowed to push to the protected branch using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch
            users (array): The username for users Example: ['octocat'].

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        request_body_data = None
        request_body_data = {
            'users': users,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_branch_protection_users(self, owner: str, repo: str, branch: str, users: List[str]) -> list[Any]:
        """
        Updates the list of users with push access to a protected branch in a GitHub repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch
            users (array): The username for users Example: ['octocat'].

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        request_body_data = None
        request_body_data = {
            'users': users,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_branch_restriction_user(self, owner: str, repo: str, branch: str, users: List[str]) -> list[Any]:
        """
        Removes users with push access restrictions for a branch in a GitHub repository using the DELETE method.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch
            users (array): The username for users Example: ['octocat'].

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        request_body_data = {
            'users': users,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_rename_branch(self, owner: str, repo: str, branch: str, new_name: str) -> dict[str, Any]:
        """
        Renames a branch in a GitHub repository using the "POST" method, updating its name and related references.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch
            new_name (string): The new name of the branch. Example: 'my_renamed_branch'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        request_body_data = None
        request_body_data = {
            'new_name': new_name,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/branches/{branch}/rename"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def checks_create(self, owner: str, repo: str, name: str, head_sha: str, status: Optional[str] = None, details_url: Optional[str] = None, external_id: Optional[str] = None, started_at: Optional[str] = None, conclusion: Optional[str] = None, completed_at: Optional[str] = None, output: Optional[dict[str, Any]] = None, actions: Optional[List[dict[str, Any]]] = None) -> dict[str, Any]:
        """
        Creates a new check run for a specific repository commit using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            name (string): The name of the check. For example, "code-coverage". Example: 'mighty_readme'.
            head_sha (string): The SHA of the commit. Example: 'ce587453ced02b1526dfb4cb910479d431683101'.
            status (string): The current status of the check run. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`. Example: 'in_progress'.
            details_url (string): The URL of the integrator's site that has the full details of the check. If the integrator does not provide this, then the homepage of the GitHub app is used.
            external_id (string): A reference for the run on the integrator's system. Example: '42'.
            started_at (string): The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Example: '2018-05-04T01:14:52Z'.
            conclusion (string): **Required if you provide `completed_at` or a `status` of `completed`**. The final conclusion of the check. 
        **Note:** Providing `conclusion` will automatically set the `status` parameter to `completed`. You cannot change a check run conclusion to `stale`, only GitHub can set this.
            completed_at (string): The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            output (object): Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run. Example: {'title': 'Mighty Readme report', 'summary': '', 'text': ''}.
            actions (array): Displays a button on GitHub that can be clicked to alert your app to do additional tasks. For example, a code linting app can display a button that automatically fixes detected errors. The button created in this object is displayed after the check run completes. When a user clicks the button, GitHub sends the [`check_run.requested_action` webhook](https://docs.github.com/webhooks/event-payloads/#check_run) to your app. Each action includes a `label`, `identifier` and `description`. A maximum of three actions are accepted. To learn more about check runs and requested actions, see "[Check runs and requested actions](https://docs.github.com/rest/guides/using-the-rest-api-to-interact-with-checks#check-runs-and-requested-actions)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            checks
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'status': status,
            'name': name,
            'head_sha': head_sha,
            'details_url': details_url,
            'external_id': external_id,
            'started_at': started_at,
            'conclusion': conclusion,
            'completed_at': completed_at,
            'output': output,
            'actions': actions,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/check-runs"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def checks_get(self, owner: str, repo: str, check_run_id: str) -> dict[str, Any]:
        """
        Retrieves information about a specific check run in a GitHub repository using the provided check run ID.

        Args:
            owner (string): owner
            repo (string): repo
            check_run_id (string): check_run_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            checks
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if check_run_id is None:
            raise ValueError("Missing required parameter 'check_run_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/check-runs/{check_run_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def checks_update(self, owner: str, repo: str, check_run_id: str, status: Optional[str] = None, name: Optional[str] = None, details_url: Optional[str] = None, external_id: Optional[str] = None, started_at: Optional[str] = None, conclusion: Optional[str] = None, completed_at: Optional[str] = None, output: Optional[dict[str, Any]] = None, actions: Optional[List[dict[str, Any]]] = None) -> dict[str, Any]:
        """
        Updates an existing check run in a GitHub repository using the specified check run ID.

        Args:
            owner (string): owner
            repo (string): repo
            check_run_id (string): check_run_id
            status (string): The current status of the check run. Only GitHub Actions can set a status of `waiting`, `pending`, or `requested`. Example: 'completed'.
            name (string): The name of the check. For example, "code-coverage". Example: 'mighty_readme'.
            details_url (string): The URL of the integrator's site that has the full details of the check.
            external_id (string): A reference for the run on the integrator's system.
            started_at (string): This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Example: '2018-05-04T01:14:52Z'.
            conclusion (string): **Required if you provide `completed_at` or a `status` of `completed`**. The final conclusion of the check. 
        **Note:** Providing `conclusion` will automatically set the `status` parameter to `completed`. You cannot change a check run conclusion to `stale`, only GitHub can set this. Example: 'success'.
            completed_at (string): The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Example: '2018-05-04T01:14:52Z'.
            output (object): Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run. Example: {'title': 'Mighty Readme report', 'summary': 'There are 0 failures, 2 warnings, and 1 notices.', 'text': 'You may have some misspelled words on lines 2 and 4. You also may want to add a section in your README about how to install your app.', 'annotations': [{'path': 'README.md', 'annotation_level': 'warning', 'title': 'Spell Checker', 'message': "Check your spelling for 'banaas'.", 'raw_details': "Do you mean 'bananas' or 'banana'?", 'start_line': 2, 'end_line': 2}, {'path': 'README.md', 'annotation_level': 'warning', 'title': 'Spell Checker', 'message': "Check your spelling for 'aples'", 'raw_details': "Do you mean 'apples' or 'Naples'", 'start_line': 4, 'end_line': 4}], 'images': [{'alt': 'Super bananas', 'image_url': 'http://example.com/images/42'}]}.
            actions (array): Possible further actions the integrator can perform, which a user may trigger. Each action includes a `label`, `identifier` and `description`. A maximum of three actions are accepted. To learn more about check runs and requested actions, see "[Check runs and requested actions](https://docs.github.com/rest/guides/using-the-rest-api-to-interact-with-checks#check-runs-and-requested-actions)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            checks
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if check_run_id is None:
            raise ValueError("Missing required parameter 'check_run_id'.")
        request_body_data = None
        request_body_data = {
            'status': status,
            'name': name,
            'details_url': details_url,
            'external_id': external_id,
            'started_at': started_at,
            'conclusion': conclusion,
            'completed_at': completed_at,
            'output': output,
            'actions': actions,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/check-runs/{check_run_id}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def checks_list_annotations(self, owner: str, repo: str, check_run_id: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves annotations (e.g., errors, warnings, notices) for a specific check run in a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            check_run_id (string): check_run_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            checks
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if check_run_id is None:
            raise ValueError("Missing required parameter 'check_run_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def checks_rerequest_run(self, owner: str, repo: str, check_run_id: str) -> dict[str, Any]:
        """
        Triggers GitHub to rerequest an existing check run without code changes, resetting its status to queued and clearing previous conclusions.

        Args:
            owner (string): owner
            repo (string): repo
            check_run_id (string): check_run_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            checks
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if check_run_id is None:
            raise ValueError("Missing required parameter 'check_run_id'.")
        request_body_data = None
        url = f"{self.base_url}/repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def checks_create_suite(self, owner: str, repo: str, head_sha: str) -> dict[str, Any]:
        """
        Creates a manual check suite for a GitHub repository commit when automatic creation is disabled, returning success or creation status.

        Args:
            owner (string): owner
            repo (string): repo
            head_sha (string): The sha of the head commit. Example: 'd6fde92930d4715a2b49857d24b940956b26d2d3'.

        Returns:
            dict[str, Any]: Response when the suite already exists

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            checks
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'head_sha': head_sha,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/check-suites"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def checks_set_suites_preferences(self, owner: str, repo: str, auto_trigger_checks: Optional[List[dict[str, Any]]] = None) -> dict[str, Any]:
        """
        Updates the repository preferences for check suites using the GitHub API, allowing control over the automatic creation of check suites on code pushes.

        Args:
            owner (string): owner
            repo (string): repo
            auto_trigger_checks (array): Enables or disables automatic creation of CheckSuite events upon pushes to the repository. Enabled by default. Example: [{'app_id': 4, 'setting': False}].

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            checks
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'auto_trigger_checks': auto_trigger_checks,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/check-suites/preferences"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def checks_get_suite(self, owner: str, repo: str, check_suite_id: str) -> dict[str, Any]:
        """
        Retrieves a specific check suite by its ID from a GitHub repository, providing details about its status and check runs.

        Args:
            owner (string): owner
            repo (string): repo
            check_suite_id (string): check_suite_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            checks
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if check_suite_id is None:
            raise ValueError("Missing required parameter 'check_suite_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/check-suites/{check_suite_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def checks_list_for_suite(self, owner: str, repo: str, check_suite_id: str, check_name: Optional[str] = None, status: Optional[str] = None, filter: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of check runs associated with a specific check suite in a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            check_suite_id (string): check_suite_id
            check_name (string): Returns check runs with the specified `name`.
            status (string): Returns check runs with the specified `status`.
            filter (string): Filters check runs by their `completed_at` timestamp. `latest` returns the most recent check runs.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            checks
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if check_suite_id is None:
            raise ValueError("Missing required parameter 'check_suite_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"
        query_params = {k: v for k, v in [('check_name', check_name), ('status', status), ('filter', filter), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def checks_rerequest_suite(self, owner: str, repo: str, check_suite_id: str) -> dict[str, Any]:
        """
        Triggers GitHub to rerequest an existing check suite without new code pushes, returning a success status.

        Args:
            owner (string): owner
            repo (string): repo
            check_suite_id (string): check_suite_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            checks
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if check_suite_id is None:
            raise ValueError("Missing required parameter 'check_suite_id'.")
        request_body_data = None
        url = f"{self.base_url}/repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_code_scanning_alerts(self, owner: str, repo: str, tool_name: Optional[str] = None, tool_guid: Optional[str] = None, page: Optional[int] = None, per_page: Optional[int] = None, ref: Optional[str] = None, pr: Optional[int] = None, direction: Optional[str] = None, before: Optional[str] = None, after: Optional[str] = None, sort: Optional[str] = None, state: Optional[str] = None, severity: Optional[str] = None) -> list[Any]:
        """
        Retrieves a list of code scanning alerts for a specified repository, allowing filtering by parameters such as tool, page, and severity.

        Args:
            owner (string): owner
            repo (string): repo
            tool_name (string): The name of a code scanning tool. Only results by this tool will be listed. You can specify the tool by using either `tool_name` or `tool_guid`, but not both.
            tool_guid (string): The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code scanning tools may not include a GUID in their analysis data. You can specify the tool by using either `tool_guid` or `tool_name`, but not both.
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            ref (string): The Git reference for the results you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.
            pr (integer): The number of the pull request for the results you want to list.
            direction (string): The direction to sort the results by.
            before (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            after (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            sort (string): The property by which to sort the results.
            state (string): If specified, only code scanning alerts with this state will be returned.
            severity (string): If specified, only code scanning alerts with this severity will be returned.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-scanning
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/code-scanning/alerts"
        query_params = {k: v for k, v in [('tool_name', tool_name), ('tool_guid', tool_guid), ('page', page), ('per_page', per_page), ('ref', ref), ('pr', pr), ('direction', direction), ('before', before), ('after', after), ('sort', sort), ('state', state), ('severity', severity)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def code_scanning_get_alert(self, owner: str, repo: str, alert_number: str) -> dict[str, Any]:
        """
        Retrieves all instances of a specified code scanning alert from a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            alert_number (string): alert_number

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-scanning
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if alert_number is None:
            raise ValueError("Missing required parameter 'alert_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def code_scanning_update_alert(self, owner: str, repo: str, alert_number: str, state: str, dismissed_reason: Optional[str] = None, dismissed_comment: Optional[str] = None, create_request: Optional[bool] = None) -> dict[str, Any]:
        """
        Updates a code scanning alert in a GitHub repository using the "PATCH" method, allowing users to modify the alert status based on parameters like the repository owner, repository name, and alert number.

        Args:
            owner (string): owner
            repo (string): repo
            alert_number (string): alert_number
            state (string): Sets the state of the code scanning alert. You must provide `dismissed_reason` when you set the state to `dismissed`. Example: 'dismissed'.
            dismissed_reason (string): **Required when the state is dismissed.** The reason for dismissing or closing the alert. Example: 'false positive'.
            dismissed_comment (string): The dismissal comment associated with the dismissal of the alert. Example: "This alert is not actually correct, because there's a sanitizer included in the library.".
            create_request (boolean): If `true`, attempt to create an alert dismissal request. Example: True.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-scanning
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if alert_number is None:
            raise ValueError("Missing required parameter 'alert_number'.")
        request_body_data = None
        request_body_data = {
            'state': state,
            'dismissed_reason': dismissed_reason,
            'dismissed_comment': dismissed_comment,
            'create_request': create_request,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def code_scanning_get_autofix(self, owner: str, repo: str, alert_number: str) -> dict[str, Any]:
        """
        Retrieves the status of an autofix for a specific code scanning alert in a repository, providing information about suggested fixes generated by GitHub Copilot Autofix.

        Args:
            owner (string): owner
            repo (string): repo
            alert_number (string): alert_number

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-scanning
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if alert_number is None:
            raise ValueError("Missing required parameter 'alert_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def code_scanning_create_autofix(self, owner: str, repo: str, alert_number: str) -> dict[str, Any]:
        """
        Creates an autofix for a specified code scanning alert in a GitHub repository, allowing users to generate targeted fixes for identified vulnerabilities or errors.

        Args:
            owner (string): owner
            repo (string): repo
            alert_number (string): alert_number

        Returns:
            dict[str, Any]: OK

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-scanning
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if alert_number is None:
            raise ValueError("Missing required parameter 'alert_number'.")
        request_body_data = None
        url = f"{self.base_url}/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def code_scanning_commit_autofix(self, owner: str, repo: str, alert_number: str, target_ref: Optional[str] = None, message: Optional[str] = None) -> dict[str, Any]:
        """
        Commits an autofix for a code scanning alert in a GitHub repository, returning a 201 Created response if the autofix is successfully committed.

        Args:
            owner (string): owner
            repo (string): repo
            alert_number (string): alert_number
            target_ref (string): The Git reference of target branch for the commit. Branch needs to already exist.  For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation. Example: 'refs/heads/fix-bug'.
            message (string): Commit message to be used. Example: "Let's fix this !".

        Returns:
            dict[str, Any]: Created

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-scanning
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if alert_number is None:
            raise ValueError("Missing required parameter 'alert_number'.")
        request_body_data = None
        request_body_data = {
            'target_ref': target_ref,
            'message': message,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix/commits"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_alert_instances(self, owner: str, repo: str, alert_number: str, page: Optional[int] = None, per_page: Optional[int] = None, ref: Optional[str] = None, pr: Optional[int] = None) -> list[Any]:
        """
        Retrieves all instances of a specified code scanning alert for a repository, including details of each occurrence across branches or pull requests.

        Args:
            owner (string): owner
            repo (string): repo
            alert_number (string): alert_number
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            ref (string): The Git reference for the results you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.
            pr (integer): The number of the pull request for the results you want to list.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-scanning
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if alert_number is None:
            raise ValueError("Missing required parameter 'alert_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"
        query_params = {k: v for k, v in [('page', page), ('per_page', per_page), ('ref', ref), ('pr', pr)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_repo_code_scanning_analyses(self, owner: str, repo: str, tool_name: Optional[str] = None, tool_guid: Optional[str] = None, page: Optional[int] = None, per_page: Optional[int] = None, pr: Optional[int] = None, ref: Optional[str] = None, sarif_id: Optional[str] = None, direction: Optional[str] = None, sort: Optional[str] = None) -> list[Any]:
        """
        Retrieves a specified code scanning analysis for a GitHub repository, providing details such as the analysis date, tool used, and number of alerts, with optional SARIF-formatted data.

        Args:
            owner (string): owner
            repo (string): repo
            tool_name (string): The name of a code scanning tool. Only results by this tool will be listed. You can specify the tool by using either `tool_name` or `tool_guid`, but not both.
            tool_guid (string): The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code scanning tools may not include a GUID in their analysis data. You can specify the tool by using either `tool_guid` or `tool_name`, but not both.
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            pr (integer): The number of the pull request for the results you want to list.
            ref (string): The Git reference for the analyses you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.
            sarif_id (string): Filter analyses belonging to the same SARIF upload. Example: '6c81cd8e-b078-4ac3-a3be-1dad7dbd0b53'.
            direction (string): The direction to sort the results by.
            sort (string): The property by which to sort the results.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-scanning
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/code-scanning/analyses"
        query_params = {k: v for k, v in [('tool_name', tool_name), ('tool_guid', tool_guid), ('page', page), ('per_page', per_page), ('pr', pr), ('ref', ref), ('sarif_id', sarif_id), ('direction', direction), ('sort', sort)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def code_scanning_get_analysis(self, owner: str, repo: str, analysis_id: str) -> dict[str, Any]:
        """
        Retrieves a specified code scanning analysis for a GitHub repository, providing details such as the Git reference, commit SHA, analysis date, tool name, and number of alerts.

        Args:
            owner (string): owner
            repo (string): repo
            analysis_id (string): analysis_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-scanning
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if analysis_id is None:
            raise ValueError("Missing required parameter 'analysis_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def code_scanning_delete_analysis(self, owner: str, repo: str, analysis_id: str, confirm_delete: Optional[str] = None) -> dict[str, Any]:
        """
        Deletes a specific code scanning analysis from a GitHub repository, optionally requiring confirmation.

        Args:
            owner (string): owner
            repo (string): repo
            analysis_id (string): analysis_id
            confirm_delete (string): Allow deletion if the specified analysis is the last in a set. If you attempt to delete the final analysis in a set without setting this parameter to `true`, you'll get a 400 response with the message: `Analysis is last of its type and deletion may result in the loss of historical alert data. Please specify confirm_delete.`

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-scanning
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if analysis_id is None:
            raise ValueError("Missing required parameter 'analysis_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
        query_params = {k: v for k, v in [('confirm_delete', confirm_delete)] if v is not None}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_code_scanning_databases(self, owner: str, repo: str) -> list[Any]:
        """
        Retrieves information about a CodeQL database for a specified GitHub repository, using the repository's owner and name as parameters.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-scanning
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/code-scanning/codeql/databases"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_codeql_database_by_language(self, owner: str, repo: str, language: str) -> dict[str, Any]:
        """
        Retrieves a CodeQL database for a specific language in a GitHub repository, allowing optional download as a ZIP file by setting the appropriate `Accept` header.

        Args:
            owner (string): owner
            repo (string): repo
            language (string): language

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-scanning
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if language is None:
            raise ValueError("Missing required parameter 'language'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_codeql_database(self, owner: str, repo: str, language: str) -> Any:
        """
        Deletes a specific CodeQL database for a repository based on the specified programming language.

        Args:
            owner (string): owner
            repo (string): repo
            language (string): language

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-scanning
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if language is None:
            raise ValueError("Missing required parameter 'language'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_codeql_analysis(self, owner: str, repo: str, language: str, query_pack: str, repositories: Optional[List[str]] = None, repository_lists: Optional[List[str]] = None, repository_owners: Optional[List[str]] = None) -> dict[str, Any]:
        """
        Creates a variant analysis for CodeQL in a GitHub repository using the "POST" method, facilitating the identification of vulnerabilities through multi-repository variant analysis.

        Args:
            owner (string): owner
            repo (string): repo
            language (string): The language targeted by the CodeQL query Example: 'csharp'.
            query_pack (string): A Base64-encoded tarball containing a CodeQL query and all its dependencies Example: 'aGVsbG8='.
            repositories (array): List of repository names (in the form `owner/repo-name`) to run the query against. Precisely one property from `repositories`, `repository_lists` and `repository_owners` is required. Example: ['octocat/Hello-World', 'octocat/example'].
            repository_lists (array): List of repository lists to run the query against. Precisely one property from `repositories`, `repository_lists` and `repository_owners` is required.
            repository_owners (array): List of organization or user names whose repositories the query should be run against. Precisely one property from `repositories`, `repository_lists` and `repository_owners` is required.

        Returns:
            dict[str, Any]: Variant analysis submitted for processing

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-scanning
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'language': language,
            'query_pack': query_pack,
            'repositories': repositories,
            'repository_lists': repository_lists,
            'repository_owners': repository_owners,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/code-scanning/codeql/variant-analyses"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_variant_analysis(self, owner: str, repo: str, codeql_variant_analysis_id: str) -> dict[str, Any]:
        """
        Retrieves the summary of a CodeQL variant analysis for a specific repository, including analysis status and results.

        Args:
            owner (string): owner
            repo (string): repo
            codeql_variant_analysis_id (string): codeql_variant_analysis_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-scanning
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if codeql_variant_analysis_id is None:
            raise ValueError("Missing required parameter 'codeql_variant_analysis_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_codeql_variant_analysis(self, owner: str, repo: str, codeql_variant_analysis_id: str, repo_owner: str, repo_name: str) -> dict[str, Any]:
        """
        Retrieves the analysis status of a specific repository within a CodeQL variant analysis workflow using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            codeql_variant_analysis_id (string): codeql_variant_analysis_id
            repo_owner (string): repo_owner
            repo_name (string): repo_name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-scanning
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if codeql_variant_analysis_id is None:
            raise ValueError("Missing required parameter 'codeql_variant_analysis_id'.")
        if repo_owner is None:
            raise ValueError("Missing required parameter 'repo_owner'.")
        if repo_name is None:
            raise ValueError("Missing required parameter 'repo_name'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}/repos/{repo_owner}/{repo_name}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_code_scanning_setup(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Retrieves the default code scanning configuration setup for a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-scanning
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/code-scanning/default-setup"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def patch_default_setup_code_scanning(self, owner: str, repo: str, state: Optional[str] = None, runner_type: Optional[str] = None, runner_label: Optional[str] = None, query_suite: Optional[str] = None, languages: Optional[List[str]] = None) -> dict[str, Any]:
        """
        Enables or updates the default code scanning configuration for a GitHub repository using CodeQL analysis.

        Args:
            owner (string): owner
            repo (string): repo
            state (string): The desired state of code scanning default setup. Example: 'configured'.
            runner_type (string): Runner type to be used.
            runner_label (string): Runner label to be used if the runner type is labeled. Example: 'code-scanning'.
            query_suite (string): CodeQL query suite to be used.
            languages (array): CodeQL languages to be analyzed.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-scanning
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'state': state,
            'runner_type': runner_type,
            'runner_label': runner_label,
            'query_suite': query_suite,
            'languages': languages,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/code-scanning/default-setup"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def code_scanning_upload_sarif(self, owner: str, repo: str, commit_sha: str, ref: str, sarif: str, checkout_uri: Optional[str] = None, started_at: Optional[str] = None, tool_name: Optional[str] = None, validate: Optional[bool] = None) -> dict[str, Any]:
        """
        Uploads a Static Analysis Results Interchange Format (SARIF) file as code scanning analysis results to a GitHub repository, allowing for the integration of external code analysis tools with GitHub's code scanning feature.

        Args:
            owner (string): owner
            repo (string): repo
            commit_sha (string): The SHA of the commit to which the analysis you are uploading relates. Example: '4b6472266afd7b471e86085a6659e8c7f2b119da'.
            ref (string): The full Git reference, formatted as `refs/heads/<branch name>`,
        `refs/tags/<tag>`, `refs/pull/<number>/merge`, or `refs/pull/<number>/head`. Example: 'refs/heads/main'.
            sarif (string): A Base64 string representing the SARIF file to upload. You must first compress your SARIF file using [`gzip`](http://www.gnu.org/software/gzip/manual/gzip.html) and then translate the contents of the file into a Base64 encoding string. For more information, see "[SARIF support for code scanning](https://docs.github.com/code-security/secure-coding/sarif-support-for-code-scanning)." Example: 'H4sICMLGdF4AA2V4YW1wbGUuc2FyaWYAvVjdbts2FL7PUxDCijaA/CM7iRNfLkPXYgHSNstumlzQ0pHFVCI1korjFgH2ONtr7Ul2KFmy/mOn6QIkjsjDw0/nfN85NL8dEGL9pNwAImqRObECrWM1H40kXQ2XTAfJIlEgXcE1cD10RTQSVDE10K4aKSqZP1AxuKOIKg1ydJU60jSfSh8Hk6EzHA/vlOCWbfa7B6kYPpj90rlsWCZcmbHP5Bs+4oAWIjQD2SMOeJLh2vIQDnIaQerqXHjw8YIgxohybxAyDsS4cAPKsp03K4RcUs6+Up2D+JXpd8mibKIQN9fM/aMCdbyBujGSSQgVxJtx5qX2d2qUcIweQhEuDQf3GBO6CKHkogx/N3MVCKl/AeVKFuf4y5ubsMGDTj1ep+5I7sgmLIpxtU38hLtmMRGSuCFVyip5eKzs5ydh+LztVL6f2m6oih1BkYiuyQIIJWodxVpERPj4sEiWBNNH8EWT0DMG8EAjzKVHXCrB4FkPu/F64NMk1OeC+2yZSNoBOoR7CC0EzYWGbm+xFDFIzbI011+cLjfZtyJkmMZfumAh02uL3NpV2y+MZ6RAjxibyKrNxxJcVjANSb4eBGwZ1M0KsuyR2poLr5rMl8vaDSeVn6eTWEO2j2xIEcmhwlTKNOi4GMOI8gfuZYkvJ7b4v5Tiumyz7RnHeodFzpS8ASIZCH/AYdWi2z3sG8JtFxJ6fF9yR9CdifBr9Pd6d5V2+zbJKjjCFGGmsHuYFy2ytJq9tUxcLSRSQecppOGKrpUxYfxefMEFK+wOGa4hudQByBVT0L+EKtyACxnRsABhEx1QjVDs1KNI9MbpnhqfE45B6FJvu3hRu5VRU9MhZLmK7fqkKyQSTHNoyMqUFMqXCV3CwAeqEwmVokraK8IuBaGvHjQ0gMYrKjnjyw7uk9uD8tgmsBbFMPnU1bV2ZhkJNkuolUiWys3UPWzs5aaIUz9TBe8zMb+6+nT+6fLy91dlE3xzeDDT4zYszb0bW6NjJd0Rvn2EnLvWLFSdKPpBzInzfRgu8ETyMcH8nIfMnJCeC2PyfTA+UKngcnGH7Hw2hGkVQs5YlIRCtdWZYQ4/73es2JlxkfViOEIhoWJq5Oo6UBBfiKIqFBWhiE3jJGbFwVoxBHTRSuIS67sMeplei24X20shLjG+8gqbKC/bESiNMC+wd5q5id0yeS7CJEqXzmrTWNq3k05l84P6f4/bEmXFJjI0fIt1BGQssUnUDkBYeVhE5TqPnMH3jqogDcP0zKcTgLPTMSzOjhbjuVOmW23l1fYNStulfo6sXlFsGLhbDy5RECPRYGCTgOj2bd4nUQEivEd0H7KKYxqnEhFohuur3a3UPskbH/+Yg0+M5P2MHRJu3ziHh3Z2NCrWt3XF1rWTw8Ne/pfbWYXnDSE0SNZQQt1i18q7te2vOhu7ehWuvVyeu0wbLZi24mhoo6aOOTltzG/lgdVvVoXQq5V+pewkFIzL8fjEcadT55jOjpzFzHuOTtDNrMkJPMVQDd7F09RID72O/UPZ0tmctqZ7kWX6EmSZnDpP8GU67SXM8XE3YSrxbKsx6UReZ4y6n/FVZfJjs9Z7stma75W5yQtkzjk5eSJxk1lv4o7+j8TlhaJ2lsKWZO6lruDPBLib3x5ZN/KGWzZ+pn///evv7OOf4iIBv3oY9L/l1wiJ9p0Tc+F1zZnOE9NxXWEus6IQhr5pMfoqxi8WPsuu0azsns4UC6WzNzHIzbeEx4P/AJ3SefgcFAAA'.
            checkout_uri (string): The base directory used in the analysis, as it appears in the SARIF file.
        This property is used to convert file paths from absolute to relative, so that alerts can be mapped to their correct location in the repository. Example: 'file:///github/workspace/'.
            started_at (string): The time that the analysis run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            tool_name (string): The name of the tool used to generate the code scanning analysis. If this parameter is not used, the tool name defaults to "API". If the uploaded SARIF contains a tool GUID, this will be available for filtering using the `tool_guid` parameter of operations such as `GET /repos/{owner}/{repo}/code-scanning/alerts`.
            validate (boolean): Whether the SARIF file will be validated according to the code scanning specifications.
        This parameter is intended to help integrators ensure that the uploaded SARIF files are correctly rendered by code scanning.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-scanning
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'commit_sha': commit_sha,
            'ref': ref,
            'sarif': sarif,
            'checkout_uri': checkout_uri,
            'started_at': started_at,
            'tool_name': tool_name,
            'validate': validate,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/code-scanning/sarifs"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def code_scanning_get_sarif(self, owner: str, repo: str, sarif_id: str) -> dict[str, Any]:
        """
        Retrieves information about a specific SARIF upload for a repository, providing details such as the status and analysis URL associated with the given SARIF ID.

        Args:
            owner (string): owner
            repo (string): repo
            sarif_id (string): sarif_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-scanning
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if sarif_id is None:
            raise ValueError("Missing required parameter 'sarif_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_code_security_config(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Retrieves a code security configuration for a specified GitHub repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            code-security
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/code-security-configuration"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_codeowners_errors(self, owner: str, repo: str, ref: Optional[str] = None) -> dict[str, Any]:
        """
        Retrieves a list of errors in a repository's CODEOWNERS file using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            ref (string): A branch, tag or commit name used to determine which version of the CODEOWNERS file to use. Default: the repository's default branch (e.g. `main`)

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/codeowners/errors"
        query_params = {k: v for k, v in [('ref', ref)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_repo_codespaces(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Lists the authenticated user's codespaces in a specified GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/codespaces"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_repo_codespace(self, owner: str, repo: str, ref: Optional[str] = None, location: Optional[str] = None, geo: Optional[str] = None, client_ip: Optional[str] = None, machine: Optional[str] = None, devcontainer_path: Optional[str] = None, multi_repo_permissions_opt_out: Optional[bool] = None, working_directory: Optional[str] = None, idle_timeout_minutes: Optional[int] = None, display_name: Optional[str] = None, retention_period_minutes: Optional[int] = None) -> dict[str, Any]:
        """
        Creates a codespace for the specified repository using the GitHub API, initializing the development environment with the repository's configuration.

        Args:
            owner (string): owner
            repo (string): repo
            ref (string): Git ref (typically a branch name) for this codespace Example: 'main'.
            location (string): The requested location for a new codespace. Best efforts are made to respect this upon creation. Assigned by IP if not provided.
            geo (string): The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is closing down.
            client_ip (string): IP for location auto-detection when proxying a request
            machine (string): Machine type to use for this codespace Example: 'standardLinux32gb'.
            devcontainer_path (string): Path to devcontainer.json config to use for this codespace
            multi_repo_permissions_opt_out (boolean): Whether to authorize requested permissions from devcontainer.json
            working_directory (string): Working directory for this codespace
            idle_timeout_minutes (integer): Time in minutes before codespace stops from inactivity
            display_name (string): Display name for this codespace
            retention_period_minutes (integer): Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).

        Returns:
            dict[str, Any]: Response when the codespace was successfully created

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'ref': ref,
            'location': location,
            'geo': geo,
            'client_ip': client_ip,
            'machine': machine,
            'devcontainer_path': devcontainer_path,
            'multi_repo_permissions_opt_out': multi_repo_permissions_opt_out,
            'working_directory': working_directory,
            'idle_timeout_minutes': idle_timeout_minutes,
            'display_name': display_name,
            'retention_period_minutes': retention_period_minutes,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/codespaces"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_dev_container_config(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of available dev container configurations for a GitHub repository, supporting pagination.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/codespaces/devcontainers"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_repo_codespaces_machines(self, owner: str, repo: str, location: Optional[str] = None, client_ip: Optional[str] = None, ref: Optional[str] = None) -> dict[str, Any]:
        """
        Retrieves available machine types for creating or updating a codespace in a specific repository, considering location, client IP, and branch parameters.

        Args:
            owner (string): owner
            repo (string): repo
            location (string): The location to check for available machines. Assigned by IP if not provided. Example: 'WestUs2'.
            client_ip (string): IP for location auto-detection when proxying a request
            ref (string): The branch or commit to check for prebuild availability and devcontainer restrictions. Example: 'main'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/codespaces/machines"
        query_params = {k: v for k, v in [('location', location), ('client_ip', client_ip), ('ref', ref)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_new_codespace_for_repo(self, owner: str, repo: str, ref: Optional[str] = None, client_ip: Optional[str] = None) -> dict[str, Any]:
        """
        Checks if the authenticated user can create a codespace in the specified repository and returns a success response if allowed.

        Args:
            owner (string): owner
            repo (string): repo
            ref (string): The branch or commit to check for a default devcontainer path. If not specified, the default branch will be checked. Example: 'main'.
            client_ip (string): An alternative IP for default location auto-detection, such as when proxying a request. Example: '1.2.3.4'.

        Returns:
            dict[str, Any]: Response when a user is able to create codespaces from the repository.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/codespaces/new"
        query_params = {k: v for k, v in [('ref', ref), ('client_ip', client_ip)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def check_codespace_permissions(self, owner: str, repo: str, ref: str, devcontainer_path: str) -> dict[str, Any]:
        """
        Checks the permissions for a codespace in a specified repository using the GitHub API and returns a status message, allowing for verification of access rights based on the provided reference and devcontainer path.

        Args:
            owner (string): owner
            repo (string): repo
            ref (string): The git reference that points to the location of the devcontainer configuration to use for the permission check. The value of `ref` will typically be a branch name (`heads/BRANCH_NAME`). For more information, see "[Git References]( in the Git documentation. Example: 'master'.
            devcontainer_path (string): Path to the devcontainer.json configuration to use for the permission check. Example: '.devcontainer/example/devcontainer.json'.

        Returns:
            dict[str, Any]: Response when the permission check is successful

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/codespaces/permissions_check"
        query_params = {k: v for k, v in [('ref', ref), ('devcontainer_path', devcontainer_path)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def codespaces_list_repo_secrets(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of Codespaces repository secrets for a specified repository without revealing their encrypted values.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/codespaces/secrets"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def codespaces_get_repo_public_key(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Retrieves a GitHub repository's public key, necessary for encrypting secrets before creating or updating them for use in GitHub Codespaces.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/codespaces/secrets/public-key"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def codespaces_get_repo_secret(self, owner: str, repo: str, secret_name: str) -> dict[str, Any]:
        """
        Retrieves a specific repository's Codespaces secret (such as access tokens) without exposing its encrypted value.

        Args:
            owner (string): owner
            repo (string): repo
            secret_name (string): secret_name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_codespace_secret(self, owner: str, repo: str, secret_name: str, encrypted_value: Optional[str] = None, key_id: Optional[str] = None) -> dict[str, Any]:
        """
        Updates or creates a repository secret for a GitHub Codespaces environment using the specified repository and secret name.

        Args:
            owner (string): owner
            repo (string): repo
            secret_name (string): secret_name
            encrypted_value (string): Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/codespaces/repository-secrets#get-a-repository-public-key) endpoint. Example: 'c2VjcmV0'.
            key_id (string): ID of the key you used to encrypt the secret. Example: '012345678912345678'.

        Returns:
            dict[str, Any]: Response when creating a secret

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        request_body_data = None
        request_body_data = {
            'encrypted_value': encrypted_value,
            'key_id': key_id,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def codespaces_delete_repo_secret(self, owner: str, repo: str, secret_name: str) -> Any:
        """
        Deletes a repository-specific development environment secret for GitHub Codespaces, removing access from all associated codespaces.

        Args:
            owner (string): owner
            repo (string): repo
            secret_name (string): secret_name

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_list_collaborators(self, owner: str, repo: str, affiliation: Optional[str] = None, permission: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of collaborators for a GitHub repository using the "GET" method, allowing filtering by affiliation and permission.

        Args:
            owner (string): owner
            repo (string): repo
            affiliation (string): Filter collaborators returned by their affiliation. `outside` means all outside collaborators of an organization-owned repository. `direct` means all collaborators with permissions to an organization-owned repository, regardless of organization membership status. `all` means all collaborators the authenticated user can see.
            permission (string): Filter collaborators by the permissions they have on the repository. If not specified, all collaborators will be returned.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/collaborators"
        query_params = {k: v for k, v in [('affiliation', affiliation), ('permission', permission), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_check_collaborator(self, owner: str, repo: str, username: str) -> Any:
        """
        Checks if a specified user is a collaborator in a GitHub repository, returning a 204 status code if the user is a collaborator or a 404 status code if not.

        Args:
            owner (string): owner
            repo (string): repo
            username (string): username

        Returns:
            Any: Response if user is a collaborator

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/collaborators/{username}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_add_collaborator(self, owner: str, repo: str, username: str, permission: Optional[str] = None) -> dict[str, Any]:
        """
        Adds or updates a repository collaborator's permissions using the GitHub API and returns a success status.

        Args:
            owner (string): owner
            repo (string): repo
            username (string): username
            permission (string): The permission to grant the collaborator. **Only valid on organization-owned repositories.** We accept the following permissions to be set: `pull`, `triage`, `push`, `maintain`, `admin` and you can also specify a custom repository role name, if the owning organization has defined any. Example: 'triage'.

        Returns:
            dict[str, Any]: Response when a new invitation is created

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        request_body_data = None
        request_body_data = {
            'permission': permission,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/collaborators/{username}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_remove_collaborator(self, owner: str, repo: str, username: str) -> Any:
        """
        Removes a collaborator from a GitHub repository and deletes their private forks if applicable.

        Args:
            owner (string): owner
            repo (string): repo
            username (string): username

        Returns:
            Any: No Content when collaborator was removed from the repository.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/collaborators/{username}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_repo_collaborator_permission(self, owner: str, repo: str, username: str) -> dict[str, Any]:
        """
        Checks the repository permission of a collaborator by retrieving their access level, which can be `admin`, `write`, `read`, or `none`, for a specified GitHub repository using the "GET" method.

        Args:
            owner (string): owner
            repo (string): repo
            username (string): username

        Returns:
            dict[str, Any]: if user has admin permissions

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/collaborators/{username}/permission"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_repo_comments(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of commit comments for a specified GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/comments"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_commit_comment(self, owner: str, repo: str, comment_id: str) -> dict[str, Any]:
        """
        Retrieves a specific comment from a GitHub repository using the provided repository owner, repository name, and comment ID.

        Args:
            owner (string): owner
            repo (string): repo
            comment_id (string): comment_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if comment_id is None:
            raise ValueError("Missing required parameter 'comment_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/comments/{comment_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_update_commit_comment(self, owner: str, repo: str, comment_id: str, body: str) -> dict[str, Any]:
        """
        Updates a commit comment in a GitHub repository and returns the modified comment.

        Args:
            owner (string): owner
            repo (string): repo
            comment_id (string): comment_id
            body (string): The contents of the comment Example: 'Nice change'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if comment_id is None:
            raise ValueError("Missing required parameter 'comment_id'.")
        request_body_data = None
        request_body_data = {
            'body': body,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/comments/{comment_id}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_delete_commit_comment(self, owner: str, repo: str, comment_id: str) -> Any:
        """
        Deletes a specific comment from a GitHub repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            comment_id (string): comment_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if comment_id is None:
            raise ValueError("Missing required parameter 'comment_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/comments/{comment_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_repo_comment_reactions(self, owner: str, repo: str, comment_id: str, content: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of reactions for a specific comment in a GitHub repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            comment_id (string): comment_id
            content (string): Returns a single [reaction type]( Omit this parameter to list all reactions to a commit comment.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            reactions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if comment_id is None:
            raise ValueError("Missing required parameter 'comment_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/comments/{comment_id}/reactions"
        query_params = {k: v for k, v in [('content', content), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_reaction(self, owner: str, repo: str, comment_id: str, content: str) -> dict[str, Any]:
        """
        Adds a reaction (e.g., , , ) to a repository's commit comment using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            comment_id (string): comment_id
            content (string): The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the commit comment. Example: 'heart'.

        Returns:
            dict[str, Any]: Reaction exists

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            reactions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if comment_id is None:
            raise ValueError("Missing required parameter 'comment_id'.")
        request_body_data = None
        request_body_data = {
            'content': content,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/comments/{comment_id}/reactions"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_repo_comment_reaction_by_id(self, owner: str, repo: str, comment_id: str, reaction_id: str) -> Any:
        """
        Deletes a reaction from a repository comment using the GitHub API and returns a success status upon completion.

        Args:
            owner (string): owner
            repo (string): repo
            comment_id (string): comment_id
            reaction_id (string): reaction_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            reactions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if comment_id is None:
            raise ValueError("Missing required parameter 'comment_id'.")
        if reaction_id is None:
            raise ValueError("Missing required parameter 'reaction_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_list_commits(self, owner: str, repo: str, sha: Optional[str] = None, path: Optional[str] = None, author: Optional[str] = None, committer: Optional[str] = None, since: Optional[str] = None, until: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a filtered list of commits from a GitHub repository with optional parameters for author, timeframe, path, and pagination.

        Args:
            owner (string): owner
            repo (string): repo
            sha (string): SHA or branch to start listing commits from. Default: the repositorys default branch (usually `main`).
            path (string): Only commits containing this file path will be returned.
            author (string): GitHub username or email address to use to filter by commit author.
            committer (string): GitHub username or email address to use to filter by commit committer.
            since (string): Only show results that were last updated after the given time. This is a timestamp in [ISO 8601]( format: `YYYY-MM-DDTHH:MM:SSZ`. Due to limitations of Git, timestamps must be between 1970-01-01 and 2099-12-31 (inclusive) or unexpected results may be returned.
            until (string): Only commits before this date will be returned. This is a timestamp in [ISO 8601]( format: `YYYY-MM-DDTHH:MM:SSZ`. Due to limitations of Git, timestamps must be between 1970-01-01 and 2099-12-31 (inclusive) or unexpected results may be returned.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/commits"
        query_params = {k: v for k, v in [('sha', sha), ('path', path), ('author', author), ('committer', committer), ('since', since), ('until', until), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_branches_by_commit(self, owner: str, repo: str, commit_sha: str) -> list[Any]:
        """
        Retrieves the branches in a GitHub repository where the specified commit is the head (latest commit).

        Args:
            owner (string): owner
            repo (string): repo
            commit_sha (string): commit_sha

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if commit_sha is None:
            raise ValueError("Missing required parameter 'commit_sha'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_list_comments_for_commit(self, owner: str, repo: str, commit_sha: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of comments made on a specific commit in a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            commit_sha (string): commit_sha
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if commit_sha is None:
            raise ValueError("Missing required parameter 'commit_sha'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/commits/{commit_sha}/comments"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_create_commit_comment(self, owner: str, repo: str, commit_sha: str, body: str, path: Optional[str] = None, position: Optional[int] = None, line: Optional[int] = None) -> dict[str, Any]:
        """
        Creates a comment on a specific commit in a GitHub repository using the provided commit SHA.

        Args:
            owner (string): owner
            repo (string): repo
            commit_sha (string): commit_sha
            body (string): The contents of the comment. Example: 'Great stuff'.
            path (string): Relative path of the file to comment on. Example: 'file1.txt'.
            position (integer): Line index in the diff to comment on. Example: 4.
            line (integer): **Closing down notice**. Use **position** parameter instead. Line number in the file to comment on. Example: 1.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if commit_sha is None:
            raise ValueError("Missing required parameter 'commit_sha'.")
        request_body_data = None
        request_body_data = {
            'body': body,
            'path': path,
            'position': position,
            'line': line,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/commits/{commit_sha}/comments"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_commit_pulls_by_repo_owner(self, owner: str, repo: str, commit_sha: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of pull requests associated with a specific commit in a GitHub repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            commit_sha (string): commit_sha
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if commit_sha is None:
            raise ValueError("Missing required parameter 'commit_sha'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/commits/{commit_sha}/pulls"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_commit(self, owner: str, repo: str, ref: str, page: Optional[int] = None, per_page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of commits for a specified reference in a GitHub repository using the "GET" method.

        Args:
            owner (string): owner
            repo (string): repo
            ref (string): ref
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if ref is None:
            raise ValueError("Missing required parameter 'ref'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/commits/{ref}"
        query_params = {k: v for k, v in [('page', page), ('per_page', per_page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def checks_list_for_ref(self, owner: str, repo: str, ref: str, check_name: Optional[str] = None, status: Optional[str] = None, filter: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None, app_id: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of check runs for a specific commit in a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            ref (string): ref
            check_name (string): Returns check runs with the specified `name`.
            status (string): Returns check runs with the specified `status`.
            filter (string): Filters check runs by their `completed_at` timestamp. `latest` returns the most recent check runs.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            app_id (integer): The GitHub App ID to filter check runs by, ensuring only those created by the specified app are returned.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            checks
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if ref is None:
            raise ValueError("Missing required parameter 'ref'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/commits/{ref}/check-runs"
        query_params = {k: v for k, v in [('check_name', check_name), ('status', status), ('filter', filter), ('per_page', per_page), ('page', page), ('app_id', app_id)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def checks_list_suites_for_ref(self, owner: str, repo: str, ref: str, app_id: Optional[int] = None, check_name: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of check suites for a specific commit in a GitHub repository, providing summaries of check runs and their statuses.

        Args:
            owner (string): owner
            repo (string): repo
            ref (string): ref
            app_id (integer): Filters check suites by GitHub App `id`. Example: '1'.
            check_name (string): Returns check runs with the specified `name`.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            checks
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if ref is None:
            raise ValueError("Missing required parameter 'ref'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/commits/{ref}/check-suites"
        query_params = {k: v for k, v in [('app_id', app_id), ('check_name', check_name), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_commit_status(self, owner: str, repo: str, ref: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves the individual and combined statuses of checks (e.g., CI results) for a specific commit in a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            ref (string): ref
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if ref is None:
            raise ValueError("Missing required parameter 'ref'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/commits/{ref}/status"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_commit_statuses(self, owner: str, repo: str, ref: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves the commit statuses for a specific reference in a GitHub repository, allowing access to the status states of a commit such as success, failure, or pending.

        Args:
            owner (string): owner
            repo (string): repo
            ref (string): ref
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if ref is None:
            raise ValueError("Missing required parameter 'ref'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/commits/{ref}/statuses"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_community_profile(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Retrieves community profile metrics for a GitHub repository using the GitHub API, providing information such as health score, presence of key files, and detected license.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/community/profile"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_compare_commits(self, owner: str, repo: str, basehead: str, page: Optional[int] = None, per_page: Optional[int] = None) -> dict[str, Any]:
        """
        Compares two commits in a GitHub repository and returns a list of commits between them, allowing users to view changes made in the repository.

        Args:
            owner (string): owner
            repo (string): repo
            basehead (string): basehead
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if basehead is None:
            raise ValueError("Missing required parameter 'basehead'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/compare/{basehead}"
        query_params = {k: v for k, v in [('page', page), ('per_page', per_page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_content(self, owner: str, repo: str, path: str, ref: Optional[str] = None) -> Any:
        """
        Retrieves the contents of a file or directory in a GitHub repository at the specified path, returning the contents in a JSON format.

        Args:
            owner (string): owner
            repo (string): repo
            path (string): path
            ref (string): The name of the commit/branch/tag. Default: the repositorys default branch.

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if path is None:
            raise ValueError("Missing required parameter 'path'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/contents/{path}"
        query_params = {k: v for k, v in [('ref', ref)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def put_repo_content_by_path(self, owner: str, repo: str, path: str, message: str, content: str, sha: Optional[str] = None, branch: Optional[str] = None, committer: Optional[dict[str, Any]] = None, author: Optional[dict[str, Any]] = None) -> dict[str, Any]:
        """
        Creates or updates a file in a GitHub repository at the specified path using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            path (string): path
            message (string): The commit message. Example: 'my commit message'.
            content (string): The new file content, using Base64 encoding. Example: 'bXkgbmV3IGZpbGUgY29udGVudHM='.
            sha (string): **Required if you are updating a file**. The blob SHA of the file being replaced.
            branch (string): The branch name. Default: the repositorys default branch.
            committer (object): The person that committed the file. Default: the authenticated user. Example: {'name': 'Monalisa Octocat', 'email': 'octocat@github.com'}.
            author (object): The author of the file. Default: The `committer` or the authenticated user if you omit `committer`.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if path is None:
            raise ValueError("Missing required parameter 'path'.")
        request_body_data = None
        request_body_data = {
            'message': message,
            'content': content,
            'sha': sha,
            'branch': branch,
            'committer': committer,
            'author': author,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/contents/{path}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_delete_file(self, owner: str, repo: str, path: str, message: str, sha: str, branch: Optional[str] = None, committer: Optional[dict[str, Any]] = None, author: Optional[dict[str, Any]] = None) -> dict[str, Any]:
        """
        Deletes a file in a GitHub repository using the GitHub API, requiring the repository owner, repository name, and file path, and returns a success status upon completion.

        Args:
            owner (string): owner
            repo (string): repo
            path (string): path
            message (string): The commit message. Example: 'my commit message'.
            sha (string): The blob SHA of the file being deleted. Example: '329688480d39049927147c162b9d2deaf885005f'.
            branch (string): The branch name. Default: the repositorys default branch
            committer (object): object containing information about the committer. Example: {'name': 'Monalisa Octocat', 'email': 'octocat@github.com'}.
            author (object): object containing information about the author.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if path is None:
            raise ValueError("Missing required parameter 'path'.")
        request_body_data = {
            'message': message,
            'sha': sha,
            'branch': branch,
            'committer': committer,
            'author': author,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/contents/{path}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_list_contributors(self, owner: str, repo: str, anon: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of contributors for a specified GitHub repository, including commit counts and optional anonymous filtering.

        Args:
            owner (string): owner
            repo (string): repo
            anon (string): Set to `1` or `true` to include anonymous contributors in results.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: If repository contains content

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/contributors"
        query_params = {k: v for k, v in [('anon', anon), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_dependabot_alerts_by_repo(self, owner: str, repo: str, state: Optional[str] = None, severity: Optional[str] = None, ecosystem: Optional[str] = None, package: Optional[str] = None, manifest: Optional[str] = None, epss_percentage: Optional[str] = None, has: Optional[Any] = None, scope: Optional[str] = None, sort: Optional[str] = None, direction: Optional[str] = None, page: Optional[int] = None, per_page: Optional[int] = None, before: Optional[str] = None, after: Optional[str] = None, first: Optional[int] = None, last: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of Dependabot alerts for a specified repository, allowing filtering by state, severity, ecosystem, package, manifest, EPSS, and other criteria, to manage vulnerable dependencies.

        Args:
            owner (string): owner
            repo (string): repo
            state (string): A comma-separated list of states. If specified, only alerts with these states will be returned.

        Can be: `auto_dismissed`, `dismissed`, `fixed`, `open`
            severity (string): A comma-separated list of severities. If specified, only alerts with these severities will be returned.

        Can be: `low`, `medium`, `high`, `critical`
            ecosystem (string): A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.

        Can be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`
            package (string): A comma-separated list of package names. If specified, only alerts for these packages will be returned.
            manifest (string): A comma-separated list of full manifest paths. If specified, only alerts for these manifests will be returned.
            epss_percentage (string): CVE Exploit Prediction Scoring System (EPSS) percentage. Can be specified as:
        - An exact number (`n`)
        - Comparators such as `>n`, `<n`, `>=n`, `<=n`
        - A range like `n..n`, where `n` is a number from 0.0 to 1.0

        Filters the list of alerts based on EPSS percentages. If specified, only alerts with the provided EPSS percentages will be returned.
            has (string): Filters the list of alerts based on whether the alert has the given value. If specified, only alerts meeting this criterion will be returned.
        Multiple `has` filters can be passed to filter for alerts that have all of the values. Currently, only `patch` is supported.
            scope (string): The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.
            sort (string): The property by which to sort the results.
        `created` means when the alert was created.
        `updated` means when the alert's state last changed.
        `epss_percentage` sorts alerts by the Exploit Prediction Scoring System (EPSS) percentage.
            direction (string): The direction to sort the results by.
            page (integer): **Closing down notice**. Page number of the results to fetch. Use cursor-based pagination with `before` or `after` instead.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](
            before (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            after (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            first (integer): **Deprecated**. The number of results per page (max 100), starting from the first matching result.
        This parameter must not be used in combination with `last`.
        Instead, use `per_page` in combination with `after` to fetch the first page of results.
            last (integer): **Deprecated**. The number of results per page (max 100), starting from the last matching result.
        This parameter must not be used in combination with `first`.
        Instead, use `per_page` in combination with `before` to fetch the last page of results.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            dependabot
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/dependabot/alerts"
        query_params = {k: v for k, v in [('state', state), ('severity', severity), ('ecosystem', ecosystem), ('package', package), ('manifest', manifest), ('epss_percentage', epss_percentage), ('has', has), ('scope', scope), ('sort', sort), ('direction', direction), ('page', page), ('per_page', per_page), ('before', before), ('after', after), ('first', first), ('last', last)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def dependabot_get_alert(self, owner: str, repo: str, alert_number: str) -> dict[str, Any]:
        """
        Retrieves a specific Dependabot alert for a GitHub repository using the provided alert number.

        Args:
            owner (string): owner
            repo (string): repo
            alert_number (string): alert_number

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            dependabot
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if alert_number is None:
            raise ValueError("Missing required parameter 'alert_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def dependabot_update_alert(self, owner: str, repo: str, alert_number: str, state: str, dismissed_reason: Optional[str] = None, dismissed_comment: Optional[str] = None) -> dict[str, Any]:
        """
        Updates a specific Dependabot alert for a repository using the GitHub API and returns a status message.

        Args:
            owner (string): owner
            repo (string): repo
            alert_number (string): alert_number
            state (string): The state of the Dependabot alert.
        A `dismissed_reason` must be provided when setting the state to `dismissed`. Example: 'dismissed'.
            dismissed_reason (string): **Required when `state` is `dismissed`.** A reason for dismissing the alert. Example: 'tolerable_risk'.
            dismissed_comment (string): An optional comment associated with dismissing the alert. Example: 'This alert is accurate but we use a sanitizer.'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            dependabot
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if alert_number is None:
            raise ValueError("Missing required parameter 'alert_number'.")
        request_body_data = None
        request_body_data = {
            'state': state,
            'dismissed_reason': dismissed_reason,
            'dismissed_comment': dismissed_comment,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def dependabot_list_repo_secrets(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of Dependabot secrets for a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            dependabot
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/dependabot/secrets"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def dependabot_get_repo_public_key(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Retrieves the public key for a repository, which is required to encrypt secrets used by Dependabot.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            dependabot
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/dependabot/secrets/public-key"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def dependabot_get_repo_secret(self, owner: str, repo: str, secret_name: str) -> dict[str, Any]:
        """
        Retrieves a Dependabot secret's metadata (excluding the encrypted value) for a specified repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            secret_name (string): secret_name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            dependabot
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def put_repo_dependabot_secret(self, owner: str, repo: str, secret_name: str, encrypted_value: Optional[str] = None, key_id: Optional[str] = None) -> dict[str, Any]:
        """
        Creates or updates a Dependabot secret for a specified repository using the GitHub API, allowing storage of sensitive information for accessing private registries.

        Args:
            owner (string): owner
            repo (string): repo
            secret_name (string): secret_name
            encrypted_value (string): Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/dependabot/secrets#get-a-repository-public-key) endpoint. Example: 'c2VjcmV0'.
            key_id (string): ID of the key you used to encrypt the secret. Example: '012345678912345678'.

        Returns:
            dict[str, Any]: Response when creating a secret

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            dependabot
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        request_body_data = None
        request_body_data = {
            'encrypted_value': encrypted_value,
            'key_id': key_id,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def dependabot_delete_repo_secret(self, owner: str, repo: str, secret_name: str) -> Any:
        """
        Deletes a Dependabot secret from a GitHub repository using the secret name.

        Args:
            owner (string): owner
            repo (string): repo
            secret_name (string): secret_name

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            dependabot
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def dependency_graph_diff_range(self, owner: str, repo: str, basehead: str, name: Optional[str] = None) -> list[Any]:
        """
        Compares the dependencies between two commits of a repository, returning a diff of dependency changes, including vulnerability data for any updated versions with known vulnerabilities.

        Args:
            owner (string): owner
            repo (string): repo
            basehead (string): basehead
            name (string): The full path, relative to the repository root, of the dependency manifest file.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            dependency-graph
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if basehead is None:
            raise ValueError("Missing required parameter 'basehead'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/dependency-graph/compare/{basehead}"
        query_params = {k: v for k, v in [('name', name)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def dependency_graph_export_sbom(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Retrieves the Software Bill of Materials (SBOM) for a GitHub repository in SPDX format, listing dependencies from the dependency graph.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            dependency-graph
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/dependency-graph/sbom"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_snapshot(self, owner: str, repo: str, version: int, job: dict[str, Any], sha: str, ref: str, detector: dict[str, Any], scanned: str, metadata: Optional[dict[str, Any]] = None, manifests: Optional[dict[str, dict[str, Any]]] = None) -> dict[str, Any]:
        """
        Creates a new snapshot of a repository's dependencies by submitting them to the GitHub Dependency Graph API, allowing for dependency tracking and security analysis.

        Args:
            owner (string): owner
            repo (string): repo
            version (integer): The version of the repository snapshot submission. Example: 0.
            job (object): job Example: {'correlator': 'yourworkflowname_youractionname', 'id': 'yourrunid'}.
            sha (string): The commit SHA associated with this dependency snapshot. Maximum length: 40 characters. Example: 'ddc951f4b1293222421f2c8df679786153acf689'.
            ref (string): The repository branch that triggered this snapshot. Example: 'refs/heads/main'.
            detector (object): A description of the detector used. Example: {'name': 'octo-detector', 'version': '0.0.1', 'url': 'https://github.com/octo-org/octo-repo'}.
            scanned (string): The time at which the snapshot was scanned. Example: '2020-06-13T14:52:50-05:00'.
            metadata (object): User-defined metadata to store domain-specific information limited to 8 keys with scalar values.
            manifests (object): A collection of package manifests, which are a collection of related dependencies declared in a file or representing a logical group of dependencies. Example: {'package-lock.json': {'name': 'package-lock.json', 'file': {'source_location': 'src/package-lock.json'}, 'resolved': {'@actions/core': {'package_url': 'pkg:/npm/%40actions/core@1.1.9', 'dependencies': ['@actions/http-client']}, '@actions/http-client': {'package_url': 'pkg:/npm/%40actions/http-client@1.0.7', 'dependencies': ['tunnel']}, 'tunnel': {'package_url': 'pkg:/npm/tunnel@0.0.6'}}}}.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            dependency-graph
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'version': version,
            'job': job,
            'sha': sha,
            'ref': ref,
            'detector': detector,
            'metadata': metadata,
            'manifests': manifests,
            'scanned': scanned,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/dependency-graph/snapshots"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_list_deployments(self, owner: str, repo: str, sha: Optional[str] = None, ref: Optional[str] = None, task: Optional[str] = None, environment: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of deployments for a specified GitHub repository, allowing filtering by SHA, reference, task, environment, and pagination parameters.

        Args:
            owner (string): owner
            repo (string): repo
            sha (string): The SHA recorded at creation time.
            ref (string): The name of the ref. This can be a branch, tag, or SHA.
            task (string): The name of the task for the deployment (e.g., `deploy` or `deploy:migrations`).
            environment (string): The name of the environment that was deployed to (e.g., `staging` or `production`).
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/deployments"
        query_params = {k: v for k, v in [('sha', sha), ('ref', ref), ('task', task), ('environment', environment), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_create_deployment(self, owner: str, repo: str, ref: str, task: Optional[str] = None, auto_merge: Optional[bool] = None, required_contexts: Optional[List[str]] = None, payload: Optional[Any] = None, environment: Optional[str] = None, description: Optional[str] = None, transient_environment: Optional[bool] = None, production_environment: Optional[bool] = None) -> dict[str, Any]:
        """
        Creates a new deployment for a specified GitHub repository using the provided parameters, such as the reference and environment, and returns a success status if the operation is successful.

        Args:
            owner (string): owner
            repo (string): repo
            ref (string): The ref to deploy. This can be a branch, tag, or SHA. Example: 'topic-branch'.
            task (string): Specifies a task to execute (e.g., `deploy` or `deploy:migrations`).
            auto_merge (boolean): Attempts to automatically merge the default branch into the requested ref, if it's behind the default branch.
            required_contexts (array): The [status](https://docs.github.com/rest/commits/statuses) contexts to verify against commit status checks. If you omit this parameter, GitHub verifies all unique contexts before creating a deployment. To bypass checking entirely, pass an empty array. Defaults to all unique contexts.
            payload (string): payload Example: '{ "deploy": "migrate" }'.
            environment (string): Name for the target deployment environment (e.g., `production`, `staging`, `qa`).
            description (string): Short description of the deployment. Example: 'Deploy request from hubot'.
            transient_environment (boolean): Specifies if the given environment is specific to the deployment and will no longer exist at some point in the future. Default: `false`
            production_environment (boolean): Specifies if the given environment is one that end-users directly interact with. Default: `true` when `environment` is `production` and `false` otherwise.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'ref': ref,
            'task': task,
            'auto_merge': auto_merge,
            'required_contexts': required_contexts,
            'payload': payload,
            'environment': environment,
            'description': description,
            'transient_environment': transient_environment,
            'production_environment': production_environment,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/deployments"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_deployment(self, owner: str, repo: str, deployment_id: str) -> dict[str, Any]:
        """
        Retrieves information about a specific deployment in a GitHub repository using the provided owner, repository name, and deployment ID.

        Args:
            owner (string): owner
            repo (string): repo
            deployment_id (string): deployment_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if deployment_id is None:
            raise ValueError("Missing required parameter 'deployment_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/deployments/{deployment_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_delete_deployment(self, owner: str, repo: str, deployment_id: str) -> Any:
        """
        Deletes a specific GitHub deployment using the GitHub API and returns status messages for success or error conditions.

        Args:
            owner (string): owner
            repo (string): repo
            deployment_id (string): deployment_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if deployment_id is None:
            raise ValueError("Missing required parameter 'deployment_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/deployments/{deployment_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_list_deployment_statuses(self, owner: str, repo: str, deployment_id: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of deployment statuses for a specific deployment in a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            deployment_id (string): deployment_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if deployment_id is None:
            raise ValueError("Missing required parameter 'deployment_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_create_deployment_status(self, owner: str, repo: str, deployment_id: str, state: str, target_url: Optional[str] = None, log_url: Optional[str] = None, description: Optional[str] = None, environment: Optional[str] = None, environment_url: Optional[str] = None, auto_inactive: Optional[bool] = None) -> dict[str, Any]:
        """
        Creates a deployment status for a specific deployment in a GitHub repository, allowing tracking of deployment progress through states like pending, success, or failure.

        Args:
            owner (string): owner
            repo (string): repo
            deployment_id (string): deployment_id
            state (string): The state of the status. When you set a transient deployment to `inactive`, the deployment will be shown as `destroyed` in GitHub. Example: 'success'.
            target_url (string): The target URL to associate with this status. This URL should contain output to keep the user updated while the task is running or serve as historical information for what happened in the deployment.

        > [!NOTE]
        > It's recommended to use the `log_url` parameter, which replaces `target_url`.
            log_url (string): The full URL of the deployment's output. This parameter replaces `target_url`. We will continue to accept `target_url` to support legacy uses, but we recommend replacing `target_url` with `log_url`. Setting `log_url` will automatically set `target_url` to the same value. Default: `""` Example: 'https://example.com/deployment/42/output'.
            description (string): A short description of the status. The maximum description length is 140 characters. Example: 'Deployment finished successfully.'.
            environment (string): Name for the target deployment environment, which can be changed when setting a deploy status. For example, `production`, `staging`, or `qa`. If not defined, the environment of the previous status on the deployment will be used, if it exists. Otherwise, the environment of the deployment will be used. Example: 'production'.
            environment_url (string): Sets the URL for accessing your environment. Default: `""`
            auto_inactive (boolean): Adds a new `inactive` status to all prior non-transient, non-production environment deployments with the same repository and `environment` name as the created status's deployment. An `inactive` status is only added to deployments that had a `success` state. Default: `true`

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if deployment_id is None:
            raise ValueError("Missing required parameter 'deployment_id'.")
        request_body_data = None
        request_body_data = {
            'state': state,
            'target_url': target_url,
            'log_url': log_url,
            'description': description,
            'environment': environment,
            'environment_url': environment_url,
            'auto_inactive': auto_inactive,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_deployment_status(self, owner: str, repo: str, deployment_id: str, status_id: str) -> dict[str, Any]:
        """
        Retrieves a specific deployment status for a given deployment in a GitHub repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            deployment_id (string): deployment_id
            status_id (string): status_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if deployment_id is None:
            raise ValueError("Missing required parameter 'deployment_id'.")
        if status_id is None:
            raise ValueError("Missing required parameter 'status_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_create_dispatch_event(self, owner: str, repo: str, event_type: str, client_payload: Optional[dict[str, Any]] = None) -> Any:
        """
        Triggers a GitHub Actions workflow by creating a dispatch event for a specified repository.

        Args:
            owner (string): owner
            repo (string): repo
            event_type (string): A custom webhook event name. Must be 100 characters or fewer. Example: 'on-demand-test'.
            client_payload (object): JSON payload with extra information about the webhook event that your action or workflow may use. The maximum number of top-level properties is 10. The total size of the JSON payload must be less than 64KB. Example: {'unit': False, 'integration': True}.

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'event_type': event_type,
            'client_payload': client_payload,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/dispatches"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_all_environments(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of environments for a specified GitHub repository using the "GET" method at the path "/repos/{owner}/{repo}/environments".

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/environments"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_environment(self, owner: str, repo: str, environment_name: str) -> dict[str, Any]:
        """
        Retrieves information about a specific environment for a GitHub repository using the provided owner, repository, and environment name.

        Args:
            owner (string): owner
            repo (string): repo
            environment_name (string): environment_name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if environment_name is None:
            raise ValueError("Missing required parameter 'environment_name'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/environments/{environment_name}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_environment(self, owner: str, repo: str, environment_name: str, wait_timer: Optional[int] = None, prevent_self_review: Optional[bool] = None, reviewers: Optional[List[dict[str, Any]]] = None, deployment_branch_policy: Optional[dict[str, Any]] = None) -> dict[str, Any]:
        """
        Creates or updates a deployment environment configuration for a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            environment_name (string): environment_name
            wait_timer (integer): The amount of time to delay a job after the job is initially triggered. The time (in minutes) must be an integer between 0 and 43,200 (30 days). Example: '30'.
            prevent_self_review (boolean): Whether or not a user who created the job is prevented from approving their own job. Example: 'False'.
            reviewers (array): The people or teams that may review jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed. Example: [{'type': 'User', 'id': 1}, {'type': 'Team', 'id': 1}].
            deployment_branch_policy (object): The type of deployment branch policy for this environment. To allow all branches to deploy, set to `null`. Example: {'protected_branches': False, 'custom_branch_policies': True}.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if environment_name is None:
            raise ValueError("Missing required parameter 'environment_name'.")
        request_body_data = None
        request_body_data = {
            'wait_timer': wait_timer,
            'prevent_self_review': prevent_self_review,
            'reviewers': reviewers,
            'deployment_branch_policy': deployment_branch_policy,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/environments/{environment_name}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_delete_an_environment(self, owner: str, repo: str, environment_name: str) -> Any:
        """
        Deletes a specific deployment environment in a GitHub repository and its associated secrets/protection rules.

        Args:
            owner (string): owner
            repo (string): repo
            environment_name (string): environment_name

        Returns:
            Any: Default response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if environment_name is None:
            raise ValueError("Missing required parameter 'environment_name'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/environments/{environment_name}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_deployment_branch_policies(self, owner: str, repo: str, environment_name: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of deployment branch policies for a specific environment in a GitHub repository, defining which branches can deploy to that environment.

        Args:
            owner (string): owner
            repo (string): repo
            environment_name (string): environment_name
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if environment_name is None:
            raise ValueError("Missing required parameter 'environment_name'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_deployment_policy(self, owner: str, repo: str, environment_name: str, name: str, type: Optional[str] = None) -> dict[str, Any]:
        """
        Creates a deployment branch policy for a specified GitHub environment by defining custom branch name patterns that must be matched for deployment, using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            environment_name (string): environment_name
            name (string): The name pattern that branches or tags must match in order to deploy to the environment.

        Wildcard characters will not match `/`. For example, to match branches that begin with `release/` and contain an additional single slash, use `release/*/*`.
        For more information about pattern matching syntax, see the [Ruby File.fnmatch documentation](https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch). Example: 'release/*'.
            type (string): Whether this rule targets a branch or tag Example: 'branch'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if environment_name is None:
            raise ValueError("Missing required parameter 'environment_name'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'type': type,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_branch_policy(self, owner: str, repo: str, environment_name: str, branch_policy_id: str) -> dict[str, Any]:
        """
        Retrieves a specific deployment branch policy configured for an environment in a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            environment_name (string): environment_name
            branch_policy_id (string): branch_policy_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if environment_name is None:
            raise ValueError("Missing required parameter 'environment_name'.")
        if branch_policy_id is None:
            raise ValueError("Missing required parameter 'branch_policy_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_branch_policy(self, owner: str, repo: str, environment_name: str, branch_policy_id: str, name: str) -> dict[str, Any]:
        """
        Updates a deployment branch policy's name pattern for a specific environment in a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            environment_name (string): environment_name
            branch_policy_id (string): branch_policy_id
            name (string): The name pattern that branches must match in order to deploy to the environment.

        Wildcard characters will not match `/`. For example, to match branches that begin with `release/` and contain an additional single slash, use `release/*/*`.
        For more information about pattern matching syntax, see the [Ruby File.fnmatch documentation](https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch). Example: 'release/*'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if environment_name is None:
            raise ValueError("Missing required parameter 'environment_name'.")
        if branch_policy_id is None:
            raise ValueError("Missing required parameter 'branch_policy_id'.")
        request_body_data = None
        request_body_data = {
            'name': name,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_branch_policy(self, owner: str, repo: str, environment_name: str, branch_policy_id: str) -> Any:
        """
        Deletes a deployment branch policy from a specific environment within a GitHub repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            environment_name (string): environment_name
            branch_policy_id (string): branch_policy_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if environment_name is None:
            raise ValueError("Missing required parameter 'environment_name'.")
        if branch_policy_id is None:
            raise ValueError("Missing required parameter 'branch_policy_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_deployment_rules(self, owner: str, repo: str, environment_name: str) -> dict[str, Any]:
        """
        Retrieves all custom deployment protection rules enabled for a specific environment within a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            environment_name (string): environment_name

        Returns:
            dict[str, Any]: List of deployment protection rules

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if environment_name is None:
            raise ValueError("Missing required parameter 'environment_name'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_deployment_protection_rule(self, owner: str, repo: str, environment_name: str, integration_id: Optional[int] = None) -> dict[str, Any]:
        """
        Creates a custom deployment protection rule on a specified environment within a GitHub repository, allowing the integration of third-party systems to control deployments.

        Args:
            owner (string): owner
            repo (string): repo
            environment_name (string): environment_name
            integration_id (integer): The ID of the custom app that will be enabled on the environment. Example: 5.

        Returns:
            dict[str, Any]: The enabled custom deployment protection rule

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if environment_name is None:
            raise ValueError("Missing required parameter 'environment_name'.")
        request_body_data = None
        request_body_data = {
            'integration_id': integration_id,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_deployment_apps(self, owner: str, repo: str, environment_name: str, page: Optional[int] = None, per_page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves all custom deployment protection rules enabled for a GitHub environment, requiring read access to the repository.

        Args:
            owner (string): owner
            repo (string): repo
            environment_name (string): environment_name
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: A list of custom deployment rule integrations available for this environment.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if environment_name is None:
            raise ValueError("Missing required parameter 'environment_name'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"
        query_params = {k: v for k, v in [('page', page), ('per_page', per_page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_protection_rule(self, owner: str, repo: str, environment_name: str, protection_rule_id: str) -> dict[str, Any]:
        """
        Retrieves a specific custom deployment protection rule enabled on a GitHub repository environment.

        Args:
            owner (string): owner
            repo (string): repo
            environment_name (string): environment_name
            protection_rule_id (string): protection_rule_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if environment_name is None:
            raise ValueError("Missing required parameter 'environment_name'.")
        if protection_rule_id is None:
            raise ValueError("Missing required parameter 'protection_rule_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_protection_rule(self, owner: str, repo: str, environment_name: str, protection_rule_id: str) -> Any:
        """
        Disables a custom deployment protection rule for a specific environment in a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            environment_name (string): environment_name
            protection_rule_id (string): protection_rule_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if environment_name is None:
            raise ValueError("Missing required parameter 'environment_name'.")
        if protection_rule_id is None:
            raise ValueError("Missing required parameter 'protection_rule_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_repo_secrets(self, owner: str, repo: str, environment_name: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of environment secrets for a specific repository environment (excluding secret values).

        Args:
            owner (string): owner
            repo (string): repo
            environment_name (string): environment_name
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if environment_name is None:
            raise ValueError("Missing required parameter 'environment_name'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/environments/{environment_name}/secrets"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_public_key(self, owner: str, repo: str, environment_name: str) -> dict[str, Any]:
        """
        Retrieves the public key required to encrypt secrets for a GitHub repository environment.

        Args:
            owner (string): owner
            repo (string): repo
            environment_name (string): environment_name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if environment_name is None:
            raise ValueError("Missing required parameter 'environment_name'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/environments/{environment_name}/secrets/public-key"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def actions_get_environment_secret(self, owner: str, repo: str, environment_name: str, secret_name: str) -> dict[str, Any]:
        """
        Retrieves details about a specific environment secret in a GitHub repository, such as its name and creation date, without revealing the secret value itself.

        Args:
            owner (string): owner
            repo (string): repo
            environment_name (string): environment_name
            secret_name (string): secret_name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if environment_name is None:
            raise ValueError("Missing required parameter 'environment_name'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_environment_secret_by_name(self, owner: str, repo: str, environment_name: str, secret_name: str, encrypted_value: str, key_id: str) -> dict[str, Any]:
        """
        Creates or updates an environment secret in a GitHub repository using the PUT method, allowing for the secure storage and management of sensitive information within specific environments.

        Args:
            owner (string): owner
            repo (string): repo
            environment_name (string): environment_name
            secret_name (string): secret_name
            encrypted_value (string): Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an environment public key](https://docs.github.com/rest/actions/secrets#get-an-environment-public-key) endpoint. Example: 'c2VjcmV0'.
            key_id (string): ID of the key you used to encrypt the secret. Example: '012345678912345678'.

        Returns:
            dict[str, Any]: Response when creating a secret

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if environment_name is None:
            raise ValueError("Missing required parameter 'environment_name'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        request_body_data = None
        request_body_data = {
            'encrypted_value': encrypted_value,
            'key_id': key_id,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_secret(self, owner: str, repo: str, environment_name: str, secret_name: str) -> Any:
        """
        Deletes a specific environment secret for a GitHub repository using the GitHub API and returns a 204 status upon success.

        Args:
            owner (string): owner
            repo (string): repo
            environment_name (string): environment_name
            secret_name (string): secret_name

        Returns:
            Any: Default response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if environment_name is None:
            raise ValueError("Missing required parameter 'environment_name'.")
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_repo_environment_variables(self, owner: str, repo: str, environment_name: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a paginated list of variables for a specific environment in a GitHub repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            environment_name (string): environment_name
            per_page (integer): The number of results per page (max 30). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if environment_name is None:
            raise ValueError("Missing required parameter 'environment_name'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/environments/{environment_name}/variables"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_environment_variable(self, owner: str, repo: str, environment_name: str, name: str, value: str) -> dict[str, Any]:
        """
        Creates environment variables for a specific environment in a GitHub repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            environment_name (string): environment_name
            name (string): The name of the variable. Example: 'USERNAME'.
            value (string): The value of the variable. Example: 'octocat'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if environment_name is None:
            raise ValueError("Missing required parameter 'environment_name'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'value': value,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/environments/{environment_name}/variables"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_variable_by_name(self, owner: str, repo: str, environment_name: str, name: str) -> dict[str, Any]:
        """
        Retrieves a specific variable from a GitHub repository environment using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            environment_name (string): environment_name
            name (string): name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if environment_name is None:
            raise ValueError("Missing required parameter 'environment_name'.")
        if name is None:
            raise ValueError("Missing required parameter 'name'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_environment_variable(self, owner: str, repo: str, environment_name: str, name: str, name_body: Optional[str] = None, value: Optional[str] = None) -> Any:
        """
        Updates an existing environment variable in a specified environment within a GitHub repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            environment_name (string): environment_name
            name (string): name
            name_body (string): The name of the variable. Example: 'USERNAME'.
            value (string): The value of the variable. Example: 'octocat'.

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if environment_name is None:
            raise ValueError("Missing required parameter 'environment_name'.")
        if name is None:
            raise ValueError("Missing required parameter 'name'.")
        request_body_data = None
        request_body_data = {
            'name': name_body,
            'value': value,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_variable(self, owner: str, repo: str, environment_name: str, name: str) -> Any:
        """
        Deletes a variable associated with a specific environment in a GitHub repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            environment_name (string): environment_name
            name (string): name

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            actions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if environment_name is None:
            raise ValueError("Missing required parameter 'environment_name'.")
        if name is None:
            raise ValueError("Missing required parameter 'name'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def activity_list_repo_events(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of repository events triggered by activity in a specified GitHub repository, including pushes, issues, and other actions.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/events"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_list_forks(self, owner: str, repo: str, sort: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of forks for the specified GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            sort (string): The sort order. `stargazers` will sort by star count.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/forks"
        query_params = {k: v for k, v in [('sort', sort), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_create_fork(self, owner: str, repo: str, organization: Optional[str] = None, name: Optional[str] = None, default_branch_only: Optional[bool] = None) -> dict[str, Any]:
        """
        Creates a fork of a GitHub repository for the authenticated user and returns a 202 Accepted status indicating asynchronous processing.

        Args:
            owner (string): owner
            repo (string): repo
            organization (string): Optional parameter to specify the organization name if forking into an organization. Example: 'octocat'.
            name (string): When forking from an existing repository, a new name for the fork. Example: 'Hello-World'.
            default_branch_only (boolean): When forking from an existing repository, fork with only the default branch. Example: True.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'organization': organization,
            'name': name,
            'default_branch_only': default_branch_only,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/forks"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def git_create_blob(self, owner: str, repo: str, content: str, encoding: Optional[str] = None) -> dict[str, Any]:
        """
        Creates a new Git blob object in a GitHub repository, allowing the storage of file contents, identified by a unique SHA-1 hash, using the GitHub REST API.

        Args:
            owner (string): owner
            repo (string): repo
            content (string): The new blob's content. Example: 'Content of the blob'.
            encoding (string): The encoding used for `content`. Currently, `"utf-8"` and `"base64"` are supported. Example: 'utf-8'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            git
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'content': content,
            'encoding': encoding,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/git/blobs"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def git_get_blob(self, owner: str, repo: str, file_sha: str) -> dict[str, Any]:
        """
        Retrieves a Git blob (binary large object) by its SHA-1 hash, returning either raw binary data or a Base64-encoded content string.

        Args:
            owner (string): owner
            repo (string): repo
            file_sha (string): file_sha

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            git
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if file_sha is None:
            raise ValueError("Missing required parameter 'file_sha'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/git/blobs/{file_sha}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def git_create_commit(self, owner: str, repo: str, message: str, tree: str, parents: Optional[List[str]] = None, author: Optional[dict[str, Any]] = None, committer: Optional[dict[str, Any]] = None, signature: Optional[str] = None) -> dict[str, Any]:
        """
        Creates a new Git commit object in a GitHub repository and returns verification details.

        Args:
            owner (string): owner
            repo (string): repo
            message (string): The commit message Example: 'my commit message'.
            tree (string): The SHA of the tree object this commit points to Example: '827efc6d56897b048c772eb4087f854f46256132'.
            parents (array): The full SHAs of the commits that were the parents of this commit. If omitted or empty, the commit will be written as a root commit. For a single parent, an array of one SHA should be provided; for a merge commit, an array of more than one should be provided. Example: ['7d1b31e74ee336d15cbd21741bc88a537ed063a0'].
            author (object): Information about the author of the commit. By default, the `author` will be the authenticated user and the current date. See the `author` and `committer` object below for details. Example: {'name': 'Mona Octocat', 'email': 'octocat@github.com', 'date': '2008-07-09T16:13:30+12:00'}.
            committer (object): Information about the person who is making the commit. By default, `committer` will use the information set in `author`. See the `author` and `committer` object below for details.
            signature (string): The [PGP signature](https://en.wikipedia.org/wiki/Pretty_Good_Privacy) of the commit. GitHub adds the signature to the `gpgsig` header of the created commit. For a commit signature to be verifiable by Git or GitHub, it must be an ASCII-armored detached PGP signature over the string commit as it would be written to the object database. To pass a `signature` parameter, you need to first manually create a valid PGP signature, which can be complicated. You may find it easier to [use the command line](https://git-scm.com/book/id/v2/Git-Tools-Signing-Your-Work) to create signed commits. Example: '-----BEGIN PGP SIGNATURE-----\n\niQIzBAABAQAdFiEESn/54jMNIrGSE6Tp6cQjvhfv7nAFAlnT71cACgkQ6cQjvhfv\n7nCWwA//XVqBKWO0zF+bZl6pggvky3Oc2j1pNFuRWZ29LXpNuD5WUGXGG209B0hI\nDkmcGk19ZKUTnEUJV2Xd0R7AW01S/YSub7OYcgBkI7qUE13FVHN5ln1KvH2all2n\n2+JCV1HcJLEoTjqIFZSSu/sMdhkLQ9/NsmMAzpf/iIM0nQOyU4YRex9eD1bYj6nA\nOQPIDdAuaTQj1gFPHYLzM4zJnCqGdRlg0sOM/zC5apBNzIwlgREatOYQSCfCKV7k\nnrU34X8b9BzQaUx48Qa+Dmfn5KQ8dl27RNeWAqlkuWyv3pUauH9UeYW+KyuJeMkU\n+NyHgAsWFaCFl23kCHThbLStMZOYEnGagrd0hnm1TPS4GJkV4wfYMwnI4KuSlHKB\njHl3Js9vNzEUQipQJbgCgTiWvRJoK3ENwBTMVkKHaqT4x9U4Jk/XZB6Q8MA09ezJ\n3QgiTjTAGcum9E9QiJqMYdWQPWkaBIRRz5cET6HPB48YNXAAUsfmuYsGrnVLYbG+\nUpC6I97VybYHTy2O9XSGoaLeMI9CsFn38ycAxxbWagk5mhclNTP5mezIq6wKSwmr\nX11FW3n1J23fWZn5HJMBsRnUCgzqzX3871IqLYHqRJ/bpZ4h20RhTyPj5c/z7QXp\neSakNQMfbbMcljkha+ZMuVQX1K9aRlVqbmv3ZMWh+OijLYVU2bc=\n=5Io4\n-----END PGP SIGNATURE-----\n'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            git
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'message': message,
            'tree': tree,
            'parents': parents,
            'author': author,
            'committer': committer,
            'signature': signature,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/git/commits"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def git_get_commit(self, owner: str, repo: str, commit_sha: str) -> dict[str, Any]:
        """
        Retrieves detailed information about a specific commit in a GitHub repository, including metadata and file changes.

        Args:
            owner (string): owner
            repo (string): repo
            commit_sha (string): commit_sha

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            git
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if commit_sha is None:
            raise ValueError("Missing required parameter 'commit_sha'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/git/commits/{commit_sha}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def git_list_matching_refs(self, owner: str, repo: str, ref: str) -> list[Any]:
        """
        Retrieves Git references (branches/tags) matching a specified pattern or all references if no pattern is provided.

        Args:
            owner (string): owner
            repo (string): repo
            ref (string): ref

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            git
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if ref is None:
            raise ValueError("Missing required parameter 'ref'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/git/matching-refs/{ref}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def git_get_ref(self, owner: str, repo: str, ref: str) -> dict[str, Any]:
        """
        Retrieves a specific Git reference from a GitHub repository, allowing access to branches or tags by their names.

        Args:
            owner (string): owner
            repo (string): repo
            ref (string): ref

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            git
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if ref is None:
            raise ValueError("Missing required parameter 'ref'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/git/ref/{ref}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def git_create_ref(self, owner: str, repo: str, ref: str, sha: str) -> dict[str, Any]:
        """
        Creates a new Git reference (branch or tag) in a GitHub repository by specifying the ref name and commit SHA-1 hash.

        Args:
            owner (string): owner
            repo (string): repo
            ref (string): The name of the fully qualified reference (ie: `refs/heads/master`). If it doesn't start with 'refs' and have at least two slashes, it will be rejected. Example: 'refs/heads/featureA'.
            sha (string): The SHA1 value for this reference. Example: 'aa218f56b14c9653891f9e74264a383fa43fefbd'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            git
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'ref': ref,
            'sha': sha,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/git/refs"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def git_update_ref(self, owner: str, repo: str, ref: str, sha: str, force: Optional[bool] = None) -> dict[str, Any]:
        """
        Updates a Git reference (branch or tag) for a GitHub repository, allowing modification of the commit hash it points to.

        Args:
            owner (string): owner
            repo (string): repo
            ref (string): ref
            sha (string): The SHA1 value to set this reference to Example: 'aa218f56b14c9653891f9e74264a383fa43fefbd'.
            force (boolean): Indicates whether to force the update or to make sure the update is a fast-forward update. Leaving this out or setting it to `false` will make sure you're not overwriting work. Example: True.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            git
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if ref is None:
            raise ValueError("Missing required parameter 'ref'.")
        request_body_data = None
        request_body_data = {
            'sha': sha,
            'force': force,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/git/refs/{ref}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def git_delete_ref(self, owner: str, repo: str, ref: str) -> Any:
        """
        Deletes a Git reference from a GitHub repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            ref (string): ref

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            git
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if ref is None:
            raise ValueError("Missing required parameter 'ref'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/git/refs/{ref}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def git_create_tag(self, owner: str, repo: str, tag: str, message: str, object: str, type: str, tagger: Optional[dict[str, Any]] = None) -> dict[str, Any]:
        """
        Creates a tag object in a specified GitHub repository using the Git Tags API, allowing users to create annotated tags that can be used to mark specific commits.

        Args:
            owner (string): owner
            repo (string): repo
            tag (string): The tag's name. This is typically a version (e.g., "v0.0.1"). Example: 'v0.0.1'.
            message (string): The tag message. Example: 'initial version'.
            object (string): The SHA of the git object this is tagging. Example: 'c3d0be41ecbe669545ee3e94d31ed9a4bc91ee3c'.
            type (string): The type of the object we're tagging. Normally this is a `commit` but it can also be a `tree` or a `blob`. Example: 'commit'.
            tagger (object): An object with information about the individual creating the tag. Example: {'name': 'Monalisa Octocat', 'email': 'octocat@github.com', 'date': '2011-06-17T14:53:35-07:00'}.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            git
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'tag': tag,
            'message': message,
            'object': object,
            'type': type,
            'tagger': tagger,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/git/tags"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def git_get_tag(self, owner: str, repo: str, tag_sha: str) -> dict[str, Any]:
        """
        Retrieves a specific Git tag object from a GitHub repository using the tag's SHA.

        Args:
            owner (string): owner
            repo (string): repo
            tag_sha (string): tag_sha

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            git
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if tag_sha is None:
            raise ValueError("Missing required parameter 'tag_sha'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/git/tags/{tag_sha}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def git_create_tree(self, owner: str, repo: str, tree: List[dict[str, Any]], base_tree: Optional[str] = None) -> dict[str, Any]:
        """
        Creates a new Git tree structure in the specified repository, allowing hierarchical file/directory relationships to be defined.

        Args:
            owner (string): owner
            repo (string): repo
            tree (array): Objects (of `path`, `mode`, `type`, and `sha`) specifying a tree structure. Example: [{'path': 'file.rb', 'mode': '100644', 'type': 'blob', 'sha': '44b4fc6d56897b048c772eb4087f854f46256132'}].
            base_tree (string): The SHA1 of an existing Git tree object which will be used as the base for the new tree. If provided, a new Git tree object will be created from entries in the Git tree object pointed to by `base_tree` and entries defined in the `tree` parameter. Entries defined in the `tree` parameter will overwrite items from `base_tree` with the same `path`. If you're creating new changes on a branch, then normally you'd set `base_tree` to the SHA1 of the Git tree object of the current latest commit on the branch you're working on.
        If not provided, GitHub will create a new Git tree object from only the entries defined in the `tree` parameter. If you create a new commit pointing to such a tree, then all files which were a part of the parent commit's tree and were not defined in the `tree` parameter will be listed as deleted by the new commit. Example: '9fb037999f264ba9a7fc6274d15fa3ae2ab98312'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            git
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'tree': tree,
            'base_tree': base_tree,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/git/trees"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def git_get_tree(self, owner: str, repo: str, tree_sha: str, recursive: Optional[str] = None) -> dict[str, Any]:
        """
        Retrieves a Git tree object from a GitHub repository using the provided SHA1 value or ref name, optionally including recursive traversal of subtrees when specified.

        Args:
            owner (string): owner
            repo (string): repo
            tree_sha (string): tree_sha
            recursive (string): Setting this parameter to any value returns the objects or subtrees referenced by the tree specified in `:tree_sha`. For example, setting `recursive` to any of the following will enable returning objects or subtrees: `0`, `1`, `"true"`, and `"false"`. Omit this parameter to prevent recursively returning objects or subtrees.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            git
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if tree_sha is None:
            raise ValueError("Missing required parameter 'tree_sha'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/git/trees/{tree_sha}"
        query_params = {k: v for k, v in [('recursive', recursive)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_list_webhooks(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of webhooks for a GitHub repository using the GitHub API, allowing you to view configurations and event subscriptions for the specified repository.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/hooks"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_create_webhook(self, owner: str, repo: str, name: Optional[str] = None, config: Optional[dict[str, Any]] = None, events: Optional[List[str]] = None, active: Optional[bool] = None) -> dict[str, Any]:
        """
        Creates and configures a webhook for a GitHub repository to receive event notifications.

        Args:
            owner (string): owner
            repo (string): repo
            name (string): Use `web` to create a webhook. Default: `web`. This parameter only accepts the value `web`. Example: 'web'.
            config (object): Key/value pairs to provide settings for this webhook. Example: {'url': 'https://example.com/webhook', 'content_type': 'json', 'insecure_ssl': '0'}.
            events (array): Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for. Example: ['push', 'pull_request'].
            active (boolean): Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications. Example: True.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'config': config,
            'events': events,
            'active': active,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/hooks"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_webhook(self, owner: str, repo: str, hook_id: str) -> dict[str, Any]:
        """
        Retrieves the details of a specific webhook configured for a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            hook_id (string): hook_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if hook_id is None:
            raise ValueError("Missing required parameter 'hook_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/hooks/{hook_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_update_webhook(self, owner: str, repo: str, hook_id: str, config: Optional[dict[str, Any]] = None, events: Optional[List[str]] = None, add_events: Optional[List[str]] = None, remove_events: Optional[List[str]] = None, active: Optional[bool] = None) -> dict[str, Any]:
        """
        Updates a repository webhook configuration using the GitHub API and returns the modified webhook details.

        Args:
            owner (string): owner
            repo (string): repo
            hook_id (string): hook_id
            config (object): Configuration object of the webhook
            events (array): Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for. This replaces the entire array of events.
            add_events (array): Determines a list of events to be added to the list of events that the Hook triggers for. Example: ['pull_request'].
            remove_events (array): Determines a list of events to be removed from the list of events that the Hook triggers for.
            active (boolean): Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications. Example: True.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if hook_id is None:
            raise ValueError("Missing required parameter 'hook_id'.")
        request_body_data = None
        request_body_data = {
            'config': config,
            'events': events,
            'add_events': add_events,
            'remove_events': remove_events,
            'active': active,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/hooks/{hook_id}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_delete_webhook(self, owner: str, repo: str, hook_id: str) -> Any:
        """
        Deletes a specified webhook from a GitHub repository and returns an empty response on success.

        Args:
            owner (string): owner
            repo (string): repo
            hook_id (string): hook_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if hook_id is None:
            raise ValueError("Missing required parameter 'hook_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/hooks/{hook_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_repo_hook_config_by_id(self, owner: str, repo: str, hook_id: str) -> dict[str, Any]:
        """
        Retrieves the configuration details for a specific repository webhook in the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            hook_id (string): hook_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if hook_id is None:
            raise ValueError("Missing required parameter 'hook_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/hooks/{hook_id}/config"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def patch_repo_hook_config(self, owner: str, repo: str, hook_id: str, url: Optional[str] = None, content_type: Optional[str] = None, secret: Optional[str] = None, insecure_ssl: Optional[Any] = None) -> dict[str, Any]:
        """
        Updates the configuration of a specified webhook in a GitHub repository, including settings like the secret and event triggers.

        Args:
            owner (string): owner
            repo (string): repo
            hook_id (string): hook_id
            url (string): The URL to which the payloads will be delivered. Example: 'https://example.com/webhook'.
            content_type (string): The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`. Example: '"json"'.
            secret (string): If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers). Example: '"********"'.
            insecure_ssl (string): insecure_ssl

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if hook_id is None:
            raise ValueError("Missing required parameter 'hook_id'.")
        request_body_data = None
        request_body_data = {
            'url': url,
            'content_type': content_type,
            'secret': secret,
            'insecure_ssl': insecure_ssl,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/hooks/{hook_id}/config"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_list_webhook_deliveries(self, owner: str, repo: str, hook_id: str, per_page: Optional[int] = None, cursor: Optional[str] = None) -> list[Any]:
        """
        Retrieves a paginated list of webhook deliveries for a specific repository webhook using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            hook_id (string): hook_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            cursor (string): Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if hook_id is None:
            raise ValueError("Missing required parameter 'hook_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/hooks/{hook_id}/deliveries"
        query_params = {k: v for k, v in [('per_page', per_page), ('cursor', cursor)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_webhook_delivery(self, owner: str, repo: str, hook_id: str, delivery_id: str) -> dict[str, Any]:
        """
        Retrieves a specific webhook delivery event for a repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            hook_id (string): hook_id
            delivery_id (string): delivery_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if hook_id is None:
            raise ValueError("Missing required parameter 'hook_id'.")
        if delivery_id is None:
            raise ValueError("Missing required parameter 'delivery_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def re_deliver_hook_delivery_attempt(self, owner: str, repo: str, hook_id: str, delivery_id: str) -> dict[str, Any]:
        """
        Retries a failed webhook delivery attempt for a GitHub repository using the specified delivery ID.

        Args:
            owner (string): owner
            repo (string): repo
            hook_id (string): hook_id
            delivery_id (string): delivery_id

        Returns:
            dict[str, Any]: Accepted

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if hook_id is None:
            raise ValueError("Missing required parameter 'hook_id'.")
        if delivery_id is None:
            raise ValueError("Missing required parameter 'delivery_id'.")
        request_body_data = None
        url = f"{self.base_url}/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_ping_webhook(self, owner: str, repo: str, hook_id: str) -> Any:
        """
        Triggers a ping event to test a GitHub repository webhook's connectivity and returns a success status.

        Args:
            owner (string): owner
            repo (string): repo
            hook_id (string): hook_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if hook_id is None:
            raise ValueError("Missing required parameter 'hook_id'.")
        request_body_data = None
        url = f"{self.base_url}/repos/{owner}/{repo}/hooks/{hook_id}/pings"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_test_push_webhook(self, owner: str, repo: str, hook_id: str) -> Any:
        """
        Triggers a test push event for a repository webhook subscribed to push events using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            hook_id (string): hook_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if hook_id is None:
            raise ValueError("Missing required parameter 'hook_id'.")
        request_body_data = None
        url = f"{self.base_url}/repos/{owner}/{repo}/hooks/{hook_id}/tests"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def migrations_get_import_status(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Retrieves the status of a repository import process for a specified GitHub repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            migrations
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/import"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def migrations_start_import(self, owner: str, repo: str, vcs_url: str, vcs: Optional[str] = None, vcs_username: Optional[str] = None, vcs_password: Optional[str] = None, tfvc_project: Optional[str] = None) -> dict[str, Any]:
        """
        Initiates a repository import from another source using the GitHub API, returning appropriate status codes for success or errors.

        Args:
            owner (string): owner
            repo (string): repo
            vcs_url (string): The URL of the originating repository. Example: 'http://svn.mycompany.com/svn/myproject'.
            vcs (string): The originating VCS type. Without this parameter, the import job will take additional time to detect the VCS type before beginning the import. This detection step will be reflected in the response. Example: 'subversion'.
            vcs_username (string): If authentication is required, the username to provide to `vcs_url`. Example: 'octocat'.
            vcs_password (string): If authentication is required, the password to provide to `vcs_url`. Example: 'secret'.
            tfvc_project (string): For a tfvc import, the name of the project that is being imported.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            migrations
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'vcs_url': vcs_url,
            'vcs': vcs,
            'vcs_username': vcs_username,
            'vcs_password': vcs_password,
            'tfvc_project': tfvc_project,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/import"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def migrations_update_import(self, owner: str, repo: str, vcs_username: Optional[str] = None, vcs_password: Optional[str] = None, vcs: Optional[str] = None, tfvc_project: Optional[str] = None) -> dict[str, Any]:
        """
        Updates authentication for a repository import using the GitHub API, allowing adjustments to the import process from another Git repository.

        Args:
            owner (string): owner
            repo (string): repo
            vcs_username (string): The username to provide to the originating repository. Example: 'octocat'.
            vcs_password (string): The password to provide to the originating repository. Example: 'secret'.
            vcs (string): The type of version control system you are migrating from. Example: '"git"'.
            tfvc_project (string): For a tfvc import, the name of the project that is being imported. Example: '"project1"'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            migrations
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'vcs_username': vcs_username,
            'vcs_password': vcs_password,
            'vcs': vcs,
            'tfvc_project': tfvc_project,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/import"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def migrations_cancel_import(self, owner: str, repo: str) -> Any:
        """
        Cancels an ongoing repository import from another Git service using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            migrations
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/import"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def migrations_get_commit_authors(self, owner: str, repo: str, since: Optional[int] = None) -> list[Any]:
        """
        Retrieves commit authors from a repository import, including optional filtering by user ID.

        Args:
            owner (string): owner
            repo (string): repo
            since (integer): A user ID. Only return users with an ID greater than this ID.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            migrations
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/import/authors"
        query_params = {k: v for k, v in [('since', since)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def migrations_map_commit_author(self, owner: str, repo: str, author_id: str, email: Optional[str] = None, name: Optional[str] = None) -> dict[str, Any]:
        """
        Maps a commit author's identity during a repository import, updating author information for imported commits.

        Args:
            owner (string): owner
            repo (string): repo
            author_id (string): author_id
            email (string): The new Git author email. Example: 'hubot@github.com'.
            name (string): The new Git author name. Example: 'Hubot the Robot'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            migrations
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if author_id is None:
            raise ValueError("Missing required parameter 'author_id'.")
        request_body_data = None
        request_body_data = {
            'email': email,
            'name': name,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/import/authors/{author_id}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def migrations_get_large_files(self, owner: str, repo: str) -> list[Any]:
        """
        Retrieves information about importing large files into a GitHub repository using the specified owner and repository names.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            migrations
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/import/large_files"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def migrations_set_lfs_preference(self, owner: str, repo: str, use_lfs: str) -> dict[str, Any]:
        """
        Updates the Git LFS preference for a GitHub repository import, enabling or disabling large file support during the migration process.

        Args:
            owner (string): owner
            repo (string): repo
            use_lfs (string): Whether to store large files during the import. `opt_in` means large files will be stored using Git LFS. `opt_out` means large files will be removed during the import. Example: 'opt_in'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            migrations
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'use_lfs': use_lfs,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/import/lfs"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def apps_get_repo_installation(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Retrieves the installation information for a GitHub App in a specific repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/installation"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_repo_interaction_limits(self, owner: str, repo: str) -> Any:
        """
        Retrieves the current interaction restrictions (commenting, issues, pull requests) for a public GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            interactions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/interaction-limits"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_repo_interaction_limits(self, owner: str, repo: str, limit: str, expiry: Optional[str] = None) -> dict[str, Any]:
        """
        Sets temporary interaction restrictions for a GitHub repository to limit commenting, issue creation, or pull request creation by user type.

        Args:
            owner (string): owner
            repo (string): repo
            limit (string): The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect. Example: 'collaborators_only'.
            expiry (string): The duration of the interaction restriction. Default: `one_day`. Example: 'one_month'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            interactions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'limit': limit,
            'expiry': expiry,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/interaction-limits"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_interaction_limits(self, owner: str, repo: str) -> Any:
        """
        Removes temporary interaction restrictions for a GitHub repository, allowing all users to comment, open issues, or create pull requests.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            interactions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/interaction-limits"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_list_invitations(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of open invitations for collaborators to a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/invitations"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_update_invitation(self, owner: str, repo: str, invitation_id: str, permissions: Optional[str] = None) -> dict[str, Any]:
        """
        Updates a repository invitation using the GitHub API by modifying the specified invitation's details, such as permissions, for a repository owned by a specified user.

        Args:
            owner (string): owner
            repo (string): repo
            invitation_id (string): invitation_id
            permissions (string): The permissions that the associated user will have on the repository. Valid values are `read`, `write`, `maintain`, `triage`, and `admin`. Example: 'write'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if invitation_id is None:
            raise ValueError("Missing required parameter 'invitation_id'.")
        request_body_data = None
        request_body_data = {
            'permissions': permissions,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/invitations/{invitation_id}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_delete_invitation(self, owner: str, repo: str, invitation_id: str) -> Any:
        """
        Deletes a GitHub repository invitation using the GitHub API, removing the specified invitation by its ID from the repository.

        Args:
            owner (string): owner
            repo (string): repo
            invitation_id (string): invitation_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if invitation_id is None:
            raise ValueError("Missing required parameter 'invitation_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/invitations/{invitation_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_list_for_repo(self, owner: str, repo: str, milestone: Optional[str] = None, state: Optional[str] = None, assignee: Optional[str] = None, type: Optional[str] = None, creator: Optional[str] = None, mentioned: Optional[str] = None, labels: Optional[str] = None, sort: Optional[str] = None, direction: Optional[str] = None, since: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of issues from a GitHub repository, allowing filtering by parameters such as milestone, state, assignee, and labels, using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            milestone (string): If an `integer` is passed, it should refer to a milestone by its `number` field. If the string `*` is passed, issues with any milestone are accepted. If the string `none` is passed, issues without milestones are returned.
            state (string): Indicates the state of the issues to return.
            assignee (string): Can be the name of a user. Pass in `none` for issues with no assigned user, and `*` for issues assigned to any user.
            type (string): Can be the name of an issue type. If the string `*` is passed, issues with any type are accepted. If the string `none` is passed, issues without type are returned.
            creator (string): The user that created the issue.
            mentioned (string): A user that's mentioned in the issue.
            labels (string): A list of comma separated label names. Example: `bug,ui,@high`
            sort (string): What to sort results by.
            direction (string): The direction to sort the results by.
            since (string): Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/issues"
        query_params = {k: v for k, v in [('milestone', milestone), ('state', state), ('assignee', assignee), ('type', type), ('creator', creator), ('mentioned', mentioned), ('labels', labels), ('sort', sort), ('direction', direction), ('since', since), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_create(self, owner: str, repo: str, title: Any, body: Optional[str] = None, assignee: Optional[str] = None, milestone: Optional[Any] = None, labels: Optional[List[Any]] = None, assignees: Optional[List[str]] = None, type: Optional[str] = None) -> dict[str, Any]:
        """
        Creates a new issue in a GitHub repository and returns the created issue details.

        Args:
            owner (string): owner
            repo (string): repo
            title (string): The title of the issue. Example: 'Found a bug'.
            body (string): The contents of the issue. Example: "I'm having a problem with this.".
            assignee (string): Login for the user that this issue should be assigned to. _NOTE: Only users with push access can set the assignee for new issues. The assignee is silently dropped otherwise. **This field is closing down.**_
            milestone (string): milestone Example: 1.
            labels (array): Labels to associate with this issue. _NOTE: Only users with push access can set labels for new issues. Labels are silently dropped otherwise._ Example: ['bug'].
            assignees (array): Logins for Users to assign to this issue. _NOTE: Only users with push access can set assignees for new issues. Assignees are silently dropped otherwise._ Example: ['octocat'].
            type (string): The name of the issue type to associate with this issue. _NOTE: Only users with push access can set the type for new issues. The type is silently dropped otherwise._ Example: 'Epic'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'title': title,
            'body': body,
            'assignee': assignee,
            'milestone': milestone,
            'labels': labels,
            'assignees': assignees,
            'type': type,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/issues"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_list_comments_for_repo(self, owner: str, repo: str, sort: Optional[str] = None, direction: Optional[str] = None, since: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves comments from issues and pull requests in a GitHub repository, including formatted body content like raw, text, or HTML.

        Args:
            owner (string): owner
            repo (string): repo
            sort (string): The property to sort the results by.
            direction (string): Either `asc` or `desc`. Ignored without the `sort` parameter.
            since (string): Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/comments"
        query_params = {k: v for k, v in [('sort', sort), ('direction', direction), ('since', since), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_get_comment(self, owner: str, repo: str, comment_id: str) -> dict[str, Any]:
        """
        Retrieves a specific comment on an issue or pull request in a GitHub repository using the "GET" method.

        Args:
            owner (string): owner
            repo (string): repo
            comment_id (string): comment_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if comment_id is None:
            raise ValueError("Missing required parameter 'comment_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/comments/{comment_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_update_comment(self, owner: str, repo: str, comment_id: str, body: str) -> dict[str, Any]:
        """
        Updates an existing issue or pull request comment in a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            comment_id (string): comment_id
            body (string): The contents of the comment. Example: 'Me too'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if comment_id is None:
            raise ValueError("Missing required parameter 'comment_id'.")
        request_body_data = None
        request_body_data = {
            'body': body,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/comments/{comment_id}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_delete_comment(self, owner: str, repo: str, comment_id: str) -> Any:
        """
        Deletes a specific comment on an issue or pull request in a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            comment_id (string): comment_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if comment_id is None:
            raise ValueError("Missing required parameter 'comment_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/comments/{comment_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_reactions_to_comment(self, owner: str, repo: str, comment_id: str, content: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of reactions (e.g., , ) on a specific GitHub issue or pull request comment.

        Args:
            owner (string): owner
            repo (string): repo
            comment_id (string): comment_id
            content (string): Returns a single [reaction type]( Omit this parameter to list all reactions to an issue comment.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            reactions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if comment_id is None:
            raise ValueError("Missing required parameter 'comment_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
        query_params = {k: v for k, v in [('content', content), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def post_issue_comment_reaction(self, owner: str, repo: str, comment_id: str, content: str) -> dict[str, Any]:
        """
        Adds an emoji reaction (e.g., , ) to a GitHub issue comment using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            comment_id (string): comment_id
            content (string): The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the issue comment. Example: 'heart'.

        Returns:
            dict[str, Any]: Reaction exists

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            reactions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if comment_id is None:
            raise ValueError("Missing required parameter 'comment_id'.")
        request_body_data = None
        request_body_data = {
            'content': content,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_comment_reaction_by_id(self, owner: str, repo: str, comment_id: str, reaction_id: str) -> Any:
        """
        Deletes a reaction from a specific comment on a GitHub issue using the "DELETE" method, returning a successful response if the operation is completed without content.

        Args:
            owner (string): owner
            repo (string): repo
            comment_id (string): comment_id
            reaction_id (string): reaction_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            reactions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if comment_id is None:
            raise ValueError("Missing required parameter 'comment_id'.")
        if reaction_id is None:
            raise ValueError("Missing required parameter 'reaction_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_list_events_for_repo(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of events for a specified GitHub issue using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/events"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_get_event(self, owner: str, repo: str, event_id: str) -> dict[str, Any]:
        """
        Retrieves a specific issue event by its ID from a GitHub repository using the "GET" method.

        Args:
            owner (string): owner
            repo (string): repo
            event_id (string): event_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if event_id is None:
            raise ValueError("Missing required parameter 'event_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/events/{event_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_get(self, owner: str, repo: str, issue_number: str) -> dict[str, Any]:
        """
        Retrieves a specific GitHub issue by its number within a repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            issue_number (string): issue_number

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if issue_number is None:
            raise ValueError("Missing required parameter 'issue_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/{issue_number}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_update(self, owner: str, repo: str, issue_number: str, title: Optional[Any] = None, body: Optional[str] = None, assignee: Optional[str] = None, state: Optional[str] = None, state_reason: Optional[str] = None, milestone: Optional[Any] = None, labels: Optional[List[Any]] = None, assignees: Optional[List[str]] = None, type: Optional[str] = None) -> dict[str, Any]:
        """
        Updates an issue in a GitHub repository by modifying its properties, including labels, assignees, and body content.

        Args:
            owner (string): owner
            repo (string): repo
            issue_number (string): issue_number
            title (string): The title of the issue. Example: 'Found a bug'.
            body (string): The contents of the issue. Example: "I'm having a problem with this.".
            assignee (string): Username to assign to this issue. **This field is closing down.**
            state (string): The open or closed state of the issue. Example: 'open'.
            state_reason (string): The reason for the state change. Ignored unless `state` is changed. Example: 'not_planned'.
            milestone (string): milestone Example: 1.
            labels (array): Labels to associate with this issue. Pass one or more labels to _replace_ the set of labels on this issue. Send an empty array (`[]`) to clear all labels from the issue. Only users with push access can set labels for issues. Without push access to the repository, label changes are silently dropped. Example: ['bug'].
            assignees (array): Usernames to assign to this issue. Pass one or more user logins to _replace_ the set of assignees on this issue. Send an empty array (`[]`) to clear all assignees from the issue. Only users with push access can set assignees for new issues. Without push access to the repository, assignee changes are silently dropped. Example: ['octocat'].
            type (string): The name of the issue type to associate with this issue or use `null` to remove the current issue type. Only users with push access can set the type for issues. Without push access to the repository, type changes are silently dropped. Example: 'Epic'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if issue_number is None:
            raise ValueError("Missing required parameter 'issue_number'.")
        request_body_data = None
        request_body_data = {
            'title': title,
            'body': body,
            'assignee': assignee,
            'state': state,
            'state_reason': state_reason,
            'milestone': milestone,
            'labels': labels,
            'assignees': assignees,
            'type': type,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/{issue_number}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_add_assignees(self, owner: str, repo: str, issue_number: str, assignees: Optional[List[str]] = None) -> dict[str, Any]:
        """
        Assigns users to a specified GitHub issue using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            issue_number (string): issue_number
            assignees (array): Usernames of people to assign this issue to. _NOTE: Only users with push access can add assignees to an issue. Assignees are silently ignored otherwise._ Example: ['hubot', 'other_user'].

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if issue_number is None:
            raise ValueError("Missing required parameter 'issue_number'.")
        request_body_data = None
        request_body_data = {
            'assignees': assignees,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/{issue_number}/assignees"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_remove_assignees(self, owner: str, repo: str, issue_number: str, assignees: Optional[List[str]] = None) -> dict[str, Any]:
        """
        Removes assignees from a GitHub issue using the GitHub API by specifying the repository owner, repository name, and issue number, requiring users to have appropriate permissions such as push access.

        Args:
            owner (string): owner
            repo (string): repo
            issue_number (string): issue_number
            assignees (array): Usernames of assignees to remove from an issue. _NOTE: Only users with push access can remove assignees from an issue. Assignees are silently ignored otherwise._ Example: ['hubot', 'other_user'].

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if issue_number is None:
            raise ValueError("Missing required parameter 'issue_number'.")
        request_body_data = {
            'assignees': assignees,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/{issue_number}/assignees"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_assignee_to_issue(self, owner: str, repo: str, issue_number: str, assignee: str) -> Any:
        """
        Checks if a specific assignee is assigned to a GitHub repository issue and returns a 204 status if assigned, or 404 if not found.

        Args:
            owner (string): owner
            repo (string): repo
            issue_number (string): issue_number
            assignee (string): assignee

        Returns:
            Any: Response if `assignee` can be assigned to `issue_number`

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if issue_number is None:
            raise ValueError("Missing required parameter 'issue_number'.")
        if assignee is None:
            raise ValueError("Missing required parameter 'assignee'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_list_comments(self, owner: str, repo: str, issue_number: str, since: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of comments for a specific issue in a GitHub repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            issue_number (string): issue_number
            since (string): Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if issue_number is None:
            raise ValueError("Missing required parameter 'issue_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/{issue_number}/comments"
        query_params = {k: v for k, v in [('since', since), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_create_comment(self, owner: str, repo: str, issue_number: str, body: str) -> dict[str, Any]:
        """
        Creates a comment on a GitHub issue using the GitHub API, returning the created comment in response.

        Args:
            owner (string): owner
            repo (string): repo
            issue_number (string): issue_number
            body (string): The contents of the comment. Example: 'Me too'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if issue_number is None:
            raise ValueError("Missing required parameter 'issue_number'.")
        request_body_data = None
        request_body_data = {
            'body': body,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/{issue_number}/comments"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_list_events(self, owner: str, repo: str, issue_number: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of all events triggered by activity in a specific GitHub issue.

        Args:
            owner (string): owner
            repo (string): repo
            issue_number (string): issue_number
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if issue_number is None:
            raise ValueError("Missing required parameter 'issue_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/{issue_number}/events"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_list_labels_on_issue(self, owner: str, repo: str, issue_number: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of labels associated with a specific GitHub issue, allowing you to view the current labels set for that issue.

        Args:
            owner (string): owner
            repo (string): repo
            issue_number (string): issue_number
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if issue_number is None:
            raise ValueError("Missing required parameter 'issue_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/{issue_number}/labels"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_add_labels(self, owner: str, repo: str, issue_number: str, labels: Optional[List[dict[str, Any]]] = None) -> list[Any]:
        """
        Adds labels to a specified GitHub issue, allowing you to manage categorization of issues by passing the names of the labels to be added.

        Args:
            owner (string): owner
            repo (string): repo
            issue_number (string): issue_number
            labels (array): labels Example: ['bug', 'enhancement'].

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if issue_number is None:
            raise ValueError("Missing required parameter 'issue_number'.")
        request_body_data = None
        request_body_data = {
            'labels': labels,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/{issue_number}/labels"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_set_labels(self, owner: str, repo: str, issue_number: str, labels: Optional[List[dict[str, Any]]] = None) -> list[Any]:
        """
        Replaces all labels for a specific GitHub repository issue with the provided labels.

        Args:
            owner (string): owner
            repo (string): repo
            issue_number (string): issue_number
            labels (array): labels Example: ['bug', 'enhancement'].

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if issue_number is None:
            raise ValueError("Missing required parameter 'issue_number'.")
        request_body_data = None
        request_body_data = {
            'labels': labels,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/{issue_number}/labels"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_remove_all_labels(self, owner: str, repo: str, issue_number: str) -> Any:
        """
        Removes all labels from a specified issue in a GitHub repository using the "DELETE" method.

        Args:
            owner (string): owner
            repo (string): repo
            issue_number (string): issue_number

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if issue_number is None:
            raise ValueError("Missing required parameter 'issue_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/{issue_number}/labels"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_remove_label(self, owner: str, repo: str, issue_number: str, name: str) -> list[Any]:
        """
        Removes a specific label from an issue in a GitHub repository using the "DELETE" method.

        Args:
            owner (string): owner
            repo (string): repo
            issue_number (string): issue_number
            name (string): name

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if issue_number is None:
            raise ValueError("Missing required parameter 'issue_number'.")
        if name is None:
            raise ValueError("Missing required parameter 'name'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_lock(self, owner: str, repo: str, issue_number: str, lock_reason: Optional[str] = None) -> Any:
        """
        Locks an issue in a GitHub repository using the GitHub API, preventing further comments and updates.

        Args:
            owner (string): owner
            repo (string): repo
            issue_number (string): issue_number
            lock_reason (string): The reason for locking the issue or pull request conversation. Lock will fail if you don't use one of these reasons:  
         * `off-topic`  
         * `too heated`  
         * `resolved`  
         * `spam` Example: 'off-topic'.

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if issue_number is None:
            raise ValueError("Missing required parameter 'issue_number'.")
        request_body_data = None
        request_body_data = {
            'lock_reason': lock_reason,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/{issue_number}/lock"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_unlock(self, owner: str, repo: str, issue_number: str) -> Any:
        """
        Unlocks a specified issue in a GitHub repository, allowing comments and interactions.

        Args:
            owner (string): owner
            repo (string): repo
            issue_number (string): issue_number

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if issue_number is None:
            raise ValueError("Missing required parameter 'issue_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/{issue_number}/lock"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def reactions_list_for_issue(self, owner: str, repo: str, issue_number: str, content: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of reactions to a specific GitHub issue using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            issue_number (string): issue_number
            content (string): Returns a single [reaction type]( Omit this parameter to list all reactions to an issue.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            reactions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if issue_number is None:
            raise ValueError("Missing required parameter 'issue_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/{issue_number}/reactions"
        query_params = {k: v for k, v in [('content', content), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def reactions_create_for_issue(self, owner: str, repo: str, issue_number: str, content: str) -> dict[str, Any]:
        """
        Creates a reaction to a GitHub issue using the GitHub API by sending a POST request with the desired reaction type to the specified issue.

        Args:
            owner (string): owner
            repo (string): repo
            issue_number (string): issue_number
            content (string): The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the issue. Example: 'heart'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            reactions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if issue_number is None:
            raise ValueError("Missing required parameter 'issue_number'.")
        request_body_data = None
        request_body_data = {
            'content': content,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/{issue_number}/reactions"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def reactions_delete_for_issue(self, owner: str, repo: str, issue_number: str, reaction_id: str) -> Any:
        """
        Deletes a specific reaction from an issue in a GitHub repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            issue_number (string): issue_number
            reaction_id (string): reaction_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            reactions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if issue_number is None:
            raise ValueError("Missing required parameter 'issue_number'.")
        if reaction_id is None:
            raise ValueError("Missing required parameter 'reaction_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_remove_sub_issue(self, owner: str, repo: str, issue_number: str, sub_issue_id: int) -> dict[str, Any]:
        """
        Removes a sub-issue from an issue in a GitHub repository using the "DELETE" method, requiring the repository owner, repository name, and issue number to identify the target sub-issue.

        Args:
            owner (string): owner
            repo (string): repo
            issue_number (string): issue_number
            sub_issue_id (integer): The id of the sub-issue to remove Example: 6.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if issue_number is None:
            raise ValueError("Missing required parameter 'issue_number'.")
        request_body_data = {
            'sub_issue_id': sub_issue_id,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/{issue_number}/sub_issue"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_list_sub_issues(self, owner: str, repo: str, issue_number: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of sub-issues linked to a specific GitHub repository issue.

        Args:
            owner (string): owner
            repo (string): repo
            issue_number (string): issue_number
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if issue_number is None:
            raise ValueError("Missing required parameter 'issue_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/{issue_number}/sub_issues"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_add_sub_issue(self, owner: str, repo: str, issue_number: str, sub_issue_id: int, replace_parent: Optional[bool] = None) -> dict[str, Any]:
        """
        Adds a sub-issue to a parent issue in a GitHub repository and returns the result.

        Args:
            owner (string): owner
            repo (string): repo
            issue_number (string): issue_number
            sub_issue_id (integer): The id of the sub-issue to add. The sub-issue must belong to the same repository owner as the parent issue Example: 1.
            replace_parent (boolean): Option that, when true, instructs the operation to replace the sub-issues current parent issue

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if issue_number is None:
            raise ValueError("Missing required parameter 'issue_number'.")
        request_body_data = None
        request_body_data = {
            'sub_issue_id': sub_issue_id,
            'replace_parent': replace_parent,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/{issue_number}/sub_issues"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_reprioritize_sub_issue(self, owner: str, repo: str, issue_number: str, sub_issue_id: int, after_id: Optional[int] = None, before_id: Optional[int] = None) -> dict[str, Any]:
        """
        Reprioritizes a sub-issue's position within a parent issue's sub-issue list using specified positional parameters.

        Args:
            owner (string): owner
            repo (string): repo
            issue_number (string): issue_number
            sub_issue_id (integer): The id of the sub-issue to reprioritize Example: 6.
            after_id (integer): The id of the sub-issue to be prioritized after (either positional argument after OR before should be specified). Example: 5.
            before_id (integer): The id of the sub-issue to be prioritized before (either positional argument after OR before should be specified).

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if issue_number is None:
            raise ValueError("Missing required parameter 'issue_number'.")
        request_body_data = None
        request_body_data = {
            'sub_issue_id': sub_issue_id,
            'after_id': after_id,
            'before_id': before_id,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/{issue_number}/sub_issues/priority"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_issue_timeline(self, owner: str, repo: str, issue_number: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of timeline events for a specific GitHub issue using the GitHub API, providing a chronological view of changes and interactions related to the issue.

        Args:
            owner (string): owner
            repo (string): repo
            issue_number (string): issue_number
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if issue_number is None:
            raise ValueError("Missing required parameter 'issue_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/issues/{issue_number}/timeline"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_list_deploy_keys(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of deploy keys configured for a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/keys"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_create_deploy_key(self, owner: str, repo: str, key: str, title: Optional[str] = None, read_only: Optional[bool] = None) -> dict[str, Any]:
        """
        Adds a deploy key to a GitHub repository using the GitHub API, granting access to the repository.

        Args:
            owner (string): owner
            repo (string): repo
            key (string): The contents of the key. Example: 'ssh-rsa AAA...'.
            title (string): A name for the key. Example: 'octocat@octomac'.
            read_only (boolean): If `true`, the key will only be able to read repository contents. Otherwise, the key will be able to read and write.  
  
        Deploy keys with write access can perform the same actions as an organization member with admin access, or a collaborator on a personal repository. For more information, see "[Repository permission levels for an organization](https://docs.github.com/articles/repository-permission-levels-for-an-organization/)" and "[Permission levels for a user account repository](https://docs.github.com/articles/permission-levels-for-a-user-account-repository/)." Example: True.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'title': title,
            'key': key,
            'read_only': read_only,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/keys"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_deploy_key(self, owner: str, repo: str, key_id: str) -> dict[str, Any]:
        """
        Retrieves a specific key from a GitHub repository using its identifier.

        Args:
            owner (string): owner
            repo (string): repo
            key_id (string): key_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if key_id is None:
            raise ValueError("Missing required parameter 'key_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/keys/{key_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_delete_deploy_key(self, owner: str, repo: str, key_id: str) -> Any:
        """
        Removes a specified deploy key from a GitHub repository using the GitHub API, returning a 204 status code upon successful deletion.

        Args:
            owner (string): owner
            repo (string): repo
            key_id (string): key_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if key_id is None:
            raise ValueError("Missing required parameter 'key_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/keys/{key_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_list_labels_for_repo(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of labels for a specified GitHub repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/labels"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_create_label(self, owner: str, repo: str, name: str, color: Optional[str] = None, description: Optional[str] = None) -> dict[str, Any]:
        """
        Creates a new label for a specified GitHub repository, allowing users to categorize issues and pull requests.

        Args:
            owner (string): owner
            repo (string): repo
            name (string): The name of the label. Emoji can be added to label names, using either native emoji or colon-style markup. For example, typing `:strawberry:` will render the emoji ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png ":strawberry:"). For a full list of available emoji and codes, see "[Emoji cheat sheet](https://github.com/ikatyang/emoji-cheat-sheet)." Example: 'bug'.
            color (string): The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`. Example: 'f29513'.
            description (string): A short description of the label. Must be 100 characters or fewer. Example: "Something isn't working".

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'color': color,
            'description': description,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/labels"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_get_label(self, owner: str, repo: str, name: str) -> dict[str, Any]:
        """
        Retrieves a specific label from a GitHub repository by owner, repository name, and label name.

        Args:
            owner (string): owner
            repo (string): repo
            name (string): name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if name is None:
            raise ValueError("Missing required parameter 'name'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/labels/{name}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_update_label(self, owner: str, repo: str, name: str, new_name: Optional[str] = None, color: Optional[str] = None, description: Optional[str] = None) -> dict[str, Any]:
        """
        Updates an existing label in a GitHub repository using the "PATCH" method, allowing modifications to its name, description, or color.

        Args:
            owner (string): owner
            repo (string): repo
            name (string): name
            new_name (string): The new name of the label. Emoji can be added to label names, using either native emoji or colon-style markup. For example, typing `:strawberry:` will render the emoji ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png ":strawberry:"). For a full list of available emoji and codes, see "[Emoji cheat sheet](https://github.com/ikatyang/emoji-cheat-sheet)." Example: 'bug :bug:'.
            color (string): The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`. Example: 'b01f26'.
            description (string): A short description of the label. Must be 100 characters or fewer. Example: 'Small bug fix required'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if name is None:
            raise ValueError("Missing required parameter 'name'.")
        request_body_data = None
        request_body_data = {
            'new_name': new_name,
            'color': color,
            'description': description,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/labels/{name}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_delete_label(self, owner: str, repo: str, name: str) -> Any:
        """
        Deletes a specific label from a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            name (string): name

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if name is None:
            raise ValueError("Missing required parameter 'name'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/labels/{name}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_list_languages(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Retrieves the languages used in a GitHub repository, returning a list of the programming languages and their respective byte sizes.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/languages"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def licenses_get_for_repo(self, owner: str, repo: str, ref: Optional[str] = None) -> dict[str, Any]:
        """
        Retrieves the license file content for a specified GitHub repository and returns license information if detected.

        Args:
            owner (string): owner
            repo (string): repo
            ref (string): The Git reference for the results you want to list. The `ref` for a branch can be formatted either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use `refs/pull/<number>/merge`.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            licenses
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/license"
        query_params = {k: v for k, v in [('ref', ref)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_merge_upstream(self, owner: str, repo: str, branch: str) -> dict[str, Any]:
        """
        Merges changes from an upstream repository branch into a forked repository branch using the POST method, allowing synchronization of branches with existing counterparts in both repositories.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): The name of the branch which should be updated to match upstream. Example: 'main'.

        Returns:
            dict[str, Any]: The branch has been successfully synced with the upstream repository

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'branch': branch,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/merge-upstream"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_merge(self, owner: str, repo: str, base: str, head: str, commit_message: Optional[str] = None) -> dict[str, Any]:
        """
        Merges a base branch with a head branch in a GitHub repository and returns merge status details.

        Args:
            owner (string): owner
            repo (string): repo
            base (string): The name of the base branch that the head will be merged into. Example: 'master'.
            head (string): The head to merge. This can be a branch name or a commit SHA1. Example: 'cool_feature'.
            commit_message (string): Commit message to use for the merge commit. If omitted, a default message will be used. Example: 'Shipped cool_feature!'.

        Returns:
            dict[str, Any]: Successful Response (The resulting merge commit)

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'base': base,
            'head': head,
            'commit_message': commit_message,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/merges"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_list_milestones(self, owner: str, repo: str, state: Optional[str] = None, sort: Optional[str] = None, direction: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of milestones for a specified GitHub repository using the "GET" method.

        Args:
            owner (string): owner
            repo (string): repo
            state (string): The state of the milestone. Either `open`, `closed`, or `all`.
            sort (string): What to sort results by. Either `due_on` or `completeness`.
            direction (string): The direction of the sort. Either `asc` or `desc`.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/milestones"
        query_params = {k: v for k, v in [('state', state), ('sort', sort), ('direction', direction), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_create_milestone(self, owner: str, repo: str, title: str, state: Optional[str] = None, description: Optional[str] = None, due_on: Optional[str] = None) -> dict[str, Any]:
        """
        Creates a new milestone in the specified GitHub repository, tracking progress on issues and pull requests.

        Args:
            owner (string): owner
            repo (string): repo
            title (string): The title of the milestone. Example: 'v1.0'.
            state (string): The state of the milestone. Either `open` or `closed`. Example: 'open'.
            description (string): A description of the milestone. Example: 'Tracking milestone for version 1.0'.
            due_on (string): The milestone due date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Example: '2012-10-09T23:39:01Z'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'title': title,
            'state': state,
            'description': description,
            'due_on': due_on,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/milestones"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_get_milestone(self, owner: str, repo: str, milestone_number: str) -> dict[str, Any]:
        """
        Retrieves information about a specific milestone in a GitHub repository using the given milestone number.

        Args:
            owner (string): owner
            repo (string): repo
            milestone_number (string): milestone_number

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if milestone_number is None:
            raise ValueError("Missing required parameter 'milestone_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/milestones/{milestone_number}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_update_milestone(self, owner: str, repo: str, milestone_number: str, title: Optional[str] = None, state: Optional[str] = None, description: Optional[str] = None, due_on: Optional[str] = None) -> dict[str, Any]:
        """
        Updates a GitHub milestone using the PATCH method at the path "/repos/{owner}/{repo}/milestones/{milestone_number}" to modify its details such as title, state, or description.

        Args:
            owner (string): owner
            repo (string): repo
            milestone_number (string): milestone_number
            title (string): The title of the milestone. Example: 'v1.0'.
            state (string): The state of the milestone. Either `open` or `closed`. Example: 'open'.
            description (string): A description of the milestone. Example: 'Tracking milestone for version 1.0'.
            due_on (string): The milestone due date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Example: '2012-10-09T23:39:01Z'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if milestone_number is None:
            raise ValueError("Missing required parameter 'milestone_number'.")
        request_body_data = None
        request_body_data = {
            'title': title,
            'state': state,
            'description': description,
            'due_on': due_on,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/milestones/{milestone_number}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def issues_delete_milestone(self, owner: str, repo: str, milestone_number: str) -> Any:
        """
        Deletes a specified milestone from a GitHub repository using the API.

        Args:
            owner (string): owner
            repo (string): repo
            milestone_number (string): milestone_number

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if milestone_number is None:
            raise ValueError("Missing required parameter 'milestone_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/milestones/{milestone_number}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_milestone_labels(self, owner: str, repo: str, milestone_number: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves the list of labels for issues associated with a specific GitHub repository milestone.

        Args:
            owner (string): owner
            repo (string): repo
            milestone_number (string): milestone_number
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if milestone_number is None:
            raise ValueError("Missing required parameter 'milestone_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/milestones/{milestone_number}/labels"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_repo_notifications(self, owner: str, repo: str, all: Optional[bool] = None, participating: Optional[bool] = None, since: Optional[str] = None, before: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of notifications for a specific GitHub repository using the "GET" method.

        Args:
            owner (string): owner
            repo (string): repo
            all (boolean): If `true`, show notifications marked as read.
            participating (boolean): If `true`, only shows notifications in which the user is directly participating or mentioned.
            since (string): Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            before (string): Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/notifications"
        query_params = {k: v for k, v in [('all', all), ('participating', participating), ('since', since), ('before', before), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_repo_notifications(self, owner: str, repo: str, last_read_at: Optional[str] = None) -> dict[str, Any]:
        """
        Subscribes to notifications for a GitHub repository and returns a status indicating successful subscription.

        Args:
            owner (string): owner
            repo (string): repo
            last_read_at (string): Describes the last point that notifications were checked. Anything updated since this time will not be marked as read. If you omit this parameter, all notifications are marked as read. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Default: The current timestamp. Example: '2019-01-01T00:00:00Z'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'last_read_at': last_read_at,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/notifications"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_pages(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Retrieves information about a GitHub Pages site associated with the specified repository.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/pages"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_create_pages_site(self, owner: str, repo: str, build_type: Optional[str] = None, source: Optional[dict[str, Any]] = None) -> dict[str, Any]:
        """
        Creates a GitHub Pages deployment for a specified repository using the GitHub API, enabling the hosting of static websites.

        Args:
            owner (string): owner
            repo (string): repo
            build_type (string): The process in which the Page will be built. Possible values are `"legacy"` and `"workflow"`.
            source (object): The source branch and directory used to publish your Pages site. Example: {'branch': 'main', 'path': '/docs'}.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'build_type': build_type,
            'source': source,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/pages"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_repo_pages(self, owner: str, repo: str, cname: Optional[str] = None, https_enforced: Optional[bool] = None, build_type: Optional[str] = None, source: Optional[Any] = None) -> Any:
        """
        Configures GitHub Pages for a repository using the GitHub API, returning a status response after updating the pages configuration.

        Args:
            owner (string): owner
            repo (string): repo
            cname (string): Specify a custom domain for the repository. Sending a `null` value will remove the custom domain. For more about custom domains, see "[Using a custom domain with GitHub Pages](https://docs.github.com/pages/configuring-a-custom-domain-for-your-github-pages-site)." Example: 'octocatblog.com'.
            https_enforced (boolean): Specify whether HTTPS should be enforced for the repository.
            build_type (string): The process by which the GitHub Pages site will be built. `workflow` means that the site is built by a custom GitHub Actions workflow. `legacy` means that the site is built by GitHub when changes are pushed to a specific branch.
            source (string): source Example: {'branch': 'main', 'path': '/'}.

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'cname': cname,
            'https_enforced': https_enforced,
            'build_type': build_type,
            'source': source,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/pages"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_delete_pages_site(self, owner: str, repo: str) -> Any:
        """
        Deletes the GitHub Pages site associated with a repository, requiring repository administrative permissions or specific access rights.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/pages"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_list_pages_builds(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of GitHub Pages build histories for the specified repository.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/pages/builds"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_request_pages_build(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Creates a GitHub Pages build for a specified repository using the GitHub API and returns a successful status upon completion.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        url = f"{self.base_url}/repos/{owner}/{repo}/pages/builds"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_latest_pages_build(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Retrieves information about the latest GitHub Pages build for a specified repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/pages/builds/latest"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_pages_build(self, owner: str, repo: str, build_id: str) -> dict[str, Any]:
        """
        Retrieves a specific GitHub Pages build for a repository using the provided build identifier.

        Args:
            owner (string): owner
            repo (string): repo
            build_id (string): build_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if build_id is None:
            raise ValueError("Missing required parameter 'build_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/pages/builds/{build_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_create_pages_deployment(self, owner: str, repo: str, pages_build_version: str, oidc_token: str, artifact_id: Optional[float] = None, artifact_url: Optional[str] = None, environment: Optional[str] = None) -> dict[str, Any]:
        """
        Deploys a GitHub Pages site for the specified repository and returns status details.

        Args:
            owner (string): owner
            repo (string): repo
            pages_build_version (string): A unique string that represents the version of the build for this deployment. Example: '4fd754f7e594640989b406850d0bc8f06a121251'.
            oidc_token (string): The OIDC token issued by GitHub Actions certifying the origin of the deployment. Example: 'eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6IlV2R1h4SUhlY0JFc1JCdEttemUxUEhfUERiVSIsImtpZCI6IjUyRjE5N0M0ODFERTcwMTEyQzQ0MUI0QTlCMzdCNTNDN0ZDRjBEQjUifQ.eyJqdGkiOiJhMWIwNGNjNy0zNzZiLTQ1N2QtOTMzNS05NTY5YmVjZDExYTIiLCJzdWIiOiJyZXBvOnBhcGVyLXNwYS9taW55aTplbnZpcm9ubWVudDpQcm9kdWN0aW9uIiwiYXVkIjoiaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLXNwYSIsInJlZiI6InJlZnMvaGVhZHMvbWFpbiIsInNoYSI6ImEyODU1MWJmODdiZDk3NTFiMzdiMmM0YjM3M2MxZjU3NjFmYWM2MjYiLCJyZXBvc2l0b3J5IjoicGFwZXItc3BhL21pbnlpIiwicmVwb3NpdG9yeV9vd25lciI6InBhcGVyLXNwYSIsInJ1bl9pZCI6IjE1NDY0NTkzNjQiLCJydW5fbnVtYmVyIjoiMzQiLCJydW5fYXR0ZW1wdCI6IjYiLCJhY3RvciI6IllpTXlzdHkiLCJ3b3JrZmxvdyI6IkNJIiwiaGVhZF9yZWYiOiIiLCJiYXNlX3JlZiI6IiIsImV2ZW50X25hbWUiOiJwdXNoIiwicmVmX3R5cGUiOiJicmFuY2giLCJlbnZpcm9ubWVudCI6IlByb2R1Y3Rpb24iLCJqb2Jfd29ya2Zsb3dfcmVmIjoicGFwZXItc3BhL21pbnlpLy5naXRodWIvd29ya2Zsb3dzL2JsYW5rLnltbEByZWZzL2hlYWRzL21haW4iLCJpc3MiOiJodHRwczovL3Rva2VuLmFjdGlvbnMuZ2l0aHVidXNlcmNvbnRlbnQuY29tIiwibmJmIjoxNjM5MDAwODU2LCJleHAiOjE2MzkwMDE3NTYsImlhdCI6MTYzOTAwMTQ1Nn0.VP8WictbQECKozE2SgvKb2FqJ9hisWsoMkYRTqfBrQfZTCXi5IcFEdgDMB2X7a99C2DeUuTvHh9RMKXLL2a0zg3-Sd7YrO7a2ll2kNlnvyIypcN6AeIc7BxHsTTnZN9Ud_xmEsTrSRGOEKmzCFkULQ6N4zlVD0sidypmXlMemmWEcv_ZHqhioEI_VMp5vwXQurketWH7qX4oDgG4okyYtPrv5RQHbfQcVo9izaPJ_jnsDd0CBA0QOx9InjPidtIkMYQLyUgJy33HLJy86EFNUnAf8UhBQuQi5mAsEpEzBBuKpG3PDiPtYCHOk64JZkZGd5mR888a5sbHRiaF8hm8YA'.
            artifact_id (number): The ID of an artifact that contains the .zip or .tar of static assets to deploy. The artifact belongs to the repository. Either `artifact_id` or `artifact_url` are required.
            artifact_url (string): The URL of an artifact that contains the .zip or .tar of static assets to deploy. The artifact belongs to the repository. Either `artifact_id` or `artifact_url` are required. Example: 'https://downloadcontent/'.
            environment (string): The target environment for this GitHub Pages deployment. Example: 'github-pages'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'artifact_id': artifact_id,
            'artifact_url': artifact_url,
            'environment': environment,
            'pages_build_version': pages_build_version,
            'oidc_token': oidc_token,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/pages/deployments"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_pages_deployment(self, owner: str, repo: str, pages_deployment_id: str) -> dict[str, Any]:
        """
        Retrieves the status of a specific GitHub Pages deployment by its identifier from a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            pages_deployment_id (string): pages_deployment_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if pages_deployment_id is None:
            raise ValueError("Missing required parameter 'pages_deployment_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_cancel_pages_deployment(self, owner: str, repo: str, pages_deployment_id: str) -> Any:
        """
        Cancels a specific GitHub Pages deployment using the GitHub API, requiring write permissions for the repository.

        Args:
            owner (string): owner
            repo (string): repo
            pages_deployment_id (string): pages_deployment_id

        Returns:
            Any: A header with no content is returned.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if pages_deployment_id is None:
            raise ValueError("Missing required parameter 'pages_deployment_id'.")
        request_body_data = None
        url = f"{self.base_url}/repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_pages_health_check(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Performs a health check on the DNS settings for a GitHub Pages site in a specified repository, returning a status indicating whether the configuration is valid.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/pages/health"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_repo_vulnerabilities(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Checks if private vulnerability reporting is enabled for a specified GitHub repository using the GET method.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Private vulnerability reporting status

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/private-vulnerability-reporting"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def enable_private_reporting(self, owner: str, repo: str) -> Any:
        """
        Enables private vulnerability reporting for a GitHub repository using the PUT method at the "/repos/{owner}/{repo}/private-vulnerability-reporting" path, allowing security researchers to privately report vulnerabilities to the repository maintainers.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            Any: A header with no content is returned.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        url = f"{self.base_url}/repos/{owner}/{repo}/private-vulnerability-reporting"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_repo_vulnerability_report(self, owner: str, repo: str) -> Any:
        """
        Disables private vulnerability reporting for a specified GitHub repository using the "DELETE" method, returning a 204 status code upon success.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            Any: A header with no content is returned.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/private-vulnerability-reporting"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def projects_list_for_repo(self, owner: str, repo: str, state: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of projects from a GitHub repository using the "GET" method, allowing filtering by state, page number, and the number of results per page.

        Args:
            owner (string): owner
            repo (string): repo
            state (string): Indicates the state of the projects to return.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            projects
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/projects"
        query_params = {k: v for k, v in [('state', state), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def projects_create_for_repo(self, owner: str, repo: str, name: str, body: Optional[str] = None) -> dict[str, Any]:
        """
        Creates a new project (classic) in the specified GitHub repository and returns the created project.

        Args:
            owner (string): owner
            repo (string): repo
            name (string): The name of the project. Example: 'Projects Documentation'.
            body (string): The description of the project. Example: 'Developer documentation project for the developer site.'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            projects
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'body': body,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/projects"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_repo_properties_values(self, owner: str, repo: str) -> list[Any]:
        """
        Retrieves all custom property values assigned to a GitHub repository by its owning organization.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/properties/values"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_repo_property_values(self, owner: str, repo: str, properties: List[dict[str, Any]]) -> Any:
        """
        Updates or removes custom property values for a GitHub repository and returns a success status upon completion.

        Args:
            owner (string): owner
            repo (string): repo
            properties (array): A list of custom property names and associated values to apply to the repositories. Example: [{'property_name': 'environment', 'value': 'production'}, {'property_name': 'service', 'value': 'web'}, {'property_name': 'team', 'value': 'octocat'}].

        Returns:
            Any: No Content when custom property values are successfully created or updated

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'properties': properties,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/properties/values"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def pulls_list(self, owner: str, repo: str, state: Optional[str] = None, head: Optional[str] = None, base: Optional[str] = None, sort: Optional[str] = None, direction: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of pull requests from a GitHub repository, optionally filtered by state, branch, or sorting criteria.

        Args:
            owner (string): owner
            repo (string): repo
            state (string): Either `open`, `closed`, or `all` to filter by state.
            head (string): Filter pulls by head user or head organization and branch name in the format of `user:ref-name` or `organization:ref-name`. For example: `github:new-script-format` or `octocat:test-branch`.
            base (string): Filter pulls by base branch name. Example: `gh-pages`.
            sort (string): What to sort results by. `popularity` will sort by the number of comments. `long-running` will sort by date created and will limit the results to pull requests that have been open for more than a month and have had activity within the past month.
            direction (string): The direction of the sort. Default: `desc` when sort is `created` or sort is not specified, otherwise `asc`.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls"
        query_params = {k: v for k, v in [('state', state), ('head', head), ('base', base), ('sort', sort), ('direction', direction), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def pulls_create(self, owner: str, repo: str, head: str, base: str, title: Optional[str] = None, head_repo: Optional[str] = None, body: Optional[str] = None, maintainer_can_modify: Optional[bool] = None, draft: Optional[bool] = None, issue: Optional[int] = None) -> dict[str, Any]:
        """
        Creates a new pull request from one branch into another within a specified GitHub repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            head (string): The name of the branch where your changes are implemented. For cross-repository pull requests in the same network, namespace `head` with a user like this: `username:branch`. Example: 'octocat:new-feature'.
            base (string): The name of the branch you want the changes pulled into. This should be an existing branch on the current repository. You cannot submit a pull request to one repository that requests a merge to a base of another repository. Example: 'master'.
            title (string): The title of the new pull request. Required unless `issue` is specified. Example: 'Amazing new feature'.
            head_repo (string): The name of the repository where the changes in the pull request were made. This field is required for cross-repository pull requests if both repositories are owned by the same organization. Example: 'octo-org/octo-repo'.
            body (string): The contents of the pull request. Example: 'Please pull these awesome changes in!'.
            maintainer_can_modify (boolean): Indicates whether [maintainers can modify](https://docs.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/) the pull request.
            draft (boolean): Indicates whether the pull request is a draft. See "[Draft Pull Requests](https://docs.github.com/articles/about-pull-requests#draft-pull-requests)" in the GitHub Help documentation to learn more.
            issue (integer): An issue in the repository to convert to a pull request. The issue title, body, and comments will become the title, body, and comments on the new pull request. Required unless `title` is specified. Example: '1'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'title': title,
            'head': head,
            'head_repo': head_repo,
            'base': base,
            'body': body,
            'maintainer_can_modify': maintainer_can_modify,
            'draft': draft,
            'issue': issue,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_pull_comment(self, owner: str, repo: str, sort: Optional[str] = None, direction: Optional[str] = None, since: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves and lists review comments for all pull requests in a specified repository, sorted in ascending order by default.

        Args:
            owner (string): owner
            repo (string): repo
            sort (string): The "sort" parameter specifies the property to sort the pull request comments by, such as 'created', 'updated', or 'created_at'.
            direction (string): The direction to sort results. Ignored without `sort` parameter.
            since (string): Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/comments"
        query_params = {k: v for k, v in [('sort', sort), ('direction', direction), ('since', since), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def pulls_get_review_comment(self, owner: str, repo: str, comment_id: str) -> dict[str, Any]:
        """
        Retrieves a specific pull request comment by its ID from a GitHub repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            comment_id (string): comment_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if comment_id is None:
            raise ValueError("Missing required parameter 'comment_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/comments/{comment_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def pulls_update_review_comment(self, owner: str, repo: str, comment_id: str, body: str) -> dict[str, Any]:
        """
        Updates a review comment for a pull request in a GitHub repository, allowing users to edit the content of a specified comment.

        Args:
            owner (string): owner
            repo (string): repo
            comment_id (string): comment_id
            body (string): The text of the reply to the review comment. Example: 'I like this too!'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if comment_id is None:
            raise ValueError("Missing required parameter 'comment_id'.")
        request_body_data = None
        request_body_data = {
            'body': body,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/comments/{comment_id}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def pulls_delete_review_comment(self, owner: str, repo: str, comment_id: str) -> Any:
        """
        Deletes a specific pull request review comment from a GitHub repository using the DELETE method, requiring parameters like the repository owner, repository name, and comment ID.

        Args:
            owner (string): owner
            repo (string): repo
            comment_id (string): comment_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if comment_id is None:
            raise ValueError("Missing required parameter 'comment_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/comments/{comment_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_pull_comment_reactions(self, owner: str, repo: str, comment_id: str, content: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of reactions for a specific pull request review comment within a repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            comment_id (string): comment_id
            content (string): Returns a single [reaction type]( Omit this parameter to list all reactions to a pull request review comment.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            reactions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if comment_id is None:
            raise ValueError("Missing required parameter 'comment_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
        query_params = {k: v for k, v in [('content', content), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_pull_comment_reaction(self, owner: str, repo: str, comment_id: str, content: str) -> dict[str, Any]:
        """
        Adds a reaction to a specific pull request review comment using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            comment_id (string): comment_id
            content (string): The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the pull request review comment. Example: 'heart'.

        Returns:
            dict[str, Any]: Reaction exists

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            reactions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if comment_id is None:
            raise ValueError("Missing required parameter 'comment_id'.")
        request_body_data = None
        request_body_data = {
            'content': content,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_reaction_to_comment(self, owner: str, repo: str, comment_id: str, reaction_id: str) -> Any:
        """
        Deletes a reaction from a pull request review comment using the GitHub API and returns a status code indicating success.

        Args:
            owner (string): owner
            repo (string): repo
            comment_id (string): comment_id
            reaction_id (string): reaction_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            reactions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if comment_id is None:
            raise ValueError("Missing required parameter 'comment_id'.")
        if reaction_id is None:
            raise ValueError("Missing required parameter 'reaction_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def pulls_get(self, owner: str, repo: str, pull_number: str) -> dict[str, Any]:
        """
        Retrieves detailed information about a specific pull request from a GitHub repository, including branch information, commit details, and merge status.

        Args:
            owner (string): owner
            repo (string): repo
            pull_number (string): pull_number

        Returns:
            dict[str, Any]: Pass the appropriate [media type](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types) to fetch diff and patch formats.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if pull_number is None:
            raise ValueError("Missing required parameter 'pull_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pull_number}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def pulls_update(self, owner: str, repo: str, pull_number: str, title: Optional[str] = None, body: Optional[str] = None, state: Optional[str] = None, base: Optional[str] = None, maintainer_can_modify: Optional[bool] = None) -> dict[str, Any]:
        """
        Updates a GitHub pull request using the API, modifying its state or details as specified in the request body.

        Args:
            owner (string): owner
            repo (string): repo
            pull_number (string): pull_number
            title (string): The title of the pull request. Example: 'new title'.
            body (string): The contents of the pull request. Example: 'updated body'.
            state (string): State of this Pull Request. Either `open` or `closed`. Example: 'open'.
            base (string): The name of the branch you want your changes pulled into. This should be an existing branch on the current repository. You cannot update the base branch on a pull request to point to another repository. Example: 'master'.
            maintainer_can_modify (boolean): Indicates whether [maintainers can modify](https://docs.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/) the pull request.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if pull_number is None:
            raise ValueError("Missing required parameter 'pull_number'.")
        request_body_data = None
        request_body_data = {
            'title': title,
            'body': body,
            'state': state,
            'base': base,
            'maintainer_can_modify': maintainer_can_modify,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pull_number}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_pull_codespace(self, owner: str, repo: str, pull_number: str, location: Optional[str] = None, geo: Optional[str] = None, client_ip: Optional[str] = None, machine: Optional[str] = None, devcontainer_path: Optional[str] = None, multi_repo_permissions_opt_out: Optional[bool] = None, working_directory: Optional[str] = None, idle_timeout_minutes: Optional[int] = None, display_name: Optional[str] = None, retention_period_minutes: Optional[int] = None) -> dict[str, Any]:
        """
        Creates a codespace for the authenticated user linked to the specified pull request, returning success or retry status codes.

        Args:
            owner (string): owner
            repo (string): repo
            pull_number (string): pull_number
            location (string): The requested location for a new codespace. Best efforts are made to respect this upon creation. Assigned by IP if not provided.
            geo (string): The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is closing down.
            client_ip (string): IP for location auto-detection when proxying a request
            machine (string): Machine type to use for this codespace
            devcontainer_path (string): Path to devcontainer.json config to use for this codespace
            multi_repo_permissions_opt_out (boolean): Whether to authorize requested permissions from devcontainer.json
            working_directory (string): Working directory for this codespace
            idle_timeout_minutes (integer): Time in minutes before codespace stops from inactivity
            display_name (string): Display name for this codespace
            retention_period_minutes (integer): Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).

        Returns:
            dict[str, Any]: Response when the codespace was successfully created

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if pull_number is None:
            raise ValueError("Missing required parameter 'pull_number'.")
        request_body_data = None
        request_body_data = {
            'location': location,
            'geo': geo,
            'client_ip': client_ip,
            'machine': machine,
            'devcontainer_path': devcontainer_path,
            'multi_repo_permissions_opt_out': multi_repo_permissions_opt_out,
            'working_directory': working_directory,
            'idle_timeout_minutes': idle_timeout_minutes,
            'display_name': display_name,
            'retention_period_minutes': retention_period_minutes,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pull_number}/codespaces"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def pulls_list_review_comments(self, owner: str, repo: str, pull_number: str, sort: Optional[str] = None, direction: Optional[str] = None, since: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of comments on a specific pull request in a repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            pull_number (string): pull_number
            sort (string): The property to sort the results by.
            direction (string): The direction to sort results. Ignored without `sort` parameter.
            since (string): Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if pull_number is None:
            raise ValueError("Missing required parameter 'pull_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pull_number}/comments"
        query_params = {k: v for k, v in [('sort', sort), ('direction', direction), ('since', since), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def pulls_create_review_comment(self, owner: str, repo: str, pull_number: str, body: str, commit_id: str, path: str, position: Optional[int] = None, side: Optional[str] = None, line: Optional[int] = None, start_line: Optional[int] = None, start_side: Optional[str] = None, in_reply_to: Optional[int] = None, subject_type: Optional[str] = None) -> dict[str, Any]:
        """
        Creates a review comment on a specific pull request's diff or code section using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            pull_number (string): pull_number
            body (string): The text of the review comment. Example: 'Great stuff!'.
            commit_id (string): The SHA of the commit needing a comment. Not using the latest commit SHA may render your comment outdated if a subsequent commit modifies the line you specify as the `position`. Example: '6dcb09b5b57875f334f61aebed695e2e4193db5e'.
            path (string): The relative path to the file that necessitates a comment. Example: 'file1.txt'.
            position (integer): **This parameter is closing down. Use `line` instead**. The position in the diff where you want to add a review comment. Note this value is not the same as the line number in the file. The position value equals the number of lines down from the first "@@" hunk header in the file you want to add a comment. The line just below the "@@" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.
            side (string): In a split diff view, the side of the diff that the pull request's changes appear on. Can be `LEFT` or `RIGHT`. Use `LEFT` for deletions that appear in red. Use `RIGHT` for additions that appear in green or unchanged lines that appear in white and are shown for context. For a multi-line comment, side represents whether the last line of the comment range is a deletion or addition. For more information, see "[Diff view options](https://docs.github.com/articles/about-comparing-branches-in-pull-requests#diff-view-options)" in the GitHub Help documentation. Example: 'RIGHT'.
            line (integer): **Required unless using `subject_type:file`**. The line of the blob in the pull request diff that the comment applies to. For a multi-line comment, the last line of the range that your comment applies to. Example: 2.
            start_line (integer): **Required when using multi-line comments unless using `in_reply_to`**. The `start_line` is the first line in the pull request diff that your multi-line comment applies to. To learn more about multi-line comments, see "[Commenting on a pull request](https://docs.github.com/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)" in the GitHub Help documentation. Example: 1.
            start_side (string): **Required when using multi-line comments unless using `in_reply_to`**. The `start_side` is the starting side of the diff that the comment applies to. Can be `LEFT` or `RIGHT`. To learn more about multi-line comments, see "[Commenting on a pull request](https://docs.github.com/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)" in the GitHub Help documentation. See `side` in this table for additional context. Example: 'RIGHT'.
            in_reply_to (integer): The ID of the review comment to reply to. To find the ID of a review comment with ["List review comments on a pull request"](#list-review-comments-on-a-pull-request). When specified, all parameters other than `body` in the request body are ignored. Example: '2'.
            subject_type (string): The level at which the comment is targeted.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if pull_number is None:
            raise ValueError("Missing required parameter 'pull_number'.")
        request_body_data = None
        request_body_data = {
            'body': body,
            'commit_id': commit_id,
            'path': path,
            'position': position,
            'side': side,
            'line': line,
            'start_line': start_line,
            'start_side': start_side,
            'in_reply_to': in_reply_to,
            'subject_type': subject_type,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pull_number}/comments"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_pull_comment_reply(self, owner: str, repo: str, pull_number: str, comment_id: str, body: str) -> dict[str, Any]:
        """
        Creates a reply to a specific comment on a GitHub pull request using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            pull_number (string): pull_number
            comment_id (string): comment_id
            body (string): The text of the review comment. Example: 'Great stuff!'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if pull_number is None:
            raise ValueError("Missing required parameter 'pull_number'.")
        if comment_id is None:
            raise ValueError("Missing required parameter 'comment_id'.")
        request_body_data = None
        request_body_data = {
            'body': body,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def pulls_list_commits(self, owner: str, repo: str, pull_number: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of commits associated with a pull request in a specified GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            pull_number (string): pull_number
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if pull_number is None:
            raise ValueError("Missing required parameter 'pull_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pull_number}/commits"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def pulls_list_files(self, owner: str, repo: str, pull_number: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of files modified in a specified GitHub pull request, including pagination parameters.

        Args:
            owner (string): owner
            repo (string): repo
            pull_number (string): pull_number
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if pull_number is None:
            raise ValueError("Missing required parameter 'pull_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pull_number}/files"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def pulls_check_if_merged(self, owner: str, repo: str, pull_number: str) -> Any:
        """
        Retrieves the merge status of a specific GitHub pull request using the API, returning a success status when the pull request can be merged.

        Args:
            owner (string): owner
            repo (string): repo
            pull_number (string): pull_number

        Returns:
            Any: Response if pull request has been merged

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if pull_number is None:
            raise ValueError("Missing required parameter 'pull_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pull_number}/merge"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def pulls_merge(self, owner: str, repo: str, pull_number: str, commit_title: Optional[str] = None, commit_message: Optional[str] = None, sha: Optional[str] = None, merge_method: Optional[str] = None) -> dict[str, Any]:
        """
        Merges a pull request into its base branch using the GitHub API, returning success or error messages based on the merge outcome.

        Args:
            owner (string): owner
            repo (string): repo
            pull_number (string): pull_number
            commit_title (string): Title for the automatic commit message. Example: 'Expand enum'.
            commit_message (string): Extra detail to append to automatic commit message. Example: 'Add a new value to the merge_method enum'.
            sha (string): SHA that pull request head must match to allow merge.
            merge_method (string): The merge method to use.

        Returns:
            dict[str, Any]: if merge was successful

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if pull_number is None:
            raise ValueError("Missing required parameter 'pull_number'.")
        request_body_data = None
        request_body_data = {
            'commit_title': commit_title,
            'commit_message': commit_message,
            'sha': sha,
            'merge_method': merge_method,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pull_number}/merge"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def pulls_list_requested_reviewers(self, owner: str, repo: str, pull_number: str) -> dict[str, Any]:
        """
        Retrieves a list of users or teams who have been requested to review a specified pull request in a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            pull_number (string): pull_number

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if pull_number is None:
            raise ValueError("Missing required parameter 'pull_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def pulls_request_reviewers(self, owner: str, repo: str, pull_number: str, reviewers: Optional[List[str]] = None, team_reviewers: Optional[List[str]] = None) -> dict[str, Any]:
        """
        Requests review from specific users or teams for a GitHub pull request and returns a status message.

        Args:
            owner (string): owner
            repo (string): repo
            pull_number (string): pull_number
            reviewers (array): An array of user `login`s that will be requested. Example: ['octocat', 'hubot', 'other_user'].
            team_reviewers (array): An array of team `slug`s that will be requested. Example: ['justice-league'].

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if pull_number is None:
            raise ValueError("Missing required parameter 'pull_number'.")
        request_body_data = None
        request_body_data = {
            'reviewers': reviewers,
            'team_reviewers': team_reviewers,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_pull_request_reviewers(self, owner: str, repo: str, pull_number: str, reviewers: List[str], team_reviewers: Optional[List[str]] = None) -> dict[str, Any]:
        """
        Removes requested reviewers from a GitHub pull request using the DELETE method at the "/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers" endpoint.

        Args:
            owner (string): owner
            repo (string): repo
            pull_number (string): pull_number
            reviewers (array): An array of user `login`s that will be removed. Example: ['octocat', 'hubot', 'other_user'].
            team_reviewers (array): An array of team `slug`s that will be removed. Example: ['justice-league'].

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if pull_number is None:
            raise ValueError("Missing required parameter 'pull_number'.")
        request_body_data = {
            'reviewers': reviewers,
            'team_reviewers': team_reviewers,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def pulls_list_reviews(self, owner: str, repo: str, pull_number: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a chronological list of all reviews for a specified pull request in the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            pull_number (string): pull_number
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: The list of reviews returns in chronological order.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if pull_number is None:
            raise ValueError("Missing required parameter 'pull_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pull_number}/reviews"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def pulls_create_review(self, owner: str, repo: str, pull_number: str, commit_id: Optional[str] = None, body: Optional[str] = None, event: Optional[str] = None, comments: Optional[List[dict[str, Any]]] = None) -> dict[str, Any]:
        """
        Submits a review for a GitHub pull request with approval, comment, or request changes.

        Args:
            owner (string): owner
            repo (string): repo
            pull_number (string): pull_number
            commit_id (string): The SHA of the commit that needs a review. Not using the latest commit SHA may render your review comment outdated if a subsequent commit modifies the line you specify as the `position`. Defaults to the most recent commit in the pull request when you do not specify a value. Example: 'ecdd80bb57125d7ba9641ffaa4d7d2c19d3f3091'.
            body (string): **Required** when using `REQUEST_CHANGES` or `COMMENT` for the `event` parameter. The body text of the pull request review. Example: 'This is close to perfect! Please address the suggested inline change.'.
            event (string): The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. By leaving this blank, you set the review action state to `PENDING`, which means you will need to [submit the pull request review](https://docs.github.com/rest/pulls/reviews#submit-a-review-for-a-pull-request) when you are ready. Example: 'REQUEST_CHANGES'.
            comments (array): Use the following table to specify the location, destination, and contents of the draft review comment. Example: [{'path': 'file.md', 'position': 6, 'body': 'Please add more information here, and fix this typo.'}].

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if pull_number is None:
            raise ValueError("Missing required parameter 'pull_number'.")
        request_body_data = None
        request_body_data = {
            'commit_id': commit_id,
            'body': body,
            'event': event,
            'comments': comments,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pull_number}/reviews"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def pulls_get_review(self, owner: str, repo: str, pull_number: str, review_id: str) -> dict[str, Any]:
        """
        Retrieves a specific review for a pull request using the GitHub API, returning review details by its ID.

        Args:
            owner (string): owner
            repo (string): repo
            pull_number (string): pull_number
            review_id (string): review_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if pull_number is None:
            raise ValueError("Missing required parameter 'pull_number'.")
        if review_id is None:
            raise ValueError("Missing required parameter 'review_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def pulls_update_review(self, owner: str, repo: str, pull_number: str, review_id: str, body: str) -> dict[str, Any]:
        """
        Updates a specified review for a pull request using the GitHub API, allowing modification of the review summary comment.

        Args:
            owner (string): owner
            repo (string): repo
            pull_number (string): pull_number
            review_id (string): review_id
            body (string): The body text of the pull request review. Example: 'This is close to perfect! Please address the suggested inline change. And add more about this.'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if pull_number is None:
            raise ValueError("Missing required parameter 'pull_number'.")
        if review_id is None:
            raise ValueError("Missing required parameter 'review_id'.")
        request_body_data = None
        request_body_data = {
            'body': body,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def pulls_delete_pending_review(self, owner: str, repo: str, pull_number: str, review_id: str) -> dict[str, Any]:
        """
        Deletes a pending review for a pull request using the GitHub API, returning a status message.

        Args:
            owner (string): owner
            repo (string): repo
            pull_number (string): pull_number
            review_id (string): review_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if pull_number is None:
            raise ValueError("Missing required parameter 'pull_number'.")
        if review_id is None:
            raise ValueError("Missing required parameter 'review_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def pulls_list_comments_for_review(self, owner: str, repo: str, pull_number: str, review_id: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of comments for a specific review on a GitHub pull request, allowing users to access detailed feedback provided during the review process.

        Args:
            owner (string): owner
            repo (string): repo
            pull_number (string): pull_number
            review_id (string): review_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if pull_number is None:
            raise ValueError("Missing required parameter 'pull_number'.")
        if review_id is None:
            raise ValueError("Missing required parameter 'review_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def pulls_dismiss_review(self, owner: str, repo: str, pull_number: str, review_id: str, message: str, event: Optional[str] = None) -> dict[str, Any]:
        """
        Dismisses a specified pull request review and adds a dismissal comment using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            pull_number (string): pull_number
            review_id (string): review_id
            message (string): The message for the pull request review dismissal Example: 'You are dismissed'.
            event (string): event Example: '"DISMISS"'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if pull_number is None:
            raise ValueError("Missing required parameter 'pull_number'.")
        if review_id is None:
            raise ValueError("Missing required parameter 'review_id'.")
        request_body_data = None
        request_body_data = {
            'message': message,
            'event': event,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def pulls_submit_review(self, owner: str, repo: str, pull_number: str, review_id: str, event: str, body: Optional[str] = None) -> dict[str, Any]:
        """
        Submits a review event (approval, request changes, or comment) for a specific pull request review using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            pull_number (string): pull_number
            review_id (string): review_id
            event (string): The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. When you leave this blank, the API returns _HTTP 422 (Unrecognizable entity)_ and sets the review action state to `PENDING`, which means you will need to re-submit the pull request review using a review action. Example: 'REQUEST_CHANGES'.
            body (string): The body text of the pull request review Example: 'Here is the body for the review.'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if pull_number is None:
            raise ValueError("Missing required parameter 'pull_number'.")
        if review_id is None:
            raise ValueError("Missing required parameter 'review_id'.")
        request_body_data = None
        request_body_data = {
            'body': body,
            'event': event,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def pulls_update_branch(self, owner: str, repo: str, pull_number: str, expected_head_sha: Optional[str] = None) -> dict[str, Any]:
        """
        Updates a pull request branch by merging the latest commits from the base branch into the pull request branch using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            pull_number (string): pull_number
            expected_head_sha (string): The expected SHA of the pull request's HEAD ref. This is the most recent commit on the pull request's branch. If the expected SHA does not match the pull request's HEAD, you will receive a `422 Unprocessable Entity` status. You can use the "[List commits](https://docs.github.com/rest/commits/commits#list-commits)" endpoint to find the most recent commit SHA. Default: SHA of the pull request's current HEAD ref. Example: '6dcb09b5b57875f334f61aebed695e2e4193db5e'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            pulls
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if pull_number is None:
            raise ValueError("Missing required parameter 'pull_number'.")
        request_body_data = None
        request_body_data = {
            'expected_head_sha': expected_head_sha,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pull_number}/update-branch"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_readme(self, owner: str, repo: str, ref: Optional[str] = None) -> dict[str, Any]:
        """
        Retrieves the contents of a GitHub repository's README file using the GitHub API and returns its details.

        Args:
            owner (string): owner
            repo (string): repo
            ref (string): The name of the commit/branch/tag. Default: the repositorys default branch.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/readme"
        query_params = {k: v for k, v in [('ref', ref)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_readme_in_directory(self, owner: str, repo: str, dir: str, ref: Optional[str] = None) -> dict[str, Any]:
        """
        Retrieves the README file contents from a specified directory in a GitHub repository using the "GET" method, allowing for optional specification of a branch or commit reference.

        Args:
            owner (string): owner
            repo (string): repo
            dir (string): dir
            ref (string): The name of the commit/branch/tag. Default: the repositorys default branch.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if dir is None:
            raise ValueError("Missing required parameter 'dir'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/readme/{dir}"
        query_params = {k: v for k, v in [('ref', ref)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_list_releases(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of releases from a GitHub repository, including details like tag names, release notes, and associated assets.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/releases"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_create_release(self, owner: str, repo: str, tag_name: str, target_commitish: Optional[str] = None, name: Optional[str] = None, body: Optional[str] = None, draft: Optional[bool] = None, prerelease: Optional[bool] = None, discussion_category_name: Optional[str] = None, generate_release_notes: Optional[bool] = None, make_latest: Optional[str] = None) -> dict[str, Any]:
        """
        Creates a GitHub release for a repository, allowing tag-based versioning with optional release notes and metadata.

        Args:
            owner (string): owner
            repo (string): repo
            tag_name (string): The name of the tag. Example: 'v1.0.0'.
            target_commitish (string): Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch. Example: 'master'.
            name (string): The name of the release. Example: 'v1.0.0'.
            body (string): Text describing the contents of the tag. Example: 'Description of the release'.
            draft (boolean): `true` to create a draft (unpublished) release, `false` to create a published one. Example: False.
            prerelease (boolean): `true` to identify the release as a prerelease. `false` to identify the release as a full release. Example: False.
            discussion_category_name (string): If specified, a discussion of the specified category is created and linked to the release. The value must be a category that already exists in the repository. For more information, see "[Managing categories for discussions in your repository](https://docs.github.com/discussions/managing-discussions-for-your-community/managing-categories-for-discussions-in-your-repository)."
            generate_release_notes (boolean): Whether to automatically generate the name and body for this release. If `name` is specified, the specified name will be used; otherwise, a name will be automatically generated. If `body` is specified, the body will be pre-pended to the automatically generated notes. Example: False.
            make_latest (string): Specifies whether this release should be set as the latest release for the repository. Drafts and prereleases cannot be set as latest. Defaults to `true` for newly published releases. `legacy` specifies that the latest release should be determined based on the release creation date and higher semantic version.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'tag_name': tag_name,
            'target_commitish': target_commitish,
            'name': name,
            'body': body,
            'draft': draft,
            'prerelease': prerelease,
            'discussion_category_name': discussion_category_name,
            'generate_release_notes': generate_release_notes,
            'make_latest': make_latest,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/releases"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_release_asset(self, owner: str, repo: str, asset_id: str) -> dict[str, Any]:
        """
        Retrieves a specific release asset from a GitHub repository using the provided owner, repository name, and asset ID, returning the asset details if found.

        Args:
            owner (string): owner
            repo (string): repo
            asset_id (string): asset_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if asset_id is None:
            raise ValueError("Missing required parameter 'asset_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/releases/assets/{asset_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_update_release_asset(self, owner: str, repo: str, asset_id: str, name: Optional[str] = None, label: Optional[str] = None, state: Optional[str] = None) -> dict[str, Any]:
        """
        Updates a release asset in a GitHub repository using the PATCH method, allowing users with appropriate permissions to modify the asset's details.

        Args:
            owner (string): owner
            repo (string): repo
            asset_id (string): asset_id
            name (string): The file name of the asset. Example: 'foo-1.0.0-osx.zip'.
            label (string): An alternate short description of the asset. Used in place of the filename. Example: 'Mac binary'.
            state (string): state Example: '"uploaded"'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if asset_id is None:
            raise ValueError("Missing required parameter 'asset_id'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'label': label,
            'state': state,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/releases/assets/{asset_id}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_delete_release_asset(self, owner: str, repo: str, asset_id: str) -> Any:
        """
        Deletes a release asset by its ID from a specified GitHub repository using the GitHub API and returns a successful status message upon deletion.

        Args:
            owner (string): owner
            repo (string): repo
            asset_id (string): asset_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if asset_id is None:
            raise ValueError("Missing required parameter 'asset_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/releases/assets/{asset_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_generate_release_notes(self, owner: str, repo: str, tag_name: str, target_commitish: Optional[str] = None, previous_tag_name: Optional[str] = None, configuration_file_path: Optional[str] = None) -> dict[str, Any]:
        """
        Generates release notes content for a GitHub repository using the provided parameters.

        Args:
            owner (string): owner
            repo (string): repo
            tag_name (string): The tag name for the release. This can be an existing tag or a new one. Example: 'v1.0.0'.
            target_commitish (string): Specifies the commitish value that will be the target for the release's tag. Required if the supplied tag_name does not reference an existing tag. Ignored if the tag_name already exists. Example: 'main'.
            previous_tag_name (string): The name of the previous tag to use as the starting point for the release notes. Use to manually specify the range for the set of changes considered as part this release. Example: 'v0.9.2'.
            configuration_file_path (string): Specifies a path to a file in the repository containing configuration settings used for generating the release notes. If unspecified, the configuration file located in the repository at '.github/release.yml' or '.github/release.yaml' will be used. If that is not present, the default configuration will be used. Example: '.github/custom_release_config.yml'.

        Returns:
            dict[str, Any]: Name and body of generated release notes

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'tag_name': tag_name,
            'target_commitish': target_commitish,
            'previous_tag_name': previous_tag_name,
            'configuration_file_path': configuration_file_path,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/releases/generate-notes"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_latest_release(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Retrieves the latest release details for a GitHub repository including tag name, release notes, and associated assets.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/releases/latest"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_release_by_tag(self, owner: str, repo: str, tag: str) -> dict[str, Any]:
        """
        Retrieves a specific release by its associated Git tag from a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            tag (string): tag

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if tag is None:
            raise ValueError("Missing required parameter 'tag'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/releases/tags/{tag}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_release(self, owner: str, repo: str, release_id: str) -> dict[str, Any]:
        """
        Retrieves a specific release from a GitHub repository by release ID, including draft releases for authenticated users with push access.

        Args:
            owner (string): owner
            repo (string): repo
            release_id (string): release_id

        Returns:
            dict[str, Any]: **Note:** This returns an `upload_url` key corresponding to the endpoint for uploading release assets. This key is a hypermedia resource. For more information, see "[Getting started with the REST API](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#hypermedia)."

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if release_id is None:
            raise ValueError("Missing required parameter 'release_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/releases/{release_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_update_release(self, owner: str, repo: str, release_id: str, tag_name: Optional[str] = None, target_commitish: Optional[str] = None, name: Optional[str] = None, body: Optional[str] = None, draft: Optional[bool] = None, prerelease: Optional[bool] = None, make_latest: Optional[str] = None, discussion_category_name: Optional[str] = None) -> dict[str, Any]:
        """
        Edits an existing GitHub release using the specified release ID, allowing updates to release details such as name, description, and status.

        Args:
            owner (string): owner
            repo (string): repo
            release_id (string): release_id
            tag_name (string): The name of the tag. Example: 'v1.0.0'.
            target_commitish (string): Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch. Example: 'master'.
            name (string): The name of the release. Example: 'v1.0.0'.
            body (string): Text describing the contents of the tag. Example: 'Description of the release'.
            draft (boolean): `true` makes the release a draft, and `false` publishes the release. Example: False.
            prerelease (boolean): `true` to identify the release as a prerelease, `false` to identify the release as a full release. Example: False.
            make_latest (string): Specifies whether this release should be set as the latest release for the repository. Drafts and prereleases cannot be set as latest. Defaults to `true` for newly published releases. `legacy` specifies that the latest release should be determined based on the release creation date and higher semantic version.
            discussion_category_name (string): If specified, a discussion of the specified category is created and linked to the release. The value must be a category that already exists in the repository. If there is already a discussion linked to the release, this parameter is ignored. For more information, see "[Managing categories for discussions in your repository](https://docs.github.com/discussions/managing-discussions-for-your-community/managing-categories-for-discussions-in-your-repository)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if release_id is None:
            raise ValueError("Missing required parameter 'release_id'.")
        request_body_data = None
        request_body_data = {
            'tag_name': tag_name,
            'target_commitish': target_commitish,
            'name': name,
            'body': body,
            'draft': draft,
            'prerelease': prerelease,
            'make_latest': make_latest,
            'discussion_category_name': discussion_category_name,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/releases/{release_id}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_delete_release(self, owner: str, repo: str, release_id: str) -> Any:
        """
        Deletes a GitHub release using the GitHub API, returning a status code indicating the success of the operation.

        Args:
            owner (string): owner
            repo (string): repo
            release_id (string): release_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if release_id is None:
            raise ValueError("Missing required parameter 'release_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/releases/{release_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_list_release_assets(self, owner: str, repo: str, release_id: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of release assets for a specific release in a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            release_id (string): release_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if release_id is None:
            raise ValueError("Missing required parameter 'release_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/releases/{release_id}/assets"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_upload_release_asset(self, owner: str, repo: str, release_id: str, name: str, label: Optional[str] = None, body_content: Optional[bytes] = None) -> dict[str, Any]:
        """
        Uploads a release asset to a specified GitHub repository using the POST method, allowing you to add binary files to releases identified by owner, repository, and release ID.

        Args:
            owner (string): owner
            repo (string): repo
            release_id (string): release_id
            name (string): The "name" parameter specifies the file name for the release asset being uploaded.
            label (string): An alternate short description of the asset displayed in place of the filename.
            body_content (bytes | None): Raw binary content for the request body.

        Returns:
            dict[str, Any]: Response for successful upload

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if release_id is None:
            raise ValueError("Missing required parameter 'release_id'.")
        request_body_data = None
        request_body_data = body_content
        url = f"{self.base_url}/repos/{owner}/{repo}/releases/{release_id}/assets"
        query_params = {k: v for k, v in [('name', name), ('label', label)] if v is not None}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/octet-stream')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def reactions_list_for_release(self, owner: str, repo: str, release_id: str, content: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of reactions for a specific release in a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            release_id (string): release_id
            content (string): Returns a single [reaction type]( Omit this parameter to list all reactions to a release.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            reactions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if release_id is None:
            raise ValueError("Missing required parameter 'release_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/releases/{release_id}/reactions"
        query_params = {k: v for k, v in [('content', content), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def reactions_create_for_release(self, owner: str, repo: str, release_id: str, content: str) -> dict[str, Any]:
        """
        Adds a reaction (like , , or ) to a GitHub release and returns the reaction status.

        Args:
            owner (string): owner
            repo (string): repo
            release_id (string): release_id
            content (string): The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the release. Example: 'heart'.

        Returns:
            dict[str, Any]: Reaction exists

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            reactions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if release_id is None:
            raise ValueError("Missing required parameter 'release_id'.")
        request_body_data = None
        request_body_data = {
            'content': content,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/releases/{release_id}/reactions"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def reactions_delete_for_release(self, owner: str, repo: str, release_id: str, reaction_id: str) -> Any:
        """
        Removes a reaction from a GitHub release using the GitHub API and returns a status code indicating success.

        Args:
            owner (string): owner
            repo (string): repo
            release_id (string): release_id
            reaction_id (string): reaction_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            reactions
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if release_id is None:
            raise ValueError("Missing required parameter 'release_id'.")
        if reaction_id is None:
            raise ValueError("Missing required parameter 'reaction_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_branch_rules(self, owner: str, repo: str, branch: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves all active rules applying to a specified branch in a repository, including those configured at repository or organization levels.

        Args:
            owner (string): owner
            repo (string): repo
            branch (string): branch
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if branch is None:
            raise ValueError("Missing required parameter 'branch'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/rules/branches/{branch}"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_repo_rulesets(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None, includes_parents: Optional[bool] = None, targets: Optional[str] = None) -> list[Any]:
        """
        Retrieves a list of rulesets for a specified GitHub repository, allowing control over how users interact with branches and tags, using the "GET" method at the "/repos/{owner}/{repo}/rulesets" path.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            includes_parents (boolean): Include rulesets configured at higher levels that apply to this repository
            targets (string): A comma-separated list of rule targets to filter by.
        If provided, only rulesets that apply to the specified targets will be returned.
        For example, `branch,tag,push`.
         Example: 'branch,tag,push'.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/rulesets"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page), ('includes_parents', includes_parents), ('targets', targets)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_create_repo_ruleset(self, owner: str, repo: str, name: str, enforcement: str, target: Optional[str] = None, bypass_actors: Optional[List[dict[str, Any]]] = None, conditions: Optional[dict[str, Any]] = None, rules: Optional[List[dict[str, Any]]] = None) -> dict[str, Any]:
        """
        Creates a repository ruleset to control branch and tag interaction policies using specified enforcement rules and conditions.

        Args:
            owner (string): owner
            repo (string): repo
            name (string): The name of the ruleset. Example: 'super cool ruleset'.
            enforcement (string): The enforcement level of the ruleset. `evaluate` allows admins to test rules before enforcing them. Admins can view insights on the Rule Insights page (`evaluate` is only available with GitHub Enterprise). Example: 'active'.
            target (string): The target of the ruleset Example: 'branch'.
            bypass_actors (array): The actors that can bypass the rules in this ruleset Example: [{'actor_id': 234, 'actor_type': 'Team', 'bypass_mode': 'always'}].
            conditions (object): Parameters for a repository ruleset ref name condition Example: {'ref_name': {'include': ['refs/heads/main', 'refs/heads/master'], 'exclude': ['refs/heads/dev*']}}.
            rules (array): An array of rules within the ruleset. Example: [{'type': 'commit_author_email_pattern', 'parameters': {'operator': 'contains', 'pattern': 'github'}}].

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'target': target,
            'enforcement': enforcement,
            'bypass_actors': bypass_actors,
            'conditions': conditions,
            'rules': rules,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/rulesets"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_repo_rule_suites(self, owner: str, repo: str, ref: Optional[str] = None, time_period: Optional[str] = None, actor_name: Optional[str] = None, rule_suite_result: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of rule suites for a GitHub repository, which are collections of rule evaluations that enforce specific behaviors or checks, using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            ref (string): The name of the ref. Cannot contain wildcard characters. Optionally prefix with `refs/heads/` to limit to branches or `refs/tags/` to limit to tags. Omit the prefix to search across all refs. When specified, only rule evaluations triggered for this ref will be returned.
            time_period (string): The time period to filter by.

        For example, `day` will filter for rule suites that occurred in the past 24 hours, and `week` will filter for insights that occurred in the past 7 days (168 hours).
            actor_name (string): The handle for the GitHub user account to filter on. When specified, only rule evaluations triggered by this actor will be returned.
            rule_suite_result (string): The rule results to filter on. When specified, only suites with this result will be returned.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/rulesets/rule-suites"
        query_params = {k: v for k, v in [('ref', ref), ('time_period', time_period), ('actor_name', actor_name), ('rule_suite_result', rule_suite_result), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_repo_rule_suite(self, owner: str, repo: str, rule_suite_id: str) -> dict[str, Any]:
        """
        Retrieves a specific rule suite evaluation result for a GitHub repository by ID.

        Args:
            owner (string): owner
            repo (string): repo
            rule_suite_id (string): rule_suite_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if rule_suite_id is None:
            raise ValueError("Missing required parameter 'rule_suite_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_repo_ruleset(self, owner: str, repo: str, ruleset_id: str, includes_parents: Optional[bool] = None) -> dict[str, Any]:
        """
        Retrieves a specific ruleset from a GitHub repository, including parent rulesets if specified, using the repository owner, name, and ruleset identifier.

        Args:
            owner (string): owner
            repo (string): repo
            ruleset_id (string): ruleset_id
            includes_parents (boolean): Include rulesets configured at higher levels that apply to this repository

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if ruleset_id is None:
            raise ValueError("Missing required parameter 'ruleset_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/rulesets/{ruleset_id}"
        query_params = {k: v for k, v in [('includes_parents', includes_parents)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_update_repo_ruleset(self, owner: str, repo: str, ruleset_id: str, name: Optional[str] = None, target: Optional[str] = None, enforcement: Optional[str] = None, bypass_actors: Optional[List[dict[str, Any]]] = None, conditions: Optional[dict[str, Any]] = None, rules: Optional[List[dict[str, Any]]] = None) -> dict[str, Any]:
        """
        Updates a specific ruleset in a GitHub repository using the "PUT" method, allowing for the modification of how interactions are managed for selected branches and tags.

        Args:
            owner (string): owner
            repo (string): repo
            ruleset_id (string): ruleset_id
            name (string): The name of the ruleset. Example: 'super cool ruleset'.
            target (string): The target of the ruleset Example: 'branch'.
            enforcement (string): The enforcement level of the ruleset. `evaluate` allows admins to test rules before enforcing them. Admins can view insights on the Rule Insights page (`evaluate` is only available with GitHub Enterprise). Example: 'active'.
            bypass_actors (array): The actors that can bypass the rules in this ruleset Example: [{'actor_id': 234, 'actor_type': 'Team', 'bypass_mode': 'always'}].
            conditions (object): Parameters for a repository ruleset ref name condition Example: {'ref_name': {'include': ['refs/heads/main', 'refs/heads/master'], 'exclude': ['refs/heads/dev*']}}.
            rules (array): An array of rules within the ruleset. Example: [{'type': 'commit_author_email_pattern', 'parameters': {'operator': 'contains', 'pattern': 'github'}}].

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if ruleset_id is None:
            raise ValueError("Missing required parameter 'ruleset_id'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'target': target,
            'enforcement': enforcement,
            'bypass_actors': bypass_actors,
            'conditions': conditions,
            'rules': rules,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/rulesets/{ruleset_id}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_delete_repo_ruleset(self, owner: str, repo: str, ruleset_id: str) -> Any:
        """
        Deletes a ruleset for a specified GitHub repository using the repository's owner, repository name, and ruleset ID.

        Args:
            owner (string): owner
            repo (string): repo
            ruleset_id (string): ruleset_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if ruleset_id is None:
            raise ValueError("Missing required parameter 'ruleset_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/rulesets/{ruleset_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_repo_ruleset_history(self, owner: str, repo: str, ruleset_id: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves the history of a repository ruleset using the GitHub API, which provides a record of changes made to the ruleset.

        Args:
            owner (string): owner
            repo (string): repo
            ruleset_id (string): ruleset_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if ruleset_id is None:
            raise ValueError("Missing required parameter 'ruleset_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/rulesets/{ruleset_id}/history"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_repo_ruleset_version(self, owner: str, repo: str, ruleset_id: str, version_id: str) -> Any:
        """
        Retrieves a specific historical version of a repository ruleset configuration using its unique ruleset ID and version ID.

        Args:
            owner (string): owner
            repo (string): repo
            ruleset_id (string): ruleset_id
            version_id (string): version_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if ruleset_id is None:
            raise ValueError("Missing required parameter 'ruleset_id'.")
        if version_id is None:
            raise ValueError("Missing required parameter 'version_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_secret_scanning_alerts(self, owner: str, repo: str, state: Optional[str] = None, secret_type: Optional[str] = None, resolution: Optional[str] = None, sort: Optional[str] = None, direction: Optional[str] = None, page: Optional[int] = None, per_page: Optional[int] = None, before: Optional[str] = None, after: Optional[str] = None, validity: Optional[str] = None, is_publicly_leaked: Optional[bool] = None, is_multi_repo: Optional[bool] = None) -> list[Any]:
        """
        Retrieves a list of secret scanning alerts for a specified repository, sorted from newest to oldest.

        Args:
            owner (string): owner
            repo (string): repo
            state (string): Set to `open` or `resolved` to only list secret scanning alerts in a specific state.
            secret_type (string): A comma-separated list of secret types to return. All default secret patterns are returned. To return generic patterns, pass the token name(s) in the parameter. See "[Supported secret scanning patterns](https://docs.github.com/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)" for a complete list of secret types.
            resolution (string): A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.
            sort (string): The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.
            direction (string): The direction to sort the results by.
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            before (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events before this cursor. To receive an initial cursor on your first request, include an empty "before" query string.
            after (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events after this cursor.  To receive an initial cursor on your first request, include an empty "after" query string.
            validity (string): A comma-separated list of validities that, when present, will return alerts that match the validities in this list. Valid options are `active`, `inactive`, and `unknown`.
            is_publicly_leaked (boolean): A boolean value representing whether or not to filter alerts by the publicly-leaked tag being present.
            is_multi_repo (boolean): A boolean value representing whether or not to filter alerts by the multi-repo tag being present.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            secret-scanning
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/secret-scanning/alerts"
        query_params = {k: v for k, v in [('state', state), ('secret_type', secret_type), ('resolution', resolution), ('sort', sort), ('direction', direction), ('page', page), ('per_page', per_page), ('before', before), ('after', after), ('validity', validity), ('is_publicly_leaked', is_publicly_leaked), ('is_multi_repo', is_multi_repo)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def secret_scanning_get_alert(self, owner: str, repo: str, alert_number: str) -> dict[str, Any]:
        """
        Retrieves details of a specific secret scanning alert detected in a GitHub repository using the provided alert number.

        Args:
            owner (string): owner
            repo (string): repo
            alert_number (string): alert_number

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            secret-scanning
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if alert_number is None:
            raise ValueError("Missing required parameter 'alert_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def secret_scanning_update_alert(self, owner: str, repo: str, alert_number: str, state: str, resolution: Optional[str] = None, resolution_comment: Optional[str] = None) -> dict[str, Any]:
        """
        Updates a secret scanning alert in a GitHub repository using the "PATCH" method, allowing actions such as dismissing or modifying the alert's status.

        Args:
            owner (string): owner
            repo (string): repo
            alert_number (string): alert_number
            state (string): Sets the state of the secret scanning alert. You must provide `resolution` when you set the state to `resolved`. Example: 'resolved'.
            resolution (string): **Required when the `state` is `resolved`.** The reason for resolving the alert. Example: 'false_positive'.
            resolution_comment (string): An optional comment when closing or reopening an alert. Cannot be updated or deleted.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            secret-scanning
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if alert_number is None:
            raise ValueError("Missing required parameter 'alert_number'.")
        request_body_data = None
        request_body_data = {
            'state': state,
            'resolution': resolution,
            'resolution_comment': resolution_comment,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_secret_locations(self, owner: str, repo: str, alert_number: str, page: Optional[int] = None, per_page: Optional[int] = None) -> list[Any]:
        """
        Retrieves the locations of a specific secret scanning alert within a GitHub repository using the provided alert number.

        Args:
            owner (string): owner
            repo (string): repo
            alert_number (string): alert_number
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            secret-scanning
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if alert_number is None:
            raise ValueError("Missing required parameter 'alert_number'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"
        query_params = {k: v for k, v in [('page', page), ('per_page', per_page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def bypass_push_protection(self, owner: str, repo: str, reason: str, placeholder_id: str) -> dict[str, Any]:
        """
        Submits a request to bypass secret scanning push protection for a repository via the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            reason (string): The reason for bypassing push protection. Example: 'will_fix_later'.
            placeholder_id (string): The ID of the push protection bypass placeholder. This value is returned on any push protected routes. Example: '2k4dM4tseyC5lPIsjl5emX9sPNk'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            secret-scanning
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'reason': reason,
            'placeholder_id': placeholder_id,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/secret-scanning/push-protection-bypasses"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_repo_secret_scanning_history(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Retrieves a repository's secret scanning scan history using the GitHub API, providing visibility into when different types of secrets were scanned.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            secret-scanning
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/secret-scanning/scan-history"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_security_advisories(self, owner: str, repo: str, direction: Optional[str] = None, sort: Optional[str] = None, before: Optional[str] = None, after: Optional[str] = None, per_page: Optional[int] = None, state: Optional[str] = None) -> list[Any]:
        """
        Retrieves a list of security advisories for a specified GitHub repository using the "GET" method, allowing users to manage and view vulnerabilities associated with the repository.

        Args:
            owner (string): owner
            repo (string): repo
            direction (string): The direction to sort the results by.
            sort (string): The property to sort the results by.
            before (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            after (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of advisories to return per page. For more information, see "[Using pagination in the REST API](
            state (string): Filter by state of the repository advisories. Only advisories of this state will be returned.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            security-advisories
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/security-advisories"
        query_params = {k: v for k, v in [('direction', direction), ('sort', sort), ('before', before), ('after', after), ('per_page', per_page), ('state', state)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_security_advisory(self, owner: str, repo: str, summary: str, description: str, vulnerabilities: List[dict[str, Any]], cve_id: Optional[str] = None, cwe_ids: Optional[List[str]] = None, credits: Optional[List[dict[str, Any]]] = None, severity: Optional[str] = None, cvss_vector_string: Optional[str] = None, start_private_fork: Optional[bool] = None) -> dict[str, Any]:
        """
        Creates a repository security advisory to report vulnerabilities and track security issues in a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            summary (string): A short summary of the advisory. Example: 'A new important advisory'.
            description (string): A detailed description of what the advisory impacts. Example: 'A more in-depth description of what the problem is.'.
            vulnerabilities (array): A product affected by the vulnerability detailed in a repository security advisory. Example: [{'package': {'name': 'a-package', 'ecosystem': 'npm'}, 'vulnerable_version_range': '< 1.0.0', 'patched_versions': '1.0.0', 'vulnerable_functions': ['important_function']}].
            cve_id (string): The Common Vulnerabilities and Exposures (CVE) ID.
            cwe_ids (array): A list of Common Weakness Enumeration (CWE) IDs. Example: ['CWE-1101', 'CWE-20'].
            credits (array): A list of users receiving credit for their participation in the security advisory. Example: [{'login': 'monalisa', 'type': 'reporter'}, {'login': 'octocat', 'type': 'analyst'}].
            severity (string): The severity of the advisory. You must choose between setting this field or `cvss_vector_string`. Example: 'high'.
            cvss_vector_string (string): The CVSS vector that calculates the severity of the advisory. You must choose between setting this field or `severity`.
            start_private_fork (boolean): Whether to create a temporary private fork of the repository to collaborate on a fix.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            security-advisories
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'summary': summary,
            'description': description,
            'cve_id': cve_id,
            'vulnerabilities': vulnerabilities,
            'cwe_ids': cwe_ids,
            'credits': credits,
            'severity': severity,
            'cvss_vector_string': cvss_vector_string,
            'start_private_fork': start_private_fork,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/security-advisories"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_security_advisory_report(self, owner: str, repo: str, summary: str, description: str, vulnerabilities: Optional[List[dict[str, Any]]] = None, cwe_ids: Optional[List[str]] = None, severity: Optional[str] = None, cvss_vector_string: Optional[str] = None, start_private_fork: Optional[bool] = None) -> dict[str, Any]:
        """
        Creates a new repository security advisory report for a specified GitHub repository to track and manage security vulnerabilities.

        Args:
            owner (string): owner
            repo (string): repo
            summary (string): A short summary of the advisory. Example: 'A newly discovered vulnerability'.
            description (string): A detailed description of what the advisory impacts. Example: 'A more in-depth description of what the problem is.'.
            vulnerabilities (array): An array of products affected by the vulnerability detailed in a repository security advisory. Example: [{'package': {'name': 'a-package', 'ecosystem': 'npm'}, 'vulnerable_version_range': '< 1.0.0', 'patched_versions': '1.0.0', 'vulnerable_functions': ['important_function']}].
            cwe_ids (array): A list of Common Weakness Enumeration (CWE) IDs. Example: ['CWE-123'].
            severity (string): The severity of the advisory. You must choose between setting this field or `cvss_vector_string`. Example: 'high'.
            cvss_vector_string (string): The CVSS vector that calculates the severity of the advisory. You must choose between setting this field or `severity`.
            start_private_fork (boolean): Whether to create a temporary private fork of the repository to collaborate on a fix.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            security-advisories
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'summary': summary,
            'description': description,
            'vulnerabilities': vulnerabilities,
            'cwe_ids': cwe_ids,
            'severity': severity,
            'cvss_vector_string': cvss_vector_string,
            'start_private_fork': start_private_fork,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/security-advisories/reports"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_security_advisory_by_id(self, owner: str, repo: str, ghsa_id: str) -> dict[str, Any]:
        """
        Retrieves a specific repository security advisory identified by its GitHub Security Advisory (GHSA) ID, including details like summary, description, and associated CVE.

        Args:
            owner (string): owner
            repo (string): repo
            ghsa_id (string): ghsa_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            security-advisories
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if ghsa_id is None:
            raise ValueError("Missing required parameter 'ghsa_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/security-advisories/{ghsa_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_security_advisory(self, owner: str, repo: str, ghsa_id: str, summary: Optional[str] = None, description: Optional[str] = None, cve_id: Optional[str] = None, vulnerabilities: Optional[List[dict[str, Any]]] = None, cwe_ids: Optional[List[str]] = None, credits: Optional[List[dict[str, Any]]] = None, severity: Optional[str] = None, cvss_vector_string: Optional[str] = None, state: Optional[str] = None, collaborating_users: Optional[List[str]] = None, collaborating_teams: Optional[List[str]] = None) -> dict[str, Any]:
        """
        Updates a specific repository security advisory identified by its GSHA ID using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            ghsa_id (string): ghsa_id
            summary (string): A short summary of the advisory.
            description (string): A detailed description of what the advisory impacts.
            cve_id (string): The Common Vulnerabilities and Exposures (CVE) ID.
            vulnerabilities (array): A product affected by the vulnerability detailed in a repository security advisory.
            cwe_ids (array): A list of Common Weakness Enumeration (CWE) IDs.
            credits (array): A list of users receiving credit for their participation in the security advisory.
            severity (string): The severity of the advisory. You must choose between setting this field or `cvss_vector_string`. Example: 'critical'.
            cvss_vector_string (string): The CVSS vector that calculates the severity of the advisory. You must choose between setting this field or `severity`.
            state (string): The state of the advisory. Example: 'published'.
            collaborating_users (array): A list of usernames who have been granted write access to the advisory.
            collaborating_teams (array): A list of team slugs which have been granted write access to the advisory.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            security-advisories
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if ghsa_id is None:
            raise ValueError("Missing required parameter 'ghsa_id'.")
        request_body_data = None
        request_body_data = {
            'summary': summary,
            'description': description,
            'cve_id': cve_id,
            'vulnerabilities': vulnerabilities,
            'cwe_ids': cwe_ids,
            'credits': credits,
            'severity': severity,
            'cvss_vector_string': cvss_vector_string,
            'state': state,
            'collaborating_users': collaborating_users,
            'collaborating_teams': collaborating_teams,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/security-advisories/{ghsa_id}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def post_repo_security_advisory_cve(self, owner: str, repo: str, ghsa_id: str) -> dict[str, Any]:
        """
        Requests a CVE identification number for a specified GitHub Security Advisory (GHSA) in a repository.

        Args:
            owner (string): owner
            repo (string): repo
            ghsa_id (string): ghsa_id

        Returns:
            dict[str, Any]: Accepted

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            security-advisories
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if ghsa_id is None:
            raise ValueError("Missing required parameter 'ghsa_id'.")
        request_body_data = None
        url = f"{self.base_url}/repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def fork_security_advisory(self, owner: str, repo: str, ghsa_id: str) -> dict[str, Any]:
        """
        Creates a temporary private fork for a repository security advisory, allowing private collaboration on fixing a security vulnerability.

        Args:
            owner (string): owner
            repo (string): repo
            ghsa_id (string): ghsa_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            security-advisories
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if ghsa_id is None:
            raise ValueError("Missing required parameter 'ghsa_id'.")
        request_body_data = None
        url = f"{self.base_url}/repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_stargazers(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None) -> Any:
        """
        Retrieves a list of users who have starred the specified GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/stargazers"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_code_frequency_stats(self, owner: str, repo: str) -> list[Any]:
        """
        Retrieves a weekly aggregate of the number of additions and deletions pushed to a GitHub repository using the REST API.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            list[Any]: Returns a weekly aggregate of the number of additions and deletions pushed to a repository.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/stats/code_frequency"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_repo_commit_activity_stats(self, owner: str, repo: str) -> list[Any]:
        """
        Retrieves the commit activity statistics for a GitHub repository using the "GET" method, which includes information such as the number of commits by week.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/stats/commit_activity"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_contributors_stats(self, owner: str, repo: str) -> list[Any]:
        """
        Retrieves weekly commit activity statistics for contributors in a GitHub repository, including additions, deletions, and commit counts.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/stats/contributors"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_participation_stats(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Retrieves the commit participation data (weekly commit counts) for a repository, including owner and contributor activity.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: The array order is oldest week (index 0) to most recent week.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/stats/participation"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_punch_card_stats(self, owner: str, repo: str) -> list[Any]:
        """
        Retrieves the hourly commit count for each day of the week from a GitHub repository, providing data in the format of a punch card.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            list[Any]: For example, `[2, 14, 25]` indicates that there were 25 total commits, during the 2:00pm hour on Tuesdays. All times are based on the time zone of individual commits.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/stats/punch_card"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_create_commit_status(self, owner: str, repo: str, sha: str, state: str, target_url: Optional[str] = None, description: Optional[str] = None, context: Optional[str] = None) -> dict[str, Any]:
        """
        Creates a commit status (e.g., success, failure) for a specific SHA in a GitHub repository, including optional context and target URL.

        Args:
            owner (string): owner
            repo (string): repo
            sha (string): sha
            state (string): The state of the status. Example: 'success'.
            target_url (string): The target URL to associate with this status. This URL will be linked from the GitHub UI to allow users to easily see the source of the status.  
        For example, if your continuous integration system is posting build status, you would want to provide the deep link for the build output for this specific SHA:  
        `http://ci.example.com/user/repo/build/sha` Example: 'https://example.com/build/status'.
            description (string): A short description of the status. Example: 'The build succeeded!'.
            context (string): A string label to differentiate this status from the status of other systems. This field is case-insensitive. Example: 'continuous-integration/jenkins'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if sha is None:
            raise ValueError("Missing required parameter 'sha'.")
        request_body_data = None
        request_body_data = {
            'state': state,
            'target_url': target_url,
            'description': description,
            'context': context,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/statuses/{sha}"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_subscribers(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of users subscribed to notifications for a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/subscribers"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def activity_get_repo_subscription(self, owner: str, repo: str) -> dict[str, Any]:
        """
        Retrieves a subscription status for a GitHub repository using the "GET" method at "/repos/{owner}/{repo}/subscription", returning a response based on the repository's subscription status.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: if you subscribe to the repository

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/subscription"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def activity_set_repo_subscription(self, owner: str, repo: str, subscribed: Optional[bool] = None, ignored: Optional[bool] = None) -> dict[str, Any]:
        """
        Subscribes to notifications for activity in a GitHub repository and returns the subscription status.

        Args:
            owner (string): owner
            repo (string): repo
            subscribed (boolean): Determines if notifications should be received from this repository. Example: True.
            ignored (boolean): Determines if all notifications should be blocked from this repository. Example: False.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'subscribed': subscribed,
            'ignored': ignored,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/subscription"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def unsubscribe_repo(self, owner: str, repo: str) -> Any:
        """
        Removes the authenticated user's subscription to a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/subscription"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_list_tags(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of repository tags from a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/tags"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_list_tag_protection(self, owner: str, repo: str) -> list[Any]:
        """
        Retrieves tag protection rules configured for a GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/tags/protection"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_create_tag_protection(self, owner: str, repo: str, pattern: str) -> dict[str, Any]:
        """
        Creates a tag protection rule for a GitHub repository to prevent unauthorized tag operations.

        Args:
            owner (string): owner
            repo (string): repo
            pattern (string): An optional glob pattern to match against when enforcing tag protection. Example: 'v1.*'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'pattern': pattern,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/tags/protection"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_delete_tag_protection(self, owner: str, repo: str, tag_protection_id: str) -> Any:
        """
        Deletes a tag protection state for a specified repository using the GitHub API, removing the protection rules associated with the given tag protection ID.

        Args:
            owner (string): owner
            repo (string): repo
            tag_protection_id (string): tag_protection_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if tag_protection_id is None:
            raise ValueError("Missing required parameter 'tag_protection_id'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/tags/protection/{tag_protection_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_download_tarball_archive(self, owner: str, repo: str, ref: str) -> Any:
        """
        Redirects to a URL for downloading a tar archive of a GitHub repository, specified by the repository owner, name, and reference (e.g., branch or tag), returning a redirect status (302) with the download link.

        Args:
            owner (string): owner
            repo (string): repo
            ref (string): ref

        Returns:
            Any: API response data.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if ref is None:
            raise ValueError("Missing required parameter 'ref'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/tarball/{ref}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_list_teams(self, owner: str, repo: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of teams associated with a specific GitHub repository using the "GET /repos/{owner}/{repo}/teams" method.

        Args:
            owner (string): owner
            repo (string): repo
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/teams"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_all_topics(self, owner: str, repo: str, page: Optional[int] = None, per_page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of repository topics for a specified GitHub repository using the "GET" method.

        Args:
            owner (string): owner
            repo (string): repo
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/topics"
        query_params = {k: v for k, v in [('page', page), ('per_page', per_page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_replace_all_topics(self, owner: str, repo: str, names: List[str]) -> dict[str, Any]:
        """
        Updates the topics for a GitHub repository using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            names (array): An array of topics to add to the repository. Pass one or more topics to _replace_ the set of existing topics. Send an empty array (`[]`) to clear all topics from the repository. **Note:** Topic `names` will be saved as lowercase. Example: ['octocat', 'atom', 'electron', 'api'].

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'names': names,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/topics"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_clones(self, owner: str, repo: str, per: Optional[str] = None) -> dict[str, Any]:
        """
        Retrieves the total number of clones and breakdown per day or week for a GitHub repository using the "GET" method, providing traffic data for the specified repository.

        Args:
            owner (string): owner
            repo (string): repo
            per (string): The time frame to display results for.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/traffic/clones"
        query_params = {k: v for k, v in [('per', per)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_top_paths(self, owner: str, repo: str) -> list[Any]:
        """
        Retrieves the top 10 popular paths in a GitHub repository over the last 14 days using the "GET" method at the "/repos/{owner}/{repo}/traffic/popular/paths" endpoint.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/traffic/popular/paths"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_top_referrers(self, owner: str, repo: str) -> list[Any]:
        """
        Retrieves a list of the most popular referrers for a GitHub repository, providing details on traffic sources.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/traffic/popular/referrers"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_get_views(self, owner: str, repo: str, per: Optional[str] = None) -> dict[str, Any]:
        """
        Retrieves the total number of views and daily/weekly breakdowns for a GitHub repository over the last 14 days.

        Args:
            owner (string): owner
            repo (string): repo
            per (string): The time frame to display results for.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/traffic/views"
        query_params = {k: v for k, v in [('per', per)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_transfer(self, owner: str, repo: str, new_owner: str, new_name: Optional[str] = None, team_ids: Optional[List[int]] = None) -> dict[str, Any]:
        """
        Transfers ownership of a GitHub repository to another user or organization using the GitHub API and returns a success status upon initiation.

        Args:
            owner (string): owner
            repo (string): repo
            new_owner (string): The username or organization name the repository will be transferred to. Example: 'github'.
            new_name (string): The new name to be given to the repository. Example: 'octorepo'.
            team_ids (array): ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories. Example: [12, 345].

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'new_owner': new_owner,
            'new_name': new_name,
            'team_ids': team_ids,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{owner}/{repo}/transfer"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_vulnerability_alerts(self, owner: str, repo: str) -> Any:
        """
        Retrieves vulnerability alerts for a specific GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            Any: Response if repository is enabled with vulnerability alerts

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/vulnerability-alerts"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_vulnerability_alerts(self, owner: str, repo: str) -> Any:
        """
        Updates vulnerability alerts for a GitHub repository at the specified path using the PUT method.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        url = f"{self.base_url}/repos/{owner}/{repo}/vulnerability-alerts"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_vulnerability_alerts(self, owner: str, repo: str) -> Any:
        """
        Disables vulnerability alerts for the specified GitHub repository.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/vulnerability-alerts"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_download_zipball_archive(self, owner: str, repo: str, ref: str) -> Any:
        """
        Downloads a ZIP archive of a GitHub repository at a specified reference using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo
            ref (string): ref

        Returns:
            Any: API response data.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        if ref is None:
            raise ValueError("Missing required parameter 'ref'.")
        url = f"{self.base_url}/repos/{owner}/{repo}/zipball/{ref}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_create_using_template(self, template_owner: str, template_repo: str, name: str, owner: Optional[str] = None, description: Optional[str] = None, include_all_branches: Optional[bool] = None, private: Optional[bool] = None) -> dict[str, Any]:
        """
        Creates a new GitHub repository from a specified template repository using the GitHub API.

        Args:
            template_owner (string): template_owner
            template_repo (string): template_repo
            name (string): The name of the new repository. Example: 'Hello-World'.
            owner (string): The organization or person who will own the new repository. To create a new repository in an organization, the authenticated user must be a member of the specified organization. Example: 'octocat'.
            description (string): A short description of the new repository. Example: 'This is your first repository'.
            include_all_branches (boolean): Set to `true` to include the directory structure and files from all branches in the template repository, and not just the default branch. Default: `false`. Example: False.
            private (boolean): Either `true` to create a new private repository or `false` to create a new public one. Example: False.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if template_owner is None:
            raise ValueError("Missing required parameter 'template_owner'.")
        if template_repo is None:
            raise ValueError("Missing required parameter 'template_repo'.")
        request_body_data = None
        request_body_data = {
            'owner': owner,
            'name': name,
            'description': description,
            'include_all_branches': include_all_branches,
            'private': private,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/repos/{template_owner}/{template_repo}/generate"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_list_public(self, since: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of repositories filtered by a timestamp parameter, returning status codes for successful responses, not modified, or validation errors.

        Args:
            since (integer): A repository ID. Only return repositories with an ID greater than this ID.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        url = f"{self.base_url}/repositories"
        query_params = {k: v for k, v in [('since', since)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def search_code(self, q: str, sort: Optional[str] = None, order: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Searches code using specified query parameters and returns matching results.

        Args:
            q (string): The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query]( See "[Searching code]( for a detailed list of qualifiers.
            sort (string): **This field is closing down.** Sorts the results of your query. Can only be `indexed`, which indicates how recently a file has been indexed by the GitHub search infrastructure. Default: [best match](
            order (string): **This field is closing down.** Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            search
        """
        url = f"{self.base_url}/search/code"
        query_params = {k: v for k, v in [('q', q), ('sort', sort), ('order', order), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def search_commits(self, q: str, sort: Optional[str] = None, order: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Searches for commits on GitHub using a query and returns a list of matching commits, supporting options for sorting, ordering, and pagination.

        Args:
            q (string): The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query]( See "[Searching commits]( for a detailed list of qualifiers.
            sort (string): Sorts the results of your query by `author-date` or `committer-date`. Default: [best match](
            order (string): Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            search
        """
        url = f"{self.base_url}/search/commits"
        query_params = {k: v for k, v in [('q', q), ('sort', sort), ('order', order), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def search_issues(self, q: str, sort: Optional[str] = None, order: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None, advanced_search: Optional[str] = None) -> dict[str, Any]:
        """
        Searches GitHub issues and pull requests using specified filters and returns matching results.

        Args:
            q (string): The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query]( See "[Searching issues and pull requests]( for a detailed list of qualifiers.
            sort (string): Sorts the results of your query by the number of `comments`, `reactions`, `reactions-+1`, `reactions--1`, `reactions-smile`, `reactions-thinking_face`, `reactions-heart`, `reactions-tada`, or `interactions`. You can also sort results by how recently the items were `created` or `updated`, Default: [best match](
            order (string): Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            advanced_search (string): Set to `true` to use advanced search.
        Example: `http://api.github.com/search/issues?q={query}&advanced_search=true`

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            search
        """
        url = f"{self.base_url}/search/issues"
        query_params = {k: v for k, v in [('q', q), ('sort', sort), ('order', order), ('per_page', per_page), ('page', page), ('advanced_search', advanced_search)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def search_labels(self, repository_id: int, q: str, sort: Optional[str] = None, order: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of labels for a specified repository using the "GET" method, allowing filtering by query, sorting, and pagination.

        Args:
            repository_id (integer): The id of the repository.
            q (string): The search keywords. This endpoint does not accept qualifiers in the query. To learn more about the format of the query, see [Constructing a search query](
            sort (string): Sorts the results of your query by when the label was `created` or `updated`. Default: [best match](
            order (string): Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            search
        """
        url = f"{self.base_url}/search/labels"
        query_params = {k: v for k, v in [('repository_id', repository_id), ('q', q), ('sort', sort), ('order', order), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def search_repos(self, q: str, sort: Optional[str] = None, order: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Searches and retrieves a list of GitHub repositories based on search parameters using the GitHub API.

        Args:
            q (string): The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query]( See "[Searching for repositories]( for a detailed list of qualifiers.
            sort (string): Sorts the results of your query by number of `stars`, `forks`, or `help-wanted-issues` or how recently the items were `updated`. Default: [best match](
            order (string): Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            search
        """
        url = f"{self.base_url}/search/repositories"
        query_params = {k: v for k, v in [('q', q), ('sort', sort), ('order', order), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def search_topics(self, q: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of topics matching a search query with pagination support.

        Args:
            q (string): The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            search
        """
        url = f"{self.base_url}/search/topics"
        query_params = {k: v for k, v in [('q', q), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def search_users(self, q: str, sort: Optional[str] = None, order: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Searches for GitHub users based on specified query parameters and returns matching results.

        Args:
            q (string): The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query]( See "[Searching users]( for a detailed list of qualifiers.
            sort (string): Sorts the results of your query by number of `followers` or `repositories`, or when the person `joined` GitHub. Default: [best match](
            order (string): Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            search
        """
        url = f"{self.base_url}/search/users"
        query_params = {k: v for k, v in [('q', q), ('sort', sort), ('order', order), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_get_legacy(self, team_id: str) -> dict[str, Any]:
        """
        Retrieves information for a specific team by its ID using the GET method at the "/teams/{team_id}" endpoint.

        Args:
            team_id (string): team_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        url = f"{self.base_url}/teams/{team_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_update_legacy(self, team_id: str, name: str, description: Optional[str] = None, privacy: Optional[str] = None, notification_setting: Optional[str] = None, permission: Optional[str] = None, parent_team_id: Optional[int] = None) -> dict[str, Any]:
        """
        Updates a team's properties by applying partial modifications using the PATCH method at the "/teams/{team_id}" path.

        Args:
            team_id (string): team_id
            name (string): The name of the team. Example: 'new team name'.
            description (string): The description of the team. Example: 'new team description'.
            privacy (string): The level of privacy this team should have. Editing teams without specifying this parameter leaves `privacy` intact. The options are:  
        **For a non-nested team:**  
         * `secret` - only visible to organization owners and members of this team.  
         * `closed` - visible to all members of this organization.  
        **For a parent or child team:**  
         * `closed` - visible to all members of this organization. Example: 'closed'.
            notification_setting (string): The notification setting the team has chosen. Editing teams without specifying this parameter leaves `notification_setting` intact. The options are: 
         * `notifications_enabled` - team members receive notifications when the team is @mentioned.  
         * `notifications_disabled` - no one receives notifications. Example: 'notifications_enabled'.
            permission (string): **Closing down notice**. The permission that new repositories will be added to the team with when none is specified.
            parent_team_id (integer): The ID of a team to set as the parent team.

        Returns:
            dict[str, Any]: Response when the updated information already exists

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'description': description,
            'privacy': privacy,
            'notification_setting': notification_setting,
            'permission': permission,
            'parent_team_id': parent_team_id,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/teams/{team_id}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_delete_legacy(self, team_id: str) -> Any:
        """
        Deletes a team with the specified ID from the system, returning appropriate status codes based on the operation's success or failure.

        Args:
            team_id (string): team_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        url = f"{self.base_url}/teams/{team_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_list_discussions_legacy(self, team_id: str, direction: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of discussion posts from a specific team's page via GitHub API.

        Args:
            team_id (string): team_id
            direction (string): The direction to sort the results by.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        url = f"{self.base_url}/teams/{team_id}/discussions"
        query_params = {k: v for k, v in [('direction', direction), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_create_discussion_legacy(self, team_id: str, title: str, body: str, private: Optional[bool] = None) -> dict[str, Any]:
        """
        Creates a new discussion post on a GitHub team's page using the `POST` method.

        Args:
            team_id (string): team_id
            title (string): The discussion post's title. Example: 'Our first team post'.
            body (string): The discussion post's body text. Example: 'Hi! This is an area for us to collaborate as a team.'.
            private (boolean): Private posts are only visible to team members, organization owners, and team maintainers. Public posts are visible to all members of the organization. Set to `true` to create a private post.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        request_body_data = None
        request_body_data = {
            'title': title,
            'body': body,
            'private': private,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/teams/{team_id}/discussions"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_get_discussion_legacy(self, team_id: str, discussion_number: str) -> dict[str, Any]:
        """
        Retrieves a specific team discussion from a GitHub team using the provided team ID and discussion number.

        Args:
            team_id (string): team_id
            discussion_number (string): discussion_number

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        if discussion_number is None:
            raise ValueError("Missing required parameter 'discussion_number'.")
        url = f"{self.base_url}/teams/{team_id}/discussions/{discussion_number}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_update_discussion_legacy(self, team_id: str, discussion_number: str, title: Optional[str] = None, body: Optional[str] = None) -> dict[str, Any]:
        """
        Updates a team discussion's title and body text via the GitHub API.

        Args:
            team_id (string): team_id
            discussion_number (string): discussion_number
            title (string): The discussion post's title. Example: 'Welcome to our first team post'.
            body (string): The discussion post's body text.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        if discussion_number is None:
            raise ValueError("Missing required parameter 'discussion_number'.")
        request_body_data = None
        request_body_data = {
            'title': title,
            'body': body,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/teams/{team_id}/discussions/{discussion_number}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_delete_discussion_legacy(self, team_id: str, discussion_number: str) -> Any:
        """
        Deletes a team discussion and returns an empty response.

        Args:
            team_id (string): team_id
            discussion_number (string): discussion_number

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        if discussion_number is None:
            raise ValueError("Missing required parameter 'discussion_number'.")
        url = f"{self.base_url}/teams/{team_id}/discussions/{discussion_number}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_discussion_comments(self, team_id: str, discussion_number: str, direction: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of comments for a specific team discussion via the GitHub API.

        Args:
            team_id (string): team_id
            discussion_number (string): discussion_number
            direction (string): The direction to sort the results by.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        if discussion_number is None:
            raise ValueError("Missing required parameter 'discussion_number'.")
        url = f"{self.base_url}/teams/{team_id}/discussions/{discussion_number}/comments"
        query_params = {k: v for k, v in [('direction', direction), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_team_discussion_comment(self, team_id: str, discussion_number: str, body: str) -> dict[str, Any]:
        """
        Creates a new discussion comment on a specified team discussion post using the GitHub API.

        Args:
            team_id (string): team_id
            discussion_number (string): discussion_number
            body (string): The discussion comment's body text. Example: 'Do you like apples?'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        if discussion_number is None:
            raise ValueError("Missing required parameter 'discussion_number'.")
        request_body_data = None
        request_body_data = {
            'body': body,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/teams/{team_id}/discussions/{discussion_number}/comments"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_comment_by_number(self, team_id: str, discussion_number: str, comment_number: str) -> dict[str, Any]:
        """
        Retrieves a specific comment from a team discussion on GitHub using the provided team ID, discussion number, and comment number.

        Args:
            team_id (string): team_id
            discussion_number (string): discussion_number
            comment_number (string): comment_number

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        if discussion_number is None:
            raise ValueError("Missing required parameter 'discussion_number'.")
        if comment_number is None:
            raise ValueError("Missing required parameter 'comment_number'.")
        url = f"{self.base_url}/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def patch_team_discussion_comment(self, team_id: str, discussion_number: str, comment_number: str, body: str) -> dict[str, Any]:
        """
        Updates a comment on a team discussion using the GitHub API, returning a success status upon completion.

        Args:
            team_id (string): team_id
            discussion_number (string): discussion_number
            comment_number (string): comment_number
            body (string): The discussion comment's body text. Example: 'Do you like pineapples?'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        if discussion_number is None:
            raise ValueError("Missing required parameter 'discussion_number'.")
        if comment_number is None:
            raise ValueError("Missing required parameter 'comment_number'.")
        request_body_data = None
        request_body_data = {
            'body': body,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_comment(self, team_id: str, discussion_number: str, comment_number: str) -> Any:
        """
        Deletes a specific comment within a team discussion on GitHub using the API and returns a successful status message upon deletion.

        Args:
            team_id (string): team_id
            discussion_number (string): discussion_number
            comment_number (string): comment_number

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        if discussion_number is None:
            raise ValueError("Missing required parameter 'discussion_number'.")
        if comment_number is None:
            raise ValueError("Missing required parameter 'comment_number'.")
        url = f"{self.base_url}/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_reaction_by_comment(self, team_id: str, discussion_number: str, comment_number: str, content: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Lists reactions (e.g., , ) for a specific comment in a team discussion using the GitHub API.

        Args:
            team_id (string): team_id
            discussion_number (string): discussion_number
            comment_number (string): comment_number
            content (string): Returns a single [reaction type]( Omit this parameter to list all reactions to a team discussion comment.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            reactions
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        if discussion_number is None:
            raise ValueError("Missing required parameter 'discussion_number'.")
        if comment_number is None:
            raise ValueError("Missing required parameter 'comment_number'.")
        url = f"{self.base_url}/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions"
        query_params = {k: v for k, v in [('content', content), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def add_team_comment_reaction(self, team_id: str, discussion_number: str, comment_number: str, content: str) -> dict[str, Any]:
        """
        Creates a reaction to a team discussion comment, allowing users to interact with comments on team discussions using the GitHub API.

        Args:
            team_id (string): team_id
            discussion_number (string): discussion_number
            comment_number (string): comment_number
            content (string): The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion comment. Example: 'heart'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            reactions
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        if discussion_number is None:
            raise ValueError("Missing required parameter 'discussion_number'.")
        if comment_number is None:
            raise ValueError("Missing required parameter 'comment_number'.")
        request_body_data = None
        request_body_data = {
            'content': content,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_team_discussion_reactions(self, team_id: str, discussion_number: str, content: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of reactions for a specific discussion post within a team using the GitHub API.

        Args:
            team_id (string): team_id
            discussion_number (string): discussion_number
            content (string): Returns a single [reaction type]( Omit this parameter to list all reactions to a team discussion.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            reactions
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        if discussion_number is None:
            raise ValueError("Missing required parameter 'discussion_number'.")
        url = f"{self.base_url}/teams/{team_id}/discussions/{discussion_number}/reactions"
        query_params = {k: v for k, v in [('content', content), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def add_reaction_to_discussion(self, team_id: str, discussion_number: str, content: str) -> dict[str, Any]:
        """
        Adds a reaction to a team discussion comment using the GitHub API.

        Args:
            team_id (string): team_id
            discussion_number (string): discussion_number
            content (string): The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion. Example: 'heart'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            reactions
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        if discussion_number is None:
            raise ValueError("Missing required parameter 'discussion_number'.")
        request_body_data = None
        request_body_data = {
            'content': content,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/teams/{team_id}/discussions/{discussion_number}/reactions"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_team_invitations(self, team_id: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of pending invitations for a specified GitHub team using the "GET" method at the "/teams/{team_id}/invitations" path.

        Args:
            team_id (string): team_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        url = f"{self.base_url}/teams/{team_id}/invitations"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_list_members_legacy(self, team_id: str, role: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of members for a specified team, optionally filtered by role, with pagination support.

        Args:
            team_id (string): team_id
            role (string): Filters members returned by their role in the team.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        url = f"{self.base_url}/teams/{team_id}/members"
        query_params = {k: v for k, v in [('role', role), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_get_member_legacy(self, team_id: str, username: str) -> Any:
        """
        Retrieves a specific team member's details by username within a team.

        Args:
            team_id (string): team_id
            username (string): username

        Returns:
            Any: if user is a member

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/teams/{team_id}/members/{username}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_add_member_legacy(self, team_id: str, username: str) -> Any:
        """
        Adds a user to a team by their username and returns a success status.

        Args:
            team_id (string): team_id
            username (string): username

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        request_body_data = None
        url = f"{self.base_url}/teams/{team_id}/members/{username}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_remove_member_legacy(self, team_id: str, username: str) -> Any:
        """
        Removes a member with the specified username from a team using the DELETE method.

        Args:
            team_id (string): team_id
            username (string): username

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/teams/{team_id}/members/{username}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_team_membership_by_username(self, team_id: str, username: str) -> dict[str, Any]:
        """
        Retrieves the team membership status for a specific user in a GitHub organization team.

        Args:
            team_id (string): team_id
            username (string): username

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/teams/{team_id}/memberships/{username}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_membership_for_user(self, team_id: str, username: str, role: Optional[str] = None) -> dict[str, Any]:
        """
        Adds or updates team membership for a user, granting organization owners/team maintainers the ability to invite new members or modify existing roles.

        Args:
            team_id (string): team_id
            username (string): username
            role (string): The role that this user should have in the team. Example: 'member'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        request_body_data = None
        request_body_data = {
            'role': role,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/teams/{team_id}/memberships/{username}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_membership_by_user(self, team_id: str, username: str) -> Any:
        """
        Removes a team membership for a specified user using the GitHub API and returns a status message.

        Args:
            team_id (string): team_id
            username (string): username

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/teams/{team_id}/memberships/{username}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_list_projects_legacy(self, team_id: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of projects for a specified team using the team ID.

        Args:
            team_id (string): team_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        url = f"{self.base_url}/teams/{team_id}/projects"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_team_project(self, team_id: str, project_id: str) -> dict[str, Any]:
        """
        Retrieves a specific project within a designated team using provided identifiers.

        Args:
            team_id (string): team_id
            project_id (string): project_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        if project_id is None:
            raise ValueError("Missing required parameter 'project_id'.")
        url = f"{self.base_url}/teams/{team_id}/projects/{project_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_project_details(self, team_id: str, project_id: str, permission: Optional[str] = None) -> Any:
        """
        Updates the project details for a specified team and returns a success status upon completion.

        Args:
            team_id (string): team_id
            project_id (string): project_id
            permission (string): The permission to grant to the team for this project. Default: the team's `permission` attribute will be used to determine what permission to grant the team on this project. Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)." Example: 'read'.

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        if project_id is None:
            raise ValueError("Missing required parameter 'project_id'.")
        request_body_data = None
        request_body_data = {
            'permission': permission,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/teams/{team_id}/projects/{project_id}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_remove_project_legacy(self, team_id: str, project_id: str) -> Any:
        """
        Deletes a project from a specified team using the "DELETE" method and returns a status message based on the operation's success or failure.

        Args:
            team_id (string): team_id
            project_id (string): project_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        if project_id is None:
            raise ValueError("Missing required parameter 'project_id'.")
        url = f"{self.base_url}/teams/{team_id}/projects/{project_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_list_repos_legacy(self, team_id: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of repositories accessible to the specified team using the GitHub API.

        Args:
            team_id (string): team_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        url = f"{self.base_url}/teams/{team_id}/repos"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_team_repo_by_owner_repo(self, team_id: str, owner: str, repo: str) -> dict[str, Any]:
        """
        Retrieves the permissions and status of a specific repository for a GitHub team using the team ID, repository owner, and repository name.

        Args:
            team_id (string): team_id
            owner (string): owner
            repo (string): repo

        Returns:
            dict[str, Any]: Alternative response with extra repository information

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/teams/{team_id}/repos/{owner}/{repo}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_team_repo(self, team_id: str, owner: str, repo: str, permission: Optional[str] = None) -> Any:
        """
        Adds a repository to a GitHub team using the GitHub API, requiring the team ID, repository owner, and repository name.

        Args:
            team_id (string): team_id
            owner (string): owner
            repo (string): repo
            permission (string): The permission to grant the team on this repository. If no permission is specified, the team's `permission` attribute will be used to determine what permission to grant the team on this repository. Example: 'push'.

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        request_body_data = {
            'permission': permission,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/teams/{team_id}/repos/{owner}/{repo}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_remove_repo_legacy(self, team_id: str, owner: str, repo: str) -> Any:
        """
        Removes a repository from a team using the GitHub API, deleting the repository's association with the specified team without deleting the repository itself.

        Args:
            team_id (string): team_id
            owner (string): owner
            repo (string): repo

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/teams/{team_id}/repos/{owner}/{repo}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def teams_list_child_legacy(self, team_id: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of teams associated with the specified team ID using the GET method.

        Args:
            team_id (string): team_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: if child teams exist

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        if team_id is None:
            raise ValueError("Missing required parameter 'team_id'.")
        url = f"{self.base_url}/teams/{team_id}/teams"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def users_get_authenticated(self) -> Any:
        """
        Retrieves user information using the "GET" method at the "/user" path.

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        url = f"{self.base_url}/user"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def users_update_authenticated(self, name: Optional[str] = None, email: Optional[str] = None, blog: Optional[str] = None, twitter_username: Optional[str] = None, company: Optional[str] = None, location: Optional[str] = None, hireable: Optional[bool] = None, bio: Optional[str] = None) -> dict[str, Any]:
        """
        Updates a user's information using the PATCH method at the "/user" endpoint, allowing partial modifications to user data.

        Args:
            name (string): The new name of the user. Example: 'Omar Jahandar'.
            email (string): The publicly visible email address of the user. Example: 'omar@example.com'.
            blog (string): The new blog URL of the user. Example: 'blog.example.com'.
            twitter_username (string): The new Twitter username of the user. Example: 'therealomarj'.
            company (string): The new company of the user. Example: 'Acme corporation'.
            location (string): The new location of the user. Example: 'Berlin, Germany'.
            hireable (boolean): The new hiring availability of the user.
            bio (string): The new short biography of the user.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        request_body_data = None
        request_body_data = {
            'name': name,
            'email': email,
            'blog': blog,
            'twitter_username': twitter_username,
            'company': company,
            'location': location,
            'hireable': hireable,
            'bio': bio,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/user"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_user_blocks(self, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of user blocks using the "GET" method at the "/user/blocks" endpoint, allowing for pagination through "per-page" and "page" parameters.

        Args:
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        url = f"{self.base_url}/user/blocks"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def users_check_blocked(self, username: str) -> Any:
        """
        Retrieves information about a blocked user specified by the username parameter.

        Args:
            username (string): username

        Returns:
            Any: If the user is blocked

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/user/blocks/{username}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def users_block(self, username: str) -> Any:
        """
        Updates the block status for a user, specified by their username, and returns a status message.

        Args:
            username (string): username

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        request_body_data = None
        url = f"{self.base_url}/user/blocks/{username}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def users_unblock(self, username: str) -> Any:
        """
        Unblocks a GitHub user using the GitHub API by deleting the block for the specified username and returns a status message upon success.

        Args:
            username (string): username

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/user/blocks/{username}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_codespaces(self, per_page: Optional[int] = None, page: Optional[int] = None, repository_id: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a paginated list of the authenticated user's GitHub Codespaces, optionally filtered by repository ID.

        Args:
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            repository_id (integer): ID of the Repository to filter on

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        url = f"{self.base_url}/user/codespaces"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page), ('repository_id', repository_id)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_user_codespace(self, repository_id: Optional[int] = None, ref: Optional[str] = None, location: Optional[str] = None, geo: Optional[str] = None, client_ip: Optional[str] = None, machine: Optional[str] = None, devcontainer_path: Optional[str] = None, multi_repo_permissions_opt_out: Optional[bool] = None, working_directory: Optional[str] = None, idle_timeout_minutes: Optional[int] = None, display_name: Optional[str] = None, retention_period_minutes: Optional[int] = None, pull_request: Optional[dict[str, Any]] = None) -> dict[str, Any]:
        """
        Creates a new GitHub Codespace for the authenticated user and returns status codes indicating success or error conditions.

        Args:
            repository_id (integer): Repository id for this codespace Example: 1.
            ref (string): Git ref (typically a branch name) for this codespace Example: 'main'.
            location (string): The requested location for a new codespace. Best efforts are made to respect this upon creation. Assigned by IP if not provided.
            geo (string): The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is closing down. Example: 'UsWest'.
            client_ip (string): IP for location auto-detection when proxying a request
            machine (string): Machine type to use for this codespace
            devcontainer_path (string): Path to devcontainer.json config to use for this codespace
            multi_repo_permissions_opt_out (boolean): Whether to authorize requested permissions from devcontainer.json
            working_directory (string): Working directory for this codespace
            idle_timeout_minutes (integer): Time in minutes before codespace stops from inactivity
            display_name (string): Display name for this codespace
            retention_period_minutes (integer): Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).
            pull_request (object): Pull request number for this codespace

        Returns:
            dict[str, Any]: Response when the codespace was successfully created

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        request_body_data = None
        request_body_data = {
            'repository_id': repository_id,
            'ref': ref,
            'location': location,
            'geo': geo,
            'client_ip': client_ip,
            'machine': machine,
            'devcontainer_path': devcontainer_path,
            'multi_repo_permissions_opt_out': multi_repo_permissions_opt_out,
            'working_directory': working_directory,
            'idle_timeout_minutes': idle_timeout_minutes,
            'display_name': display_name,
            'retention_period_minutes': retention_period_minutes,
            'pull_request': pull_request,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/user/codespaces"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_user_secrets(self, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a list of secrets for the authenticated user's GitHub Codespaces using the "GET" method, allowing access to secrets such as access tokens for cloud services without revealing their encrypted values.

        Args:
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        url = f"{self.base_url}/user/codespaces/secrets"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_codespaces_public_key(self) -> dict[str, Any]:
        """
        Retrieves a public key for encrypting user secrets in GitHub Codespaces, which is necessary for creating or updating encrypted secrets.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        url = f"{self.base_url}/user/codespaces/secrets/public-key"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_secret_by_name(self, secret_name: str) -> dict[str, Any]:
        """
        Retrieves a secret for the authenticated user's GitHub Codespaces without revealing its encrypted value, allowing access to sensitive information like access tokens or credentials.

        Args:
            secret_name (string): secret_name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        url = f"{self.base_url}/user/codespaces/secrets/{secret_name}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_secret_code(self, secret_name: str, key_id: str, encrypted_value: Optional[str] = None, selected_repository_ids: Optional[List[Any]] = None) -> dict[str, Any]:
        """
        Creates or updates a user-specific secret for GitHub Codespaces, making it available to authorized repositories.

        Args:
            secret_name (string): secret_name
            key_id (string): ID of the key you used to encrypt the secret. Example: '012345678912345678'.
            encrypted_value (string): Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get the public key for the authenticated user](https://docs.github.com/rest/codespaces/secrets#get-public-key-for-the-authenticated-user) endpoint. Example: 'c2VjcmV0'.
            selected_repository_ids (array): An array of repository ids that can access the user secret. You can manage the list of selected repositories using the [List selected repositories for a user secret](https://docs.github.com/rest/codespaces/secrets#list-selected-repositories-for-a-user-secret), [Set selected repositories for a user secret](https://docs.github.com/rest/codespaces/secrets#set-selected-repositories-for-a-user-secret), and [Remove a selected repository from a user secret](https://docs.github.com/rest/codespaces/secrets#remove-a-selected-repository-from-a-user-secret) endpoints. Example: ['1234567', '2345678'].

        Returns:
            dict[str, Any]: Response after successfully creating a secret

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        request_body_data = None
        request_body_data = {
            'encrypted_value': encrypted_value,
            'key_id': key_id,
            'selected_repository_ids': selected_repository_ids,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/user/codespaces/secrets/{secret_name}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_secret_by_name(self, secret_name: str) -> Any:
        """
        Deletes a development environment secret for the authenticated user from GitHub Codespaces using the specified secret name, removing access from all associated codespaces.

        Args:
            secret_name (string): secret_name

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        url = f"{self.base_url}/user/codespaces/secrets/{secret_name}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_secret_repositories(self, secret_name: str) -> dict[str, Any]:
        """
        Lists the repositories that have been granted access to a specific user secret in GitHub Codespaces.

        Args:
            secret_name (string): secret_name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        url = f"{self.base_url}/user/codespaces/secrets/{secret_name}/repositories"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def put_user_codespaces_secret_repos(self, secret_name: str, selected_repository_ids: List[int]) -> Any:
        """
        Associates a specified secret with one or more repositories in a user's GitHub Codespaces, using the "PUT" method.

        Args:
            secret_name (string): secret_name
            selected_repository_ids (array): An array of repository ids for which a codespace can access the secret. You can manage the list of selected repositories using the [List selected repositories for a user secret](https://docs.github.com/rest/codespaces/secrets#list-selected-repositories-for-a-user-secret), [Add a selected repository to a user secret](https://docs.github.com/rest/codespaces/secrets#add-a-selected-repository-to-a-user-secret), and [Remove a selected repository from a user secret](https://docs.github.com/rest/codespaces/secrets#remove-a-selected-repository-from-a-user-secret) endpoints. Example: ['1296269', '1296280'].

        Returns:
            Any: No Content when repositories were added to the selected list

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        request_body_data = None
        request_body_data = {
            'selected_repository_ids': selected_repository_ids,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/user/codespaces/secrets/{secret_name}/repositories"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_secrets_repository(self, secret_name: str, repository_id: str) -> Any:
        """
        Associates a secret with a specified repository in a user's codespaces using the GitHub API, updating the secret's repository linkage.

        Args:
            secret_name (string): secret_name
            repository_id (string): repository_id

        Returns:
            Any: No Content when repository was added to the selected list

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        if repository_id is None:
            raise ValueError("Missing required parameter 'repository_id'.")
        request_body_data = None
        url = f"{self.base_url}/user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_secret_repo_access(self, secret_name: str, repository_id: str) -> Any:
        """
        Removes a repository from the list of repositories assigned to a user's Codespaces secret using the GitHub API.

        Args:
            secret_name (string): secret_name
            repository_id (string): repository_id

        Returns:
            Any: No Content when repository was removed from the selected list

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if secret_name is None:
            raise ValueError("Missing required parameter 'secret_name'.")
        if repository_id is None:
            raise ValueError("Missing required parameter 'repository_id'.")
        url = f"{self.base_url}/user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_user_codespace_by_name(self, codespace_name: str) -> dict[str, Any]:
        """
        Retrieves details for a specific user-owned GitHub Codespace by name.

        Args:
            codespace_name (string): codespace_name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if codespace_name is None:
            raise ValueError("Missing required parameter 'codespace_name'.")
        url = f"{self.base_url}/user/codespaces/{codespace_name}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_codespace(self, codespace_name: str, machine: Optional[str] = None, display_name: Optional[str] = None, recent_folders: Optional[List[str]] = None) -> dict[str, Any]:
        """
        Updates an existing GitHub Codespace (cloud development environment) with configuration changes.

        Args:
            codespace_name (string): codespace_name
            machine (string): A valid machine to transition this codespace to. Example: 'standardLinux'.
            display_name (string): Display name for this codespace
            recent_folders (array): Recently opened folders inside the codespace. It is currently used by the clients to determine the folder path to load the codespace in.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if codespace_name is None:
            raise ValueError("Missing required parameter 'codespace_name'.")
        request_body_data = None
        request_body_data = {
            'machine': machine,
            'display_name': display_name,
            'recent_folders': recent_folders,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/user/codespaces/{codespace_name}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_codespace(self, codespace_name: str) -> dict[str, Any]:
        """
        Deletes a specified codespace using the GitHub API, returning a status message if successful.

        Args:
            codespace_name (string): codespace_name

        Returns:
            dict[str, Any]: Accepted

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if codespace_name is None:
            raise ValueError("Missing required parameter 'codespace_name'.")
        url = f"{self.base_url}/user/codespaces/{codespace_name}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def export_codespace(self, codespace_name: str) -> dict[str, Any]:
        """
        Initiates an export of a specific GitHub codespace identified by its name, returning a status and details for monitoring the export process.

        Args:
            codespace_name (string): codespace_name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if codespace_name is None:
            raise ValueError("Missing required parameter 'codespace_name'.")
        request_body_data = None
        url = f"{self.base_url}/user/codespaces/{codespace_name}/exports"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_user_codespace_export_by_id(self, codespace_name: str, export_id: str) -> dict[str, Any]:
        """
        Retrieves the status and details of a specific export operation for an authenticated user's codespace.

        Args:
            codespace_name (string): codespace_name
            export_id (string): export_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if codespace_name is None:
            raise ValueError("Missing required parameter 'codespace_name'.")
        if export_id is None:
            raise ValueError("Missing required parameter 'export_id'.")
        url = f"{self.base_url}/user/codespaces/{codespace_name}/exports/{export_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_codespace_machines(self, codespace_name: str) -> dict[str, Any]:
        """
        Retrieves available machine types for a GitHub Codespace to allow changing its compute resources upon restart.

        Args:
            codespace_name (string): codespace_name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if codespace_name is None:
            raise ValueError("Missing required parameter 'codespace_name'.")
        url = f"{self.base_url}/user/codespaces/{codespace_name}/machines"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def publish_codespace(self, codespace_name: str, name: Optional[str] = None, private: Optional[bool] = None) -> dict[str, Any]:
        """
        Publishes a GitHub Codespace using the GitHub API and returns a status message.

        Args:
            codespace_name (string): codespace_name
            name (string): A name for the new repository.
            private (boolean): Whether the new repository should be private. Example: False.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if codespace_name is None:
            raise ValueError("Missing required parameter 'codespace_name'.")
        request_body_data = None
        request_body_data = {
            'name': name,
            'private': private,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/user/codespaces/{codespace_name}/publish"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def start_codespace(self, codespace_name: str) -> dict[str, Any]:
        """
        Starts a GitHub Codespace instance using the GitHub Codespaces API and returns a status message.

        Args:
            codespace_name (string): codespace_name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if codespace_name is None:
            raise ValueError("Missing required parameter 'codespace_name'.")
        request_body_data = None
        url = f"{self.base_url}/user/codespaces/{codespace_name}/start"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def stop_user_codespace(self, codespace_name: str) -> dict[str, Any]:
        """
        Stops a running GitHub Codespace and returns a status code.

        Args:
            codespace_name (string): codespace_name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            codespaces
        """
        if codespace_name is None:
            raise ValueError("Missing required parameter 'codespace_name'.")
        request_body_data = None
        url = f"{self.base_url}/user/codespaces/{codespace_name}/stop"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_user_docker_conflicts(self) -> list[Any]:
        """
        Retrieves a list of conflicting Docker packages during migration for the authenticated user.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        url = f"{self.base_url}/user/docker/conflicts"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_email_visibility(self, visibility: str) -> list[Any]:
        """
        Updates the visibility of the authenticated user's email address (e.g., public/private) and returns the updated email details.

        Args:
            visibility (string): Denotes whether an email is publicly visible. Example: 'private'.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        request_body_data = None
        request_body_data = {
            'visibility': visibility,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/user/email/visibility"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_user_emails(self, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of user email addresses.

        Args:
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        url = f"{self.base_url}/user/emails"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def add_user_email(self, emails: Optional[List[str]] = None) -> list[Any]:
        """
        Adds a new email address for the authenticated user and returns a status message.

        Args:
            emails (array): Adds one or more email addresses to your GitHub account. Must contain at least one email address. **Note:** Alternatively, you can pass a single email address or an `array` of emails addresses directly, but we recommend that you pass an object using the `emails` key. Example: '[]'.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        request_body_data = None
        request_body_data = {
            'emails': emails,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/user/emails"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_emails(self, emails: Optional[List[str]] = None) -> Any:
        """
        Deletes specified email addresses from the authenticated user's GitHub account and returns a 204 No Content status upon success.

        Args:
            emails (array): Email addresses associated with the GitHub user account. Example: ['octocat@github.com', 'mona@github.com'].

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        request_body_data = {
            'emails': emails,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/user/emails"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_user_followers(self, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of followers associated with the user, supporting pagination via per_page and page parameters.

        Args:
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        url = f"{self.base_url}/user/followers"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_following_users(self, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of users that the authenticated user is following, with options to paginate the results.

        Args:
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        url = f"{self.base_url}/user/following"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_following_user(self, username: str) -> Any:
        """
        Checks if the authenticated user follows a specified user on GitHub and returns a status code indicating the result.

        Args:
            username (string): username

        Returns:
            Any: if the person is followed by the authenticated user

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/user/following/{username}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def users_follow(self, username: str) -> Any:
        """
        Follows a specified user or updates the following relationship for the current user to the specified username.

        Args:
            username (string): username

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        request_body_data = None
        url = f"{self.base_url}/user/following/{username}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def users_unfollow(self, username: str) -> Any:
        """
        Unfollows a user using the "DELETE" method, removing the specified user from the list of users being followed.

        Args:
            username (string): username

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/user/following/{username}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_gpg_keys(self, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of GPG keys for the authenticated user, allowing pagination through optional page and per-page parameters.

        Args:
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        url = f"{self.base_url}/user/gpg_keys"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_gpg_key(self, armored_public_key: str, name: Optional[str] = None) -> dict[str, Any]:
        """
        Adds a GPG key to a user's account using the API endpoint at "/user/gpg_keys" with the POST method.

        Args:
            armored_public_key (string): A GPG key in ASCII-armored format. Example: '-----BEGIN PGP PUBLIC KEY BLOCK-----\nVersion: GnuPG v1\n\nmQINBFnZ2ZIBEADQ2Z7Z7\n-----END PGP PUBLIC KEY BLOCK-----'.
            name (string): A descriptive name for the new key. Example: "Octocat's GPG Key".

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        request_body_data = None
        request_body_data = {
            'name': name,
            'armored_public_key': armored_public_key,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/user/gpg_keys"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_gpg_key_by_id(self, gpg_key_id: str) -> dict[str, Any]:
        """
        Retrieves a specific GPG key for a user using the "GET" method, identified by the provided GPG key ID.

        Args:
            gpg_key_id (string): gpg_key_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        if gpg_key_id is None:
            raise ValueError("Missing required parameter 'gpg_key_id'.")
        url = f"{self.base_url}/user/gpg_keys/{gpg_key_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_user_gpg_key_by_id(self, gpg_key_id: str) -> Any:
        """
        Deletes a GPG key identified by its ID from a user's account using the DELETE method.

        Args:
            gpg_key_id (string): gpg_key_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        if gpg_key_id is None:
            raise ValueError("Missing required parameter 'gpg_key_id'.")
        url = f"{self.base_url}/user/gpg_keys/{gpg_key_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_user_installations(self, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves a paginated list of user installations with the specified page and per-page parameters.

        Args:
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: You can find the permissions for the installation under the `permissions` key.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        url = f"{self.base_url}/user/installations"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_installation_repositories(self, installation_id: str, per_page: Optional[int] = None, page: Optional[int] = None) -> dict[str, Any]:
        """
        Lists repositories accessible to a specific GitHub App installation with pagination support.

        Args:
            installation_id (string): installation_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            dict[str, Any]: The access the user has to each repository is included in the hash under the `permissions` key.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        if installation_id is None:
            raise ValueError("Missing required parameter 'installation_id'.")
        url = f"{self.base_url}/user/installations/{installation_id}/repositories"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_repository_installation(self, installation_id: str, repository_id: str) -> Any:
        """
        Updates the repository selection for a GitHub App installation using the "PUT" method at the path "/user/installations/{installation_id}/repositories/{repository_id}".

        Args:
            installation_id (string): installation_id
            repository_id (string): repository_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        if installation_id is None:
            raise ValueError("Missing required parameter 'installation_id'.")
        if repository_id is None:
            raise ValueError("Missing required parameter 'repository_id'.")
        request_body_data = None
        url = f"{self.base_url}/user/installations/{installation_id}/repositories/{repository_id}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_repository_installation(self, installation_id: str, repository_id: str) -> Any:
        """
        Removes a specific repository from a GitHub App installation's list of accessible repositories.

        Args:
            installation_id (string): installation_id
            repository_id (string): repository_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        if installation_id is None:
            raise ValueError("Missing required parameter 'installation_id'.")
        if repository_id is None:
            raise ValueError("Missing required parameter 'repository_id'.")
        url = f"{self.base_url}/user/installations/{installation_id}/repositories/{repository_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_interaction_limits(self) -> Any:
        """
        Retrieves the current user-level interaction limits restricting comment, issue, and pull request creation on public repositories.

        Returns:
            Any: Default response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            interactions
        """
        url = f"{self.base_url}/user/interaction-limits"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_user_interaction_limits(self, limit: str, expiry: Optional[str] = None) -> dict[str, Any]:
        """
        Sets interaction limits for a GitHub user's repositories using the PUT method at the "/user/interaction-limits" path, allowing control over which types of users can comment, open issues, or create pull requests.

        Args:
            limit (string): The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect. Example: 'collaborators_only'.
            expiry (string): The duration of the interaction restriction. Default: `one_day`. Example: 'one_month'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            interactions
        """
        request_body_data = None
        request_body_data = {
            'limit': limit,
            'expiry': expiry,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/user/interaction-limits"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_user_interaction_limits(self) -> Any:
        """
        Removes user interaction limits using the GitHub API, returning a status of "No Content" upon successful deletion.

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            interactions
        """
        url = f"{self.base_url}/user/interaction-limits"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_user_issues(self, filter: Optional[str] = None, state: Optional[str] = None, labels: Optional[str] = None, sort: Optional[str] = None, direction: Optional[str] = None, since: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of user issues using the "GET" method at the "/user/issues" endpoint, allowing filtering by parameters such as filter, state, labels, sort order, since, page size, and page number.

        Args:
            filter (string): Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation.
            state (string): Indicates the state of the issues to return.
            labels (string): A list of comma separated label names. Example: `bug,ui,@high`
            sort (string): What to sort results by.
            direction (string): The direction to sort the results by.
            since (string): Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            issues
        """
        url = f"{self.base_url}/user/issues"
        query_params = {k: v for k, v in [('filter', filter), ('state', state), ('labels', labels), ('sort', sort), ('direction', direction), ('since', since), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_keys(self, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of user keys with pagination support.

        Args:
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        url = f"{self.base_url}/user/keys"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_user_key(self, key: str, title: Optional[str] = None) -> dict[str, Any]:
        """
        Creates a new API key for a user account and returns the generated key upon success.

        Args:
            key (string): The public SSH key to add to your GitHub account. Example: '2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvv1234'.
            title (string): A descriptive name for the new key. Example: 'Personal MacBook Air'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        request_body_data = None
        request_body_data = {
            'title': title,
            'key': key,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/user/keys"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_user_key_by_id(self, key_id: str) -> dict[str, Any]:
        """
        Retrieves a specific user key by ID from the API.

        Args:
            key_id (string): key_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        if key_id is None:
            raise ValueError("Missing required parameter 'key_id'.")
        url = f"{self.base_url}/user/keys/{key_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_user_key_by_id(self, key_id: str) -> Any:
        """
        Deletes a user API key identified by the key ID using the DELETE method.

        Args:
            key_id (string): key_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        if key_id is None:
            raise ValueError("Missing required parameter 'key_id'.")
        url = f"{self.base_url}/user/keys/{key_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_user_marketplace_purchases(self, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of a user's marketplace purchases.

        Args:
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        url = f"{self.base_url}/user/marketplace_purchases"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_marketplace_purchases(self, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of stubbed marketplace purchases for the authenticated user.

        Args:
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        url = f"{self.base_url}/user/marketplace_purchases/stubbed"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_org_memberships(self, state: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of organization memberships for the authenticated user using the "GET" method at the "/user/memberships/orgs" endpoint.

        Args:
            state (string): Indicates the state of the memberships to return. If not specified, the API returns both active and pending memberships.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        url = f"{self.base_url}/user/memberships/orgs"
        query_params = {k: v for k, v in [('state', state), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_user_memberships_org(self, org: str) -> dict[str, Any]:
        """
        Retrieves the authenticated user's membership status for a specified GitHub organization.

        Args:
            org (string): org

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/user/memberships/orgs/{org}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_org_membership(self, org: str, state: str) -> dict[str, Any]:
        """
        Updates the authenticated user's organization membership role for the specified organization.

        Args:
            org (string): org
            state (string): The state that the membership should be in. Only `"active"` will be accepted. Example: 'active'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        request_body_data = None
        request_body_data = {
            'state': state,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/user/memberships/orgs/{org}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_user_migrations(self, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of user migrations using pagination, allowing users to view their migration history.

        Args:
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            migrations
        """
        url = f"{self.base_url}/user/migrations"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_user_migration(self, repositories: List[str], lock_repositories: Optional[bool] = None, exclude_metadata: Optional[bool] = None, exclude_git_data: Optional[bool] = None, exclude_attachments: Optional[bool] = None, exclude_releases: Optional[bool] = None, exclude_owner_projects: Optional[bool] = None, org_metadata_only: Optional[bool] = None, exclude: Optional[List[str]] = None) -> dict[str, Any]:
        """
        Initiates user migrations using the "POST" method at the "/user/migrations" endpoint, returning status messages based on the request outcome.

        Args:
            repositories (array): repositories Example: ['octocat/Hello-World'].
            lock_repositories (boolean): Lock the repositories being migrated at the start of the migration Example: 'True'.
            exclude_metadata (boolean): Indicates whether metadata should be excluded and only git source should be included for the migration. Example: 'True'.
            exclude_git_data (boolean): Indicates whether the repository git data should be excluded from the migration. Example: 'True'.
            exclude_attachments (boolean): Do not include attachments in the migration Example: 'True'.
            exclude_releases (boolean): Do not include releases in the migration Example: 'True'.
            exclude_owner_projects (boolean): Indicates whether projects owned by the organization or users should be excluded. Example: 'True'.
            org_metadata_only (boolean): Indicates whether this should only include organization metadata (repositories array should be empty and will ignore other flags). Example: 'True'.
            exclude (array): Exclude attributes from the API response to improve performance Example: "['repositories']".

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            migrations
        """
        request_body_data = None
        request_body_data = {
            'lock_repositories': lock_repositories,
            'exclude_metadata': exclude_metadata,
            'exclude_git_data': exclude_git_data,
            'exclude_attachments': exclude_attachments,
            'exclude_releases': exclude_releases,
            'exclude_owner_projects': exclude_owner_projects,
            'org_metadata_only': org_metadata_only,
            'exclude': exclude,
            'repositories': repositories,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/user/migrations"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_migration_by_id(self, migration_id: str, exclude: Optional[List[str]] = None) -> dict[str, Any]:
        """
        Retrieves the status and details of a specific user migration using the provided migration ID.

        Args:
            migration_id (string): migration_id
            exclude (array): Used to exclude specific properties from the response when retrieving a user migration by ID.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            migrations
        """
        if migration_id is None:
            raise ValueError("Missing required parameter 'migration_id'.")
        url = f"{self.base_url}/user/migrations/{migration_id}"
        query_params = {k: v for k, v in [('exclude', exclude)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_user_migration_archive(self, migration_id: str) -> Any:
        """
        Retrieves the archived user migration data from GitHub using the specified migration ID.

        Args:
            migration_id (string): migration_id

        Returns:
            Any: API response data.

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            migrations
        """
        if migration_id is None:
            raise ValueError("Missing required parameter 'migration_id'.")
        url = f"{self.base_url}/user/migrations/{migration_id}/archive"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_user_migration_archive(self, migration_id: str) -> Any:
        """
        Deletes the user migration archive associated with the specified migration ID.

        Args:
            migration_id (string): migration_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            migrations
        """
        if migration_id is None:
            raise ValueError("Missing required parameter 'migration_id'.")
        url = f"{self.base_url}/user/migrations/{migration_id}/archive"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_repo_lock(self, migration_id: str, repo_name: str) -> Any:
        """
        Unlocks a GitHub repository that was previously locked for migration using the "DELETE" method.

        Args:
            migration_id (string): migration_id
            repo_name (string): repo_name

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            migrations
        """
        if migration_id is None:
            raise ValueError("Missing required parameter 'migration_id'.")
        if repo_name is None:
            raise ValueError("Missing required parameter 'repo_name'.")
        url = f"{self.base_url}/user/migrations/{migration_id}/repos/{repo_name}/lock"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_migration_repositories(self, migration_id: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of repositories associated with a user's migration using the specified migration ID.

        Args:
            migration_id (string): migration_id
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            migrations
        """
        if migration_id is None:
            raise ValueError("Missing required parameter 'migration_id'.")
        url = f"{self.base_url}/user/migrations/{migration_id}/repositories"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_user_orgs(self, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of organizations associated with a user using the specified page and per-page parameters.

        Args:
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        url = f"{self.base_url}/user/orgs"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_packages(self, package_type: str, visibility: Optional[str] = None, page: Optional[int] = None, per_page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of user packages filtered by package type and visibility, with options for pagination.

        Args:
            package_type (string): The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
            visibility (string): The selected visibility of the packages.  This parameter is optional and only filters an existing result set.

        The `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`.
        For the list of GitHub Packages registries that support granular permissions, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        url = f"{self.base_url}/user/packages"
        query_params = {k: v for k, v in [('package_type', package_type), ('visibility', visibility), ('page', page), ('per_page', per_page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_user_package_by_type_name(self, package_type: str, package_name: str) -> dict[str, Any]:
        """
        Retrieves information about a specific package based on the package type and name using the GET method.

        Args:
            package_type (string): package_type
            package_name (string): package_name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        if package_type is None:
            raise ValueError("Missing required parameter 'package_type'.")
        if package_name is None:
            raise ValueError("Missing required parameter 'package_name'.")
        url = f"{self.base_url}/user/packages/{package_type}/{package_name}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_package_by_name(self, package_type: str, package_name: str) -> Any:
        """
        Deletes a specific user package by type and name using the DELETE method at the "/user/packages/{package_type}/{package_name}" path.

        Args:
            package_type (string): package_type
            package_name (string): package_name

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        if package_type is None:
            raise ValueError("Missing required parameter 'package_type'.")
        if package_name is None:
            raise ValueError("Missing required parameter 'package_name'.")
        url = f"{self.base_url}/user/packages/{package_type}/{package_name}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def restore_user_package_by_type_name(self, package_type: str, package_name: str, token: Optional[str] = None) -> Any:
        """
        Restores a specified package for the authenticated user using a provided token.

        Args:
            package_type (string): package_type
            package_name (string): package_name
            token (string): package token

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        if package_type is None:
            raise ValueError("Missing required parameter 'package_type'.")
        if package_name is None:
            raise ValueError("Missing required parameter 'package_name'.")
        request_body_data = None
        url = f"{self.base_url}/user/packages/{package_type}/{package_name}/restore"
        query_params = {k: v for k, v in [('token', token)] if v is not None}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_package_versions(self, package_type: str, package_name: str, page: Optional[int] = None, per_page: Optional[int] = None, state: Optional[str] = None) -> list[Any]:
        """
        Retrieves a list of versions for a specific package type and name, optionally filtered by state and paginated.

        Args:
            package_type (string): package_type
            package_name (string): package_name
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            state (string): The state of the package, either active or deleted.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        if package_type is None:
            raise ValueError("Missing required parameter 'package_type'.")
        if package_name is None:
            raise ValueError("Missing required parameter 'package_name'.")
        url = f"{self.base_url}/user/packages/{package_type}/{package_name}/versions"
        query_params = {k: v for k, v in [('page', page), ('per_page', per_page), ('state', state)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_user_package_version_by_id(self, package_type: str, package_name: str, package_version_id: str) -> dict[str, Any]:
        """
        Retrieves specific version details for a package based on type, name, and version ID.

        Args:
            package_type (string): package_type
            package_name (string): package_name
            package_version_id (string): package_version_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        if package_type is None:
            raise ValueError("Missing required parameter 'package_type'.")
        if package_name is None:
            raise ValueError("Missing required parameter 'package_name'.")
        if package_version_id is None:
            raise ValueError("Missing required parameter 'package_version_id'.")
        url = f"{self.base_url}/user/packages/{package_type}/{package_name}/versions/{package_version_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_package_version_by_id(self, package_type: str, package_name: str, package_version_id: str) -> Any:
        """
        Deletes a specific package version from the user's package registry.

        Args:
            package_type (string): package_type
            package_name (string): package_name
            package_version_id (string): package_version_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        if package_type is None:
            raise ValueError("Missing required parameter 'package_type'.")
        if package_name is None:
            raise ValueError("Missing required parameter 'package_name'.")
        if package_version_id is None:
            raise ValueError("Missing required parameter 'package_version_id'.")
        url = f"{self.base_url}/user/packages/{package_type}/{package_name}/versions/{package_version_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def restore_user_package_version(self, package_type: str, package_name: str, package_version_id: str) -> Any:
        """
        Restores a specific version of a user's package from the deleted state using the GitHub API.

        Args:
            package_type (string): package_type
            package_name (string): package_name
            package_version_id (string): package_version_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        if package_type is None:
            raise ValueError("Missing required parameter 'package_type'.")
        if package_name is None:
            raise ValueError("Missing required parameter 'package_name'.")
        if package_version_id is None:
            raise ValueError("Missing required parameter 'package_version_id'.")
        request_body_data = None
        url = f"{self.base_url}/user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_project(self, name: str, body: Optional[str] = None) -> dict[str, Any]:
        """
        Adds a user to one or more projects using the API and returns relevant status messages based on the HTTP response codes, such as successful creation, unauthorized access, or validation errors.

        Args:
            name (string): Name of the project Example: 'Week One Sprint'.
            body (string): Body of the project Example: 'This project represents the sprint of the first week in January'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            projects
        """
        request_body_data = None
        request_body_data = {
            'name': name,
            'body': body,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/user/projects"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_public_emails(self, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of publicly visible email addresses for the user.

        Args:
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        url = f"{self.base_url}/user/public_emails"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_user_repos(self, visibility: Optional[str] = None, affiliation: Optional[str] = None, type: Optional[str] = None, sort: Optional[str] = None, direction: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None, since: Optional[str] = None, before: Optional[str] = None) -> list[Any]:
        """
        Lists and retrieves the repositories owned by the authenticated user, allowing filtering by visibility, affiliation, type, and sorting options using the GitHub API.

        Args:
            visibility (string): Limit results to repositories with the specified visibility.
            affiliation (string): Comma-separated list of values. Can include: * `owner`: Repositories that are owned by the authenticated user. * `collaborator`: Repositories that the user has been added to as a collaborator. * `organization_member`: Repositories that the user has access to through being a member of an organization. This includes every repository on every team that the user is on.
            type (string): Limit results to repositories of the specified type. Will cause a `422` error if used in the same request as **visibility** or **affiliation**.
            sort (string): The property to sort the results by.
            direction (string): The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            since (string): Only show repositories updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            before (string): Only show repositories updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        url = f"{self.base_url}/user/repos"
        query_params = {k: v for k, v in [('visibility', visibility), ('affiliation', affiliation), ('type', type), ('sort', sort), ('direction', direction), ('per_page', per_page), ('page', page), ('since', since), ('before', before)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_user_repo(self, name: str, description: Optional[str] = None, homepage: Optional[str] = None, private: Optional[bool] = None, has_issues: Optional[bool] = None, has_projects: Optional[bool] = None, has_wiki: Optional[bool] = None, has_discussions: Optional[bool] = None, team_id: Optional[int] = None, auto_init: Optional[bool] = None, gitignore_template: Optional[str] = None, license_template: Optional[str] = None, allow_squash_merge: Optional[bool] = None, allow_merge_commit: Optional[bool] = None, allow_rebase_merge: Optional[bool] = None, allow_auto_merge: Optional[bool] = None, delete_branch_on_merge: Optional[bool] = None, squash_merge_commit_title: Optional[str] = None, squash_merge_commit_message: Optional[str] = None, merge_commit_title: Optional[str] = None, merge_commit_message: Optional[str] = None, has_downloads: Optional[bool] = None, is_template: Optional[bool] = None) -> dict[str, Any]:
        """
        Creates a new repository for the authenticated user on GitHub and returns the repository details upon success.

        Args:
            name (string): The name of the repository. Example: 'Team Environment'.
            description (string): A short description of the repository. Example: 'This is your first repo!'.
            homepage (string): A URL with more information about the repository. Example: 'https://github.com'.
            private (boolean): Whether the repository is private. Example: False.
            has_issues (boolean): Whether issues are enabled. Example: 'True'.
            has_projects (boolean): Whether projects are enabled. Example: 'True'.
            has_wiki (boolean): Whether the wiki is enabled. Example: 'True'.
            has_discussions (boolean): Whether discussions are enabled. Example: 'True'.
            team_id (integer): The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.
            auto_init (boolean): Whether the repository is initialized with a minimal README.
            gitignore_template (string): The desired language or platform to apply to the .gitignore. Example: 'Haskell'.
            license_template (string): The license keyword of the open source license for this repository. Example: 'mit'.
            allow_squash_merge (boolean): Whether to allow squash merges for pull requests. Example: 'True'.
            allow_merge_commit (boolean): Whether to allow merge commits for pull requests. Example: 'True'.
            allow_rebase_merge (boolean): Whether to allow rebase merges for pull requests. Example: 'True'.
            allow_auto_merge (boolean): Whether to allow Auto-merge to be used on pull requests. Example: 'False'.
            delete_branch_on_merge (boolean): Whether to delete head branches when pull requests are merged Example: 'False'.
            squash_merge_commit_title (string): Required when using `squash_merge_commit_message`.

        The default value for a squash merge commit title:

        - `PR_TITLE` - default to the pull request's title.
        - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
            squash_merge_commit_message (string): The default value for a squash merge commit message:

        - `PR_BODY` - default to the pull request's body.
        - `COMMIT_MESSAGES` - default to the branch's commit messages.
        - `BLANK` - default to a blank commit message.
            merge_commit_title (string): Required when using `merge_commit_message`.

        The default value for a merge commit title.

        - `PR_TITLE` - default to the pull request's title.
        - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
            merge_commit_message (string): The default value for a merge commit message.

        - `PR_TITLE` - default to the pull request's title.
        - `PR_BODY` - default to the pull request's body.
        - `BLANK` - default to a blank commit message.
            has_downloads (boolean): Whether downloads are enabled. Example: 'True'.
            is_template (boolean): Whether this repository acts as a template that can be used to generate new repositories. Example: 'True'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        request_body_data = None
        request_body_data = {
            'name': name,
            'description': description,
            'homepage': homepage,
            'private': private,
            'has_issues': has_issues,
            'has_projects': has_projects,
            'has_wiki': has_wiki,
            'has_discussions': has_discussions,
            'team_id': team_id,
            'auto_init': auto_init,
            'gitignore_template': gitignore_template,
            'license_template': license_template,
            'allow_squash_merge': allow_squash_merge,
            'allow_merge_commit': allow_merge_commit,
            'allow_rebase_merge': allow_rebase_merge,
            'allow_auto_merge': allow_auto_merge,
            'delete_branch_on_merge': delete_branch_on_merge,
            'squash_merge_commit_title': squash_merge_commit_title,
            'squash_merge_commit_message': squash_merge_commit_message,
            'merge_commit_title': merge_commit_title,
            'merge_commit_message': merge_commit_message,
            'has_downloads': has_downloads,
            'is_template': is_template,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/user/repos"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_repository_invitations(self, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves the authenticated user's pending repository invitations using pagination parameters for page and results per page.

        Args:
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        url = f"{self.base_url}/user/repository_invitations"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def update_invitation(self, invitation_id: str) -> Any:
        """
        Updates a specific repository invitation using the GitHub API.

        Args:
            invitation_id (string): invitation_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if invitation_id is None:
            raise ValueError("Missing required parameter 'invitation_id'.")
        request_body_data = None
        url = f"{self.base_url}/user/repository_invitations/{invitation_id}"
        query_params = {}
        response = self._patch(url, data=request_body_data, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_repository_invitation(self, invitation_id: str) -> Any:
        """
        Deletes a repository invitation using the GitHub API, returning an appropriate status code based on the outcome.

        Args:
            invitation_id (string): invitation_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if invitation_id is None:
            raise ValueError("Missing required parameter 'invitation_id'.")
        url = f"{self.base_url}/user/repository_invitations/{invitation_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_social_accounts(self, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of a user's social accounts using the GET method, allowing pagination with per-page and page parameters.

        Args:
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        url = f"{self.base_url}/user/social_accounts"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_social_account(self, account_urls: List[str]) -> list[Any]:
        """
        Adds social media accounts to the authenticated user's GitHub profile using provided URLs and returns a success status upon creation.

        Args:
            account_urls (array): Full URLs for the social media profiles to add. Example: '[]'.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        request_body_data = None
        request_body_data = {
            'account_urls': account_urls,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/user/social_accounts"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_social_accounts(self, account_urls: List[str]) -> Any:
        """
        Deletes specified social media accounts linked to the authenticated user's GitHub profile.

        Args:
            account_urls (array): Full URLs for the social media profiles to delete. Example: '[]'.

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        request_body_data = {
            'account_urls': account_urls,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/user/social_accounts"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_ssh_signing_keys(self, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves SSH signing keys for the authenticated user, supporting pagination via per-page and page parameters.

        Args:
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        url = f"{self.base_url}/user/ssh_signing_keys"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def create_user_ssh_signing_key(self, key: str, title: Optional[str] = None) -> dict[str, Any]:
        """
        Creates an SSH signing key for the authenticated user's GitHub account using the "POST" method.

        Args:
            key (string): The public SSH key to add to your GitHub account. For more information, see "[Checking for existing SSH keys](https://docs.github.com/authentication/connecting-to-github-with-ssh/checking-for-existing-ssh-keys)." Example: '2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvv1234'.
            title (string): A descriptive name for the new key. Example: 'Personal MacBook Air'.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        request_body_data = None
        request_body_data = {
            'title': title,
            'key': key,
        }
        request_body_data = {k: v for k, v in request_body_data.items() if v is not None}
        url = f"{self.base_url}/user/ssh_signing_keys"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_ssh_signing_key(self, ssh_signing_key_id: str) -> dict[str, Any]:
        """
        Retrieves extended details for a specific SSH signing key associated with a GitHub user account.

        Args:
            ssh_signing_key_id (string): ssh_signing_key_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        if ssh_signing_key_id is None:
            raise ValueError("Missing required parameter 'ssh_signing_key_id'.")
        url = f"{self.base_url}/user/ssh_signing_keys/{ssh_signing_key_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_user_ssh_signing_key(self, ssh_signing_key_id: str) -> Any:
        """
        Deletes an SSH signing key from a GitHub user account using the GitHub API.

        Args:
            ssh_signing_key_id (string): ssh_signing_key_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        if ssh_signing_key_id is None:
            raise ValueError("Missing required parameter 'ssh_signing_key_id'.")
        url = f"{self.base_url}/user/ssh_signing_keys/{ssh_signing_key_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_starred_users(self, sort: Optional[str] = None, direction: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of repositories starred by the authenticated user, optionally filtered by sort order and pagination parameters.

        Args:
            sort (string): The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to.
            direction (string): The direction to sort the results by.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        url = f"{self.base_url}/user/starred"
        query_params = {k: v for k, v in [('sort', sort), ('direction', direction), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_user_starred_repo(self, owner: str, repo: str) -> Any:
        """
        Retrieves information about whether a specific repository is starred by the authenticated user using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            Any: Response if this repository is starred by you

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/user/starred/{owner}/{repo}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def star_repo_for_user(self, owner: str, repo: str) -> Any:
        """
        Stars a GitHub repository for the authenticated user using the GitHub API.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        request_body_data = None
        url = f"{self.base_url}/user/starred/{owner}/{repo}"
        query_params = {}
        response = self._put(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_starred_repo(self, owner: str, repo: str) -> Any:
        """
        Unstars a GitHub repository using the GitHub API by deleting a star that the authenticated user previously applied to a specified repository owned by `{owner}` and named `{repo}`, returning status messages based on the operation's outcome.

        Args:
            owner (string): owner
            repo (string): repo

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        if owner is None:
            raise ValueError("Missing required parameter 'owner'.")
        if repo is None:
            raise ValueError("Missing required parameter 'repo'.")
        url = f"{self.base_url}/user/starred/{owner}/{repo}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_user_subscriptions(self, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of user subscriptions using pagination.

        Args:
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        url = f"{self.base_url}/user/subscriptions"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_user_teams(self, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of teams associated with a user using the API at the "/user/teams" endpoint with pagination options.

        Args:
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            teams
        """
        url = f"{self.base_url}/user/teams"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def users_get_by_id(self, account_id: str) -> Any:
        """
        Retrieves user details for the specified account ID.

        Args:
            account_id (string): account_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        if account_id is None:
            raise ValueError("Missing required parameter 'account_id'.")
        url = f"{self.base_url}/user/{account_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def users_list(self, since: Optional[int] = None, per_page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of users, filtered by the specified parameters.

        Args:
            since (integer): A user ID. Only return users with an ID greater than this ID.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        url = f"{self.base_url}/users"
        query_params = {k: v for k, v in [('since', since), ('per_page', per_page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def users_get_by_username(self, username: str) -> Any:
        """
        Retrieves user information based on the provided username using the GET method at the "/users/{username}" endpoint.

        Args:
            username (string): username

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/users/{username}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def users_list_attestations(self, username: str, subject_digest: str, per_page: Optional[int] = None, before: Optional[str] = None, after: Optional[str] = None, predicate_type: Optional[str] = None) -> dict[str, Any]:
        """
        Retrieves a list of attestations for a specified user and subject digest, supporting pagination and filtering by predicate type.

        Args:
            username (string): username
            subject_digest (string): subject_digest
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            before (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            after (string): A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            predicate_type (string): Optional filter for fetching attestations with a given predicate type.
        This option accepts `provenance`, `sbom`, or freeform text for custom predicate types.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        if subject_digest is None:
            raise ValueError("Missing required parameter 'subject_digest'.")
        url = f"{self.base_url}/users/{username}/attestations/{subject_digest}"
        query_params = {k: v for k, v in [('per_page', per_page), ('before', before), ('after', after), ('predicate_type', predicate_type)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_docker_conflicts_by_username(self, username: str) -> list[Any]:
        """
        Retrieves and reports Docker conflicts associated with a specified user, returning access and status codes.

        Args:
            username (string): username

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/users/{username}/docker/conflicts"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_user_events(self, username: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of events associated with a specific user, such as user activity or interactions.

        Args:
            username (string): username
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/users/{username}/events"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_org_events_by_user(self, username: str, org: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of public organization events for a specified user and organization.

        Args:
            username (string): username
            org (string): org
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        if org is None:
            raise ValueError("Missing required parameter 'org'.")
        url = f"{self.base_url}/users/{username}/events/orgs/{org}"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_public_events_by_user(self, username: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of public events for a specified GitHub user using the "GET" method, allowing pagination with parameters such as username, page number, and results per page.

        Args:
            username (string): username
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/users/{username}/events/public"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def users_list_followers_for_user(self, username: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of followers for the specified user.

        Args:
            username (string): username
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/users/{username}/followers"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def users_list_following_for_user(self, username: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of users that the specified user is following.

        Args:
            username (string): username
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/users/{username}/following"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def users_check_following_for_user(self, username: str, target_user: str) -> Any:
        """
        Retrieves whether a user is following another user by fetching the follow status for a specific target user using the GET method.

        Args:
            username (string): username
            target_user (string): target_user

        Returns:
            Any: if the user follows the target user

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        if target_user is None:
            raise ValueError("Missing required parameter 'target_user'.")
        url = f"{self.base_url}/users/{username}/following/{target_user}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def gists_list_for_user(self, username: str, since: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of public gists associated with a specified GitHub user, optionally filtered by creation time and paginated using page size and number parameters.

        Args:
            username (string): username
            since (string): Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            gists
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/users/{username}/gists"
        query_params = {k: v for k, v in [('since', since), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def users_list_gpg_keys_for_user(self, username: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of GPG keys for a specified user using the "GET" method, allowing pagination via optional per-page and page parameters.

        Args:
            username (string): username
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/users/{username}/gpg_keys"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def users_get_context_for_user(self, username: str, subject_type: Optional[str] = None, subject_id: Optional[str] = None) -> dict[str, Any]:
        """
        Retrieves a hovercard, providing contextual information about a user, using the GitHub API at the path "/users/{username}/hovercard" with the "GET" method, optionally specifying subject type and ID.

        Args:
            username (string): username
            subject_type (string): Identifies which additional information you'd like to receive about the person's hovercard. Can be `organization`, `repository`, `issue`, `pull_request`. **Required** when using `subject_id`.
            subject_id (string): Uses the ID for the `subject_type` you specified. **Required** when using `subject_type`.

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/users/{username}/hovercard"
        query_params = {k: v for k, v in [('subject_type', subject_type), ('subject_id', subject_id)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def apps_get_user_installation(self, username: str) -> dict[str, Any]:
        """
        Retrieves a GitHub App installation associated with a specific user account.

        Args:
            username (string): username

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            apps
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/users/{username}/installation"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_user_keys(self, username: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of SSH keys associated with the specified user account.

        Args:
            username (string): username
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/users/{username}/keys"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def orgs_list_for_user(self, username: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of organizations a specific user belongs to via the GitHub API.

        Args:
            username (string): username
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            orgs
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/users/{username}/orgs"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_packages_by_user(self, username: str, package_type: str, visibility: Optional[str] = None, page: Optional[int] = None, per_page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of packages for a specific user using the provided username, with options to filter by package type and visibility, and paginate the results.

        Args:
            username (string): username
            package_type (string): The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.
            visibility (string): The selected visibility of the packages.  This parameter is optional and only filters an existing result set.

        The `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`.
        For the list of GitHub Packages registries that support granular permissions, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/users/{username}/packages"
        query_params = {k: v for k, v in [('package_type', package_type), ('visibility', visibility), ('page', page), ('per_page', per_page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def packages_get_package_for_user(self, username: str, package_type: str, package_name: str) -> dict[str, Any]:
        """
        Retrieves a specific package of a given type associated with the specified user's username.

        Args:
            username (string): username
            package_type (string): package_type
            package_name (string): package_name

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        if package_type is None:
            raise ValueError("Missing required parameter 'package_type'.")
        if package_name is None:
            raise ValueError("Missing required parameter 'package_name'.")
        url = f"{self.base_url}/users/{username}/packages/{package_type}/{package_name}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_package_by_user(self, username: str, package_type: str, package_name: str) -> Any:
        """
        Deletes a package of a specified type and name associated with a given user using the DELETE method.

        Args:
            username (string): username
            package_type (string): package_type
            package_name (string): package_name

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        if package_type is None:
            raise ValueError("Missing required parameter 'package_type'.")
        if package_name is None:
            raise ValueError("Missing required parameter 'package_name'.")
        url = f"{self.base_url}/users/{username}/packages/{package_type}/{package_name}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def restore_user_package(self, username: str, package_type: str, package_name: str, token: Optional[str] = None) -> Any:
        """
        Restores a specific package using the POST method at the "/users/{username}/packages/{package_type}/{package_name}/restore" endpoint.

        Args:
            username (string): username
            package_type (string): package_type
            package_name (string): package_name
            token (string): package token

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        if package_type is None:
            raise ValueError("Missing required parameter 'package_type'.")
        if package_name is None:
            raise ValueError("Missing required parameter 'package_name'.")
        request_body_data = None
        url = f"{self.base_url}/users/{username}/packages/{package_type}/{package_name}/restore"
        query_params = {k: v for k, v in [('token', token)] if v is not None}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_user_package_versions(self, username: str, package_type: str, package_name: str) -> list[Any]:
        """
        Retrieves the versions of a specific package for a user using the provided username, package type, and package name, returning the result in response to a GET request.

        Args:
            username (string): username
            package_type (string): package_type
            package_name (string): package_name

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        if package_type is None:
            raise ValueError("Missing required parameter 'package_type'.")
        if package_name is None:
            raise ValueError("Missing required parameter 'package_name'.")
        url = f"{self.base_url}/users/{username}/packages/{package_type}/{package_name}/versions"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_package_version_details(self, username: str, package_type: str, package_name: str, package_version_id: str) -> dict[str, Any]:
        """
        Retrieves package version details for a specified package name and version under a user's account using the "GET" method.

        Args:
            username (string): username
            package_type (string): package_type
            package_name (string): package_name
            package_version_id (string): package_version_id

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        if package_type is None:
            raise ValueError("Missing required parameter 'package_type'.")
        if package_name is None:
            raise ValueError("Missing required parameter 'package_name'.")
        if package_version_id is None:
            raise ValueError("Missing required parameter 'package_version_id'.")
        url = f"{self.base_url}/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def delete_user_package_version(self, username: str, package_type: str, package_name: str, package_version_id: str) -> Any:
        """
        Deletes a specific version of a package associated with a user, identified by the package type, name, and version ID, using the DELETE method.

        Args:
            username (string): username
            package_type (string): package_type
            package_name (string): package_name
            package_version_id (string): package_version_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        if package_type is None:
            raise ValueError("Missing required parameter 'package_type'.")
        if package_name is None:
            raise ValueError("Missing required parameter 'package_name'.")
        if package_version_id is None:
            raise ValueError("Missing required parameter 'package_version_id'.")
        url = f"{self.base_url}/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
        query_params = {}
        response = self._delete(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def restore_package_version(self, username: str, package_type: str, package_name: str, package_version_id: str) -> Any:
        """
        Restores a specific package version of a given package type for a user, using the POST method, by moving it back from an archived or deleted state to its original location.

        Args:
            username (string): username
            package_type (string): package_type
            package_name (string): package_name
            package_version_id (string): package_version_id

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            packages
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        if package_type is None:
            raise ValueError("Missing required parameter 'package_type'.")
        if package_name is None:
            raise ValueError("Missing required parameter 'package_name'.")
        if package_version_id is None:
            raise ValueError("Missing required parameter 'package_version_id'.")
        request_body_data = None
        url = f"{self.base_url}/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
        query_params = {}
        response = self._post(url, data=request_body_data, params=query_params, content_type='application/json')
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def projects_list_for_user(self, username: str, state: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of projects for a specified user, filtered by optional state, with pagination options.

        Args:
            username (string): username
            state (string): Indicates the state of the projects to return.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            projects
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/users/{username}/projects"
        query_params = {k: v for k, v in [('state', state), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_received_events_for_user(self, username: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of events received by a specified GitHub user using the "GET" method, allowing for pagination through recent activity.

        Args:
            username (string): username
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/users/{username}/received_events"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_user_public_received_events(self, username: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of public events received by a specified GitHub user account, including pagination support.

        Args:
            username (string): username
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/users/{username}/received_events/public"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def repos_list_for_user(self, username: str, type: Optional[str] = None, sort: Optional[str] = None, direction: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of repositories for a specified GitHub user using the "GET" method, allowing for filtering by repository type, sorting, and pagination.

        Args:
            username (string): username
            type (string): Limit results to repositories of the specified type.
            sort (string): The property to sort the results by.
            direction (string): The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            repos
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/users/{username}/repos"
        query_params = {k: v for k, v in [('type', type), ('sort', sort), ('direction', direction), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_billing_actions_by_user(self, username: str) -> dict[str, Any]:
        """
        Retrieves billing actions for a specific user using the provided username.

        Args:
            username (string): username

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            billing
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/users/{username}/settings/billing/actions"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_user_billing_packages(self, username: str) -> dict[str, Any]:
        """
        Retrieves billing package information for a specified user.

        Args:
            username (string): username

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            billing
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/users/{username}/settings/billing/packages"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_shared_storage_settings(self, username: str) -> dict[str, Any]:
        """
        Retrieves a user's shared storage billing settings for the specified username.

        Args:
            username (string): username

        Returns:
            dict[str, Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            billing
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/users/{username}/settings/billing/shared-storage"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_billing_usage(self, username: str, year: Optional[int] = None, month: Optional[int] = None, day: Optional[int] = None, hour: Optional[int] = None) -> dict[str, Any]:
        """
        Retrieves billing usage details for a specified user with parameters for year, month, day, and hour.

        Args:
            username (string): username
            year (integer): If specified, only return results for a single year. The value of `year` is an integer with four digits representing a year. For example, `2025`. Default value is the current year.
            month (integer): If specified, only return results for a single month. The value of `month` is an integer between `1` and `12`. If no year is specified the default `year` is used.
            day (integer): If specified, only return results for a single day. The value of `day` is an integer between `1` and `31`. If no `year` or `month` is specified, the default `year` and `month` are used.
            hour (integer): If specified, only return results for a single hour. The value of `hour` is an integer between `0` and `23`. If no `year`, `month`, or `day` is specified, the default `year`, `month`, and `day` are used.

        Returns:
            dict[str, Any]: Response when getting a billing usage report

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            billing
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/users/{username}/settings/billing/usage"
        query_params = {k: v for k, v in [('year', year), ('month', month), ('day', day), ('hour', hour)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_social_accounts_by_user(self, username: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of social accounts for a specific user using the "GET" method, allowing pagination through optional per-page and page parameters.

        Args:
            username (string): username
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/users/{username}/social_accounts"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_user_ssh_signing_keys(self, username: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a list of SSH signing keys associated with the specified GitHub user account.

        Args:
            username (string): username
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            users
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/users/{username}/ssh_signing_keys"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def get_user_starred_repositories(self, username: str, sort: Optional[str] = None, direction: Optional[str] = None, per_page: Optional[int] = None, page: Optional[int] = None) -> Any:
        """
        Retrieves a list of repositories starred by a specified GitHub user, allowing pagination and sorting of the results.

        Args:
            username (string): username
            sort (string): The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to.
            direction (string): The direction to sort the results by.
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/users/{username}/starred"
        query_params = {k: v for k, v in [('sort', sort), ('direction', direction), ('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_user_subscriptions(self, username: str, per_page: Optional[int] = None, page: Optional[int] = None) -> list[Any]:
        """
        Retrieves a paginated list of subscriptions for the specified username.

        Args:
            username (string): username
            per_page (integer): The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
            page (integer): The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            activity
        """
        if username is None:
            raise ValueError("Missing required parameter 'username'.")
        url = f"{self.base_url}/users/{username}/subscriptions"
        query_params = {k: v for k, v in [('per_page', per_page), ('page', page)] if v is not None}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def meta_get_all_versions(self) -> list[Any]:
        """
        Retrieves a list of available versions supported by the API.

        Returns:
            list[Any]: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            meta
        """
        url = f"{self.base_url}/versions"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def meta_get_zen(self) -> Any:
        """
        Retrieves data at the "/zen" path using the "GET" method.

        Returns:
            Any: Response

        Raises:
            HTTPError: Raised when the API request fails (e.g., non-2XX status code).
            JSONDecodeError: Raised if the response body cannot be parsed as JSON.

        Tags:
            meta
        """
        url = f"{self.base_url}/zen"
        query_params = {}
        response = self._get(url, params=query_params)
        response.raise_for_status()
        if response.status_code == 204 or not response.content or not response.text.strip():
            return None
        try:
            return response.json()
        except ValueError:
            return None

    def list_tools(self):
        return [
            self.star_repository,
            self.list_commits,
            self.list_branches,
            self.list_pull_requests,
            self.list_issues,
            self.get_pull_request,
            self.create_pull_request,
            self.create_issue,
            self.update_issue,
            self.list_repo_activities,
            # Auto Generated from open api spec
            self.meta_root,
            self.list_advisories,
            self.get_advisory_by_id,
            self.apps_get_authenticated,
            self.apps_create_from_manifest,
            self.get_app_hook_config,
            self.update_hook_config,
            self.apps_list_webhook_deliveries,
            self.apps_get_webhook_delivery,
            self.add_delivery_attempt,
            self.get_installation_requests,
            self.apps_list_installations,
            self.apps_get_installation,
            self.apps_delete_installation,
            self.create_access_token,
            self.apps_suspend_installation,
            self.apps_unsuspend_installation,
            self.apps_delete_authorization,
            self.apps_check_token,
            self.apps_reset_token,
            self.apps_delete_token,
            self.apps_scope_token,
            self.apps_get_by_slug,
            self.classroom_get_an_assignment,
            self.get_accepted_assignments_by_id,
            self.get_assignment_grades,
            self.classroom_list_classrooms,
            self.classroom_get_a_classroom,
            self.list_classroom_assignments,
            self.list_codes_of_conduct,
            self.get_conduct_by_key,
            self.credentials_revoke,
            self.emojis_get,
            self.fetch_enterprise_code_sec_config,
            self.create_code_security_config,
            self.get_enterprise_security_defaults,
            self.get_enterprise_config,
            self.update_code_security_config,
            self.delete_configuration_by_id,
            self.attach_configuration,
            self.update_code_security_defaults,
            self.get_repo_config,
            self.list_enterprise_dependabot_alerts,
            self.list_enterprise_secret_alerts,
            self.activity_list_public_events,
            self.activity_get_feeds,
            self.gists_list,
            self.gists_create,
            self.gists_list_public,
            self.gists_list_starred,
            self.gists_get,
            self.gists_update,
            self.gists_delete,
            self.gists_list_comments,
            self.gists_create_comment,
            self.gists_get_comment,
            self.gists_update_comment,
            self.gists_delete_comment,
            self.gists_list_commits,
            self.gists_list_forks,
            self.gists_fork,
            self.gists_check_is_starred,
            self.gists_star,
            self.gists_unstar,
            self.gists_get_revision,
            self.gitignore_get_all_templates,
            self.gitignore_get_template,
            self.get_installation_repositories,
            self.delete_installation_token,
            self.issues_list,
            self.licenses_get_all_commonly_used,
            self.licenses_get,
            self.markdown_render,
            self.markdown_render_raw,
            self.get_account_details,
            self.apps_list_plans,
            self.apps_list_accounts_for_plan,
            self.get_stubbed_account,
            self.apps_list_plans_stubbed,
            self.get_plan_accounts,
            self.meta_get,
            self.get_network_repo_events,
            self.get_notifications,
            self.update_notification,
            self.activity_get_thread,
            self.activity_mark_thread_as_read,
            self.activity_mark_thread_as_done,
            self.get_thread_subscription,
            self.update_thread_subscription,
            self.unsubscribe_thread,
            self.meta_get_octocat,
            self.orgs_list,
            self.get_org_billing_usage,
            self.orgs_get,
            self.orgs_update,
            self.orgs_delete,
            self.get_org_cache_usage,
            self.get_org_cache_usage_by_repo,
            self.get_org_hosted_runners,
            self.create_hosted_runner,
            self.get_org_images,
            self.list_hosted_images_by_org_id,
            self.get_org_runner_limits,
            self.get_org_actions_hosted_runner_sizes,
            self.list_hosted_platforms,
            self.get_hosted_runner_by_id,
            self.patch_org_hosted_runner,
            self.delete_hosted_runner_by_id,
            self.get_oidc_customization_sub,
            self.update_org_oidc_customization,
            self.get_org_permissions,
            self.update_org_permissions,
            self.get_org_repo_permissions,
            self.update_org_repo_permissions,
            self.update_repo_permissions,
            self.delete_org_repo_permission,
            self.list_org_actions,
            self.update_org_actions_permissions,
            self.get_org_workflow_permissions,
            self.update_org_workflow_permissions,
            self.list_runner_groups,
            self.create_runner_group,
            self.get_runner_group,
            self.patch_org_runner_group,
            self.delete_runner_group,
            self.get_org_runner_group_hosted_runners,
            self.get_org_runner_group_repos,
            self.update_runner_group_repo,
            self.update_runner_group_repository,
            self.delete_repo_from_runner_group,
            self.get_org_runner_group_runners,
            self.update_runner_group_runners,
            self.update_runner_group_runner_by_id,
            self.delete_runner,
            self.list_org_runners,
            self.get_org_runner_downloads,
            self.generate_jit_config,
            self.register_runner_token,
            self.remove_org_token,
            self.get_runner_info,
            self.delete_runner_by_id,
            self.get_org_runner_labels,
            self.add_runner_labels,
            self.update_runner_labels,
            self.delete_runner_label,
            self.delete_label_by_runner_id,
            self.actions_list_org_secrets,
            self.actions_get_org_public_key,
            self.actions_get_org_secret,
            self.update_secret,
            self.actions_delete_org_secret,
            self.get_org_secret_repositories,
            self.put_org_secret_repo_access,
            self.update_secret_repo,
            self.delete_org_secret_repo_by_id,
            self.actions_list_org_variables,
            self.actions_create_org_variable,
            self.actions_get_org_variable,
            self.actions_update_org_variable,
            self.actions_delete_org_variable,
            self.get_org_variable_repos,
            self.update_variable_repository,
            self.update_org_action_variable_repo,
            self.delete_repository_variable,
            self.orgs_list_attestations,
            self.orgs_list_blocked_users,
            self.orgs_check_blocked_user,
            self.orgs_block_user,
            self.orgs_unblock_user,
            self.campaigns_list_org_campaigns,
            self.campaigns_create_campaign,
            self.campaigns_get_campaign_summary,
            self.campaigns_update_campaign,
            self.campaigns_delete_campaign,
            self.list_org_code_scanning_alerts,
            self.get_org_code_configurations,
            self.create_org_code_config,
            self.get_org_code_security_defaults,
            self.detach_code_security_config,
            self.get_org_config_by_id,
            self.patch_org_code_security_config,
            self.delete_code_security_config,
            self.attach_code_config,
            self.set_default_code_security_config,
            self.get_org_repo_config,
            self.get_org_codespaces,
            self.update_org_codespaces_access,
            self.select_codespace_users,
            self.delete_selected_users_access,
            self.codespaces_list_org_secrets,
            self.codespaces_get_org_public_key,
            self.codespaces_get_org_secret,
            self.put_org_codespace_secret,
            self.codespaces_delete_org_secret,
            self.get_org_codespace_secret_repos,
            self.put_org_codespace_secret_repo,
            self.update_org_secret_repository,
            self.delete_org_secret_repo,
            self.get_org_billing,
            self.copilot_list_copilot_seats,
            self.select_teams_for_billing,
            self.unselect_teams,
            self.select_copilot_billing_users,
            self.delete_selected_users,
            self.get_org_metrics,
            self.dependabot_list_alerts_for_org,
            self.dependabot_list_org_secrets,
            self.dependabot_get_org_public_key,
            self.dependabot_get_org_secret,
            self.update_dependabot_secret,
            self.dependabot_delete_org_secret,
            self.list_secret_repos,
            self.put_dependabot_secret_repos,
            self.put_dependabot_secret_repo_access,
            self.delete_dependabot_secret_repo,
            self.get_org_docker_conflicts,
            self.get_org_events,
            self.orgs_list_failed_invitations,
            self.orgs_list_webhooks,
            self.orgs_create_webhook,
            self.orgs_get_webhook,
            self.orgs_update_webhook,
            self.orgs_delete_webhook,
            self.get_hook_config,
            self.patch_org_hook_config,
            self.orgs_list_webhook_deliveries,
            self.orgs_get_webhook_delivery,
            self.retry_delivery_attempt,
            self.orgs_ping_webhook,
            self.get_route_stats_by_actor,
            self.api_insights_get_subject_stats,
            self.api_insights_get_summary_stats,
            self.get_org_user_summary_stats,
            self.get_org_summary_stats,
            self.api_insights_get_time_stats,
            self.get_user_time_stats,
            self.get_org_insights_time_stats_by_actor,
            self.api_insights_get_user_stats,
            self.apps_get_org_installation,
            self.orgs_list_app_installations,
            self.get_org_interaction_limits,
            self.update_interaction_limits,
            self.delete_org_interaction_limits,
            self.orgs_list_pending_invitations,
            self.orgs_create_invitation,
            self.orgs_cancel_invitation,
            self.orgs_list_invitation_teams,
            self.orgs_list_issue_types,
            self.orgs_create_issue_type,
            self.orgs_update_issue_type,
            self.orgs_delete_issue_type,
            self.issues_list_for_org,
            self.orgs_list_members,
            self.orgs_check_membership_for_user,
            self.orgs_remove_member,
            self.get_org_member_codespaces,
            self.delete_org_member_codespace,
            self.stop_codespace,
            self.get_org_member_copilot,
            self.orgs_get_membership_for_user,
            self.orgs_set_membership_for_user,
            self.delete_org_membership_by_username,
            self.migrations_list_for_org,
            self.migrations_start_for_org,
            self.migrations_get_status_for_org,
            self.get_org_migration_archive,
            self.delete_migration_archive_by_org,
            self.migrations_unlock_repo_for_org,
            self.migrations_list_repos_for_org,
            self.orgs_list_org_roles,
            self.orgs_revoke_all_org_roles_team,
            self.orgs_assign_team_to_org_role,
            self.orgs_revoke_org_role_team,
            self.orgs_revoke_all_org_roles_user,
            self.orgs_assign_user_to_org_role,
            self.orgs_revoke_org_role_user,
            self.orgs_get_org_role,
            self.orgs_list_org_role_teams,
            self.orgs_list_org_role_users,
            self.get_org_outside_collaborators,
            self.update_outside_collaborator,
            self.delete_outside_collaborator,
            self.list_org_packages,
            self.get_package_details,
            self.delete_package,
            self.restore_package,
            self.get_org_package_versions,
            self.get_package_version,
            self.delete_package_version,
            self.restore_package_versionfrombin,
            self.orgs_list_pat_grant_requests,
            self.create_org_pat_request,
            self.orgs_review_pat_grant_request,
            self.get_pat_request_repositories,
            self.orgs_list_pat_grants,
            self.orgs_update_pat_accesses,
            self.orgs_update_pat_access,
            self.get_pat_repositories,
            self.get_org_private_registries,
            self.create_private_registry,
            self.get_org_private_registry_public_key,
            self.get_private_registry_secret,
            self.update_secret_registry,
            self.delete_secret_registry,
            self.projects_list_for_org,
            self.projects_create_for_org,
            self.orgs_get_all_custom_properties,
            self.update_org_schema,
            self.orgs_get_custom_property,
            self.update_custom_property_schema,
            self.orgs_remove_custom_property,
            self.get_org_property_values,
            self.patch_org_properties_values,
            self.orgs_list_public_members,
            self.get_org_public_member_by_username,
            self.update_org_member,
            self.delete_org_public_member,
            self.repos_list_for_org,
            self.repos_create_in_org,
            self.repos_get_org_rulesets,
            self.repos_create_org_ruleset,
            self.repos_get_org_rule_suites,
            self.repos_get_org_rule_suite,
            self.repos_get_org_ruleset,
            self.repos_update_org_ruleset,
            self.repos_delete_org_ruleset,
            self.orgs_get_org_ruleset_history,
            self.orgs_get_org_ruleset_version,
            self.list_org_secret_scanning_alerts,
            self.get_org_security_advisories,
            self.get_org_security_managers,
            self.orgs_add_security_manager_team,
            self.delete_security_manager_team,
            self.get_org_billing_actions,
            self.get_org_billing_packages,
            self.get_org_billing_shared_storage,
            self.get_org_network_configurations,
            self.create_org_network_configurations,
            self.get_org_network_config_by_id,
            self.update_network_configuration,
            self.delete_network_configuration_by_id,
            self.get_org_network_settings_by_id,
            self.get_team_metrics,
            self.teams_list,
            self.teams_create,
            self.teams_get_by_name,
            self.teams_update_in_org,
            self.teams_delete_in_org,
            self.teams_list_discussions_in_org,
            self.teams_create_discussion_in_org,
            self.teams_get_discussion_in_org,
            self.teams_update_discussion_in_org,
            self.teams_delete_discussion_in_org,
            self.get_discussion_comments_org,
            self.create_comment,
            self.get_comment_details,
            self.update_comment,
            self.delete_team_discussion_comment,
            self.get_comment_reactions,
            self.add_comment_reaction,
            self.delete_reaction,
            self.get_discussion_reactions,
            self.create_team_discussion_reaction,
            self.delete_reaction_by_id,
            self.list_invitations,
            self.teams_list_members_in_org,
            self.get_org_team_membership_by_username,
            self.update_team_membership,
            self.delete_team_membership,
            self.teams_list_projects_in_org,
            self.get_org_team_project,
            self.update_project,
            self.teams_remove_project_in_org,
            self.teams_list_repos_in_org,
            self.get_team_repo_details,
            self.add_team_repo_to_org,
            self.teams_remove_repo_in_org,
            self.teams_list_child_in_org,
            self.enable_security_product,
            self.projects_get_card,
            self.projects_update_card,
            self.projects_delete_card,
            self.projects_move_card,
            self.projects_get_column,
            self.projects_update_column,
            self.projects_delete_column,
            self.projects_list_cards,
            self.projects_create_card,
            self.projects_move_column,
            self.projects_get,
            self.projects_update,
            self.projects_delete,
            self.projects_list_collaborators,
            self.projects_add_collaborator,
            self.projects_remove_collaborator,
            self.get_collaborator_permission,
            self.projects_list_columns,
            self.projects_create_column,
            self.rate_limit_get,
            self.repos_get,
            self.repos_update,
            self.repos_delete,
            self.get_artifacts,
            self.actions_get_artifact,
            self.actions_delete_artifact,
            self.actions_download_artifact,
            self.get_repo_actions_cache_usage,
            self.actions_get_actions_cache_list,
            self.delete_cache,
            self.delete_cache_id,
            self.get_repo_action_job_by_id,
            self.get_repo_actions_job_logs,
            self.rerun_job,
            self.get_customization_sub,
            self.custom_sub_oidc,
            self.get_org_secrets,
            self.list_organization_variables,
            self.get_repo_permissions,
            self.update_repo_actions_permissions,
            self.get_repo_access,
            self.update_repo_access,
            self.get_selected_actions_permissions,
            self.update_actions_permissions,
            self.get_workflow_permissions,
            self.update_workflow_permissions,
            self.get_repo_actions_runners,
            self.get_runner_downloads,
            self.generate_runner_jit_config,
            self.create_runner_registration_token,
            self.remove_runner_token,
            self.get_repo_runner_by_id,
            self.delete_repo_runner_by_id,
            self.get_runner_labels_by_id,
            self.add_runner_label,
            self.set_runner_labels,
            self.delete_runner_labels,
            self.delete_runner_label_by_name,
            self.list_repo_actions_runs,
            self.actions_get_workflow_run,
            self.actions_delete_workflow_run,
            self.actions_get_reviews_for_run,
            self.actions_approve_workflow_run,
            self.get_run_artifacts,
            self.get_attempt_run_details,
            self.get_jobs_by_run_attempt,
            self.get_action_log,
            self.actions_cancel_workflow_run,
            self.create_deployment_rule,
            self.force_cancel_action_run,
            self.get_job_runs,
            self.get_repo_actions_run_logs,
            self.delete_repo_actions_run_logs,
            self.get_pending_deployments,
            self.create_deployment,
            self.actions_re_run_workflow,
            self.rerun_failed_jobs,
            self.actions_get_workflow_run_usage,
            self.actions_list_repo_secrets,
            self.actions_get_repo_public_key,
            self.actions_get_repo_secret,
            self.update_repo_secret_by_name,
            self.actions_delete_repo_secret,
            self.actions_list_repo_variables,
            self.actions_create_repo_variable,
            self.actions_get_repo_variable,
            self.actions_update_repo_variable,
            self.actions_delete_repo_variable,
            self.actions_list_repo_workflows,
            self.actions_get_workflow,
            self.actions_disable_workflow,
            self.dispatch_workflow,
            self.actions_enable_workflow,
            self.actions_list_workflow_runs,
            self.actions_get_workflow_usage,
            self.repos_list_activities,
            self.issues_list_assignees,
            self.get_assignee,
            self.repos_create_attestation,
            self.repos_list_attestations,
            self.repos_list_autolinks,
            self.repos_create_autolink,
            self.repos_get_autolink,
            self.repos_delete_autolink,
            self.get_security_fixes,
            self.enable_automated_security_fixes,
            self.delete_security_fixes,
            self.repos_list_branches,
            self.repos_get_branch,
            self.repos_get_branch_protection,
            self.repos_update_branch_protection,
            self.repos_delete_branch_protection,
            self.get_branch_protection,
            self.enforce_admins_protection,
            self.unprotect_branch_admins,
            self.get_required_reviews,
            self.update_branch_protection,
            self.delete_pull_request_reviews,
            self.get_required_signatures,
            self.enable_branch_signatures,
            self.delete_branch_protection,
            self.get_branch_status_checks,
            self.update_branch_protection_checks,
            self.delete_required_status_checks,
            self.get_branch_protection_contexts,
            self.create_status_context,
            self.update_status_check_contexts,
            self.delete_status_check_contexts,
            self.repos_get_access_restrictions,
            self.delete_branch_restrictions,
            self.get_repo_branch_protection_apps,
            self.add_branch_protection_app,
            self.update_branch_restrictions_apps,
            self.delete_branch_protection_apps,
            self.get_branch_protection_teams,
            self.add_branch_protection_teams,
            self.update_branch_protection_teams,
            self.delete_branch_protection_teams,
            self.get_branch_users,
            self.add_branch_protection_users,
            self.update_branch_protection_users,
            self.delete_branch_restriction_user,
            self.repos_rename_branch,
            self.checks_create,
            self.checks_get,
            self.checks_update,
            self.checks_list_annotations,
            self.checks_rerequest_run,
            self.checks_create_suite,
            self.checks_set_suites_preferences,
            self.checks_get_suite,
            self.checks_list_for_suite,
            self.checks_rerequest_suite,
            self.list_code_scanning_alerts,
            self.code_scanning_get_alert,
            self.code_scanning_update_alert,
            self.code_scanning_get_autofix,
            self.code_scanning_create_autofix,
            self.code_scanning_commit_autofix,
            self.get_alert_instances,
            self.get_repo_code_scanning_analyses,
            self.code_scanning_get_analysis,
            self.code_scanning_delete_analysis,
            self.get_code_scanning_databases,
            self.get_codeql_database_by_language,
            self.delete_codeql_database,
            self.create_codeql_analysis,
            self.get_variant_analysis,
            self.get_codeql_variant_analysis,
            self.get_code_scanning_setup,
            self.patch_default_setup_code_scanning,
            self.code_scanning_upload_sarif,
            self.code_scanning_get_sarif,
            self.get_code_security_config,
            self.repos_codeowners_errors,
            self.get_repo_codespaces,
            self.create_repo_codespace,
            self.get_dev_container_config,
            self.get_repo_codespaces_machines,
            self.get_new_codespace_for_repo,
            self.check_codespace_permissions,
            self.codespaces_list_repo_secrets,
            self.codespaces_get_repo_public_key,
            self.codespaces_get_repo_secret,
            self.update_codespace_secret,
            self.codespaces_delete_repo_secret,
            self.repos_list_collaborators,
            self.repos_check_collaborator,
            self.repos_add_collaborator,
            self.repos_remove_collaborator,
            self.get_repo_collaborator_permission,
            self.get_repo_comments,
            self.repos_get_commit_comment,
            self.repos_update_commit_comment,
            self.repos_delete_commit_comment,
            self.get_repo_comment_reactions,
            self.create_reaction,
            self.delete_repo_comment_reaction_by_id,
            self.repos_list_commits,
            self.get_branches_by_commit,
            self.repos_list_comments_for_commit,
            self.repos_create_commit_comment,
            self.get_commit_pulls_by_repo_owner,
            self.repos_get_commit,
            self.checks_list_for_ref,
            self.checks_list_suites_for_ref,
            self.get_commit_status,
            self.get_commit_statuses,
            self.get_community_profile,
            self.repos_compare_commits,
            self.repos_get_content,
            self.put_repo_content_by_path,
            self.repos_delete_file,
            self.repos_list_contributors,
            self.get_dependabot_alerts_by_repo,
            self.dependabot_get_alert,
            self.dependabot_update_alert,
            self.dependabot_list_repo_secrets,
            self.dependabot_get_repo_public_key,
            self.dependabot_get_repo_secret,
            self.put_repo_dependabot_secret,
            self.dependabot_delete_repo_secret,
            self.dependency_graph_diff_range,
            self.dependency_graph_export_sbom,
            self.create_snapshot,
            self.repos_list_deployments,
            self.repos_create_deployment,
            self.repos_get_deployment,
            self.repos_delete_deployment,
            self.repos_list_deployment_statuses,
            self.repos_create_deployment_status,
            self.repos_get_deployment_status,
            self.repos_create_dispatch_event,
            self.repos_get_all_environments,
            self.repos_get_environment,
            self.update_environment,
            self.repos_delete_an_environment,
            self.get_deployment_branch_policies,
            self.create_deployment_policy,
            self.get_branch_policy,
            self.update_branch_policy,
            self.delete_branch_policy,
            self.get_deployment_rules,
            self.create_deployment_protection_rule,
            self.list_deployment_apps,
            self.get_protection_rule,
            self.delete_protection_rule,
            self.get_repo_secrets,
            self.get_public_key,
            self.actions_get_environment_secret,
            self.update_environment_secret_by_name,
            self.delete_secret,
            self.get_repo_environment_variables,
            self.create_environment_variable,
            self.get_variable_by_name,
            self.update_environment_variable,
            self.delete_variable,
            self.activity_list_repo_events,
            self.repos_list_forks,
            self.repos_create_fork,
            self.git_create_blob,
            self.git_get_blob,
            self.git_create_commit,
            self.git_get_commit,
            self.git_list_matching_refs,
            self.git_get_ref,
            self.git_create_ref,
            self.git_update_ref,
            self.git_delete_ref,
            self.git_create_tag,
            self.git_get_tag,
            self.git_create_tree,
            self.git_get_tree,
            self.repos_list_webhooks,
            self.repos_create_webhook,
            self.repos_get_webhook,
            self.repos_update_webhook,
            self.repos_delete_webhook,
            self.get_repo_hook_config_by_id,
            self.patch_repo_hook_config,
            self.repos_list_webhook_deliveries,
            self.repos_get_webhook_delivery,
            self.re_deliver_hook_delivery_attempt,
            self.repos_ping_webhook,
            self.repos_test_push_webhook,
            self.migrations_get_import_status,
            self.migrations_start_import,
            self.migrations_update_import,
            self.migrations_cancel_import,
            self.migrations_get_commit_authors,
            self.migrations_map_commit_author,
            self.migrations_get_large_files,
            self.migrations_set_lfs_preference,
            self.apps_get_repo_installation,
            self.get_repo_interaction_limits,
            self.update_repo_interaction_limits,
            self.delete_interaction_limits,
            self.repos_list_invitations,
            self.repos_update_invitation,
            self.repos_delete_invitation,
            self.issues_list_for_repo,
            self.issues_create,
            self.issues_list_comments_for_repo,
            self.issues_get_comment,
            self.issues_update_comment,
            self.issues_delete_comment,
            self.list_reactions_to_comment,
            self.post_issue_comment_reaction,
            self.delete_comment_reaction_by_id,
            self.issues_list_events_for_repo,
            self.issues_get_event,
            self.issues_get,
            self.issues_update,
            self.issues_add_assignees,
            self.issues_remove_assignees,
            self.get_assignee_to_issue,
            self.issues_list_comments,
            self.issues_create_comment,
            self.issues_list_events,
            self.issues_list_labels_on_issue,
            self.issues_add_labels,
            self.issues_set_labels,
            self.issues_remove_all_labels,
            self.issues_remove_label,
            self.issues_lock,
            self.issues_unlock,
            self.reactions_list_for_issue,
            self.reactions_create_for_issue,
            self.reactions_delete_for_issue,
            self.issues_remove_sub_issue,
            self.issues_list_sub_issues,
            self.issues_add_sub_issue,
            self.issues_reprioritize_sub_issue,
            self.get_issue_timeline,
            self.repos_list_deploy_keys,
            self.repos_create_deploy_key,
            self.repos_get_deploy_key,
            self.repos_delete_deploy_key,
            self.issues_list_labels_for_repo,
            self.issues_create_label,
            self.issues_get_label,
            self.issues_update_label,
            self.issues_delete_label,
            self.repos_list_languages,
            self.licenses_get_for_repo,
            self.repos_merge_upstream,
            self.repos_merge,
            self.issues_list_milestones,
            self.issues_create_milestone,
            self.issues_get_milestone,
            self.issues_update_milestone,
            self.issues_delete_milestone,
            self.get_milestone_labels,
            self.get_repo_notifications,
            self.update_repo_notifications,
            self.repos_get_pages,
            self.repos_create_pages_site,
            self.update_repo_pages,
            self.repos_delete_pages_site,
            self.repos_list_pages_builds,
            self.repos_request_pages_build,
            self.repos_get_latest_pages_build,
            self.repos_get_pages_build,
            self.repos_create_pages_deployment,
            self.repos_get_pages_deployment,
            self.repos_cancel_pages_deployment,
            self.repos_get_pages_health_check,
            self.get_repo_vulnerabilities,
            self.enable_private_reporting,
            self.delete_repo_vulnerability_report,
            self.projects_list_for_repo,
            self.projects_create_for_repo,
            self.get_repo_properties_values,
            self.update_repo_property_values,
            self.pulls_list,
            self.pulls_create,
            self.list_pull_comment,
            self.pulls_get_review_comment,
            self.pulls_update_review_comment,
            self.pulls_delete_review_comment,
            self.get_pull_comment_reactions,
            self.create_pull_comment_reaction,
            self.delete_reaction_to_comment,
            self.pulls_get,
            self.pulls_update,
            self.create_pull_codespace,
            self.pulls_list_review_comments,
            self.pulls_create_review_comment,
            self.create_pull_comment_reply,
            self.pulls_list_commits,
            self.pulls_list_files,
            self.pulls_check_if_merged,
            self.pulls_merge,
            self.pulls_list_requested_reviewers,
            self.pulls_request_reviewers,
            self.delete_pull_request_reviewers,
            self.pulls_list_reviews,
            self.pulls_create_review,
            self.pulls_get_review,
            self.pulls_update_review,
            self.pulls_delete_pending_review,
            self.pulls_list_comments_for_review,
            self.pulls_dismiss_review,
            self.pulls_submit_review,
            self.pulls_update_branch,
            self.repos_get_readme,
            self.repos_get_readme_in_directory,
            self.repos_list_releases,
            self.repos_create_release,
            self.repos_get_release_asset,
            self.repos_update_release_asset,
            self.repos_delete_release_asset,
            self.repos_generate_release_notes,
            self.repos_get_latest_release,
            self.repos_get_release_by_tag,
            self.repos_get_release,
            self.repos_update_release,
            self.repos_delete_release,
            self.repos_list_release_assets,
            self.repos_upload_release_asset,
            self.reactions_list_for_release,
            self.reactions_create_for_release,
            self.reactions_delete_for_release,
            self.repos_get_branch_rules,
            self.repos_get_repo_rulesets,
            self.repos_create_repo_ruleset,
            self.repos_get_repo_rule_suites,
            self.repos_get_repo_rule_suite,
            self.repos_get_repo_ruleset,
            self.repos_update_repo_ruleset,
            self.repos_delete_repo_ruleset,
            self.repos_get_repo_ruleset_history,
            self.repos_get_repo_ruleset_version,
            self.list_secret_scanning_alerts,
            self.secret_scanning_get_alert,
            self.secret_scanning_update_alert,
            self.get_secret_locations,
            self.bypass_push_protection,
            self.get_repo_secret_scanning_history,
            self.list_security_advisories,
            self.create_security_advisory,
            self.create_security_advisory_report,
            self.get_security_advisory_by_id,
            self.update_security_advisory,
            self.post_repo_security_advisory_cve,
            self.fork_security_advisory,
            self.list_stargazers,
            self.repos_get_code_frequency_stats,
            self.get_repo_commit_activity_stats,
            self.repos_get_contributors_stats,
            self.repos_get_participation_stats,
            self.repos_get_punch_card_stats,
            self.repos_create_commit_status,
            self.list_subscribers,
            self.activity_get_repo_subscription,
            self.activity_set_repo_subscription,
            self.unsubscribe_repo,
            self.repos_list_tags,
            self.repos_list_tag_protection,
            self.repos_create_tag_protection,
            self.repos_delete_tag_protection,
            self.repos_download_tarball_archive,
            self.repos_list_teams,
            self.repos_get_all_topics,
            self.repos_replace_all_topics,
            self.repos_get_clones,
            self.repos_get_top_paths,
            self.repos_get_top_referrers,
            self.repos_get_views,
            self.repos_transfer,
            self.list_vulnerability_alerts,
            self.update_vulnerability_alerts,
            self.delete_vulnerability_alerts,
            self.repos_download_zipball_archive,
            self.repos_create_using_template,
            self.repos_list_public,
            self.search_code,
            self.search_commits,
            self.search_issues,
            self.search_labels,
            self.search_repos,
            self.search_topics,
            self.search_users,
            self.teams_get_legacy,
            self.teams_update_legacy,
            self.teams_delete_legacy,
            self.teams_list_discussions_legacy,
            self.teams_create_discussion_legacy,
            self.teams_get_discussion_legacy,
            self.teams_update_discussion_legacy,
            self.teams_delete_discussion_legacy,
            self.get_discussion_comments,
            self.create_team_discussion_comment,
            self.get_comment_by_number,
            self.patch_team_discussion_comment,
            self.delete_comment,
            self.get_reaction_by_comment,
            self.add_team_comment_reaction,
            self.get_team_discussion_reactions,
            self.add_reaction_to_discussion,
            self.get_team_invitations,
            self.teams_list_members_legacy,
            self.teams_get_member_legacy,
            self.teams_add_member_legacy,
            self.teams_remove_member_legacy,
            self.get_team_membership_by_username,
            self.update_membership_for_user,
            self.delete_membership_by_user,
            self.teams_list_projects_legacy,
            self.get_team_project,
            self.update_project_details,
            self.teams_remove_project_legacy,
            self.teams_list_repos_legacy,
            self.get_team_repo_by_owner_repo,
            self.update_team_repo,
            self.teams_remove_repo_legacy,
            self.teams_list_child_legacy,
            self.users_get_authenticated,
            self.users_update_authenticated,
            self.list_user_blocks,
            self.users_check_blocked,
            self.users_block,
            self.users_unblock,
            self.list_codespaces,
            self.create_user_codespace,
            self.list_user_secrets,
            self.get_codespaces_public_key,
            self.get_secret_by_name,
            self.update_secret_code,
            self.delete_secret_by_name,
            self.get_secret_repositories,
            self.put_user_codespaces_secret_repos,
            self.update_secrets_repository,
            self.delete_secret_repo_access,
            self.get_user_codespace_by_name,
            self.update_codespace,
            self.delete_codespace,
            self.export_codespace,
            self.get_user_codespace_export_by_id,
            self.get_codespace_machines,
            self.publish_codespace,
            self.start_codespace,
            self.stop_user_codespace,
            self.get_user_docker_conflicts,
            self.update_email_visibility,
            self.list_user_emails,
            self.add_user_email,
            self.delete_emails,
            self.list_user_followers,
            self.list_following_users,
            self.get_following_user,
            self.users_follow,
            self.users_unfollow,
            self.get_gpg_keys,
            self.create_gpg_key,
            self.get_gpg_key_by_id,
            self.delete_user_gpg_key_by_id,
            self.get_user_installations,
            self.list_installation_repositories,
            self.update_repository_installation,
            self.delete_repository_installation,
            self.get_interaction_limits,
            self.update_user_interaction_limits,
            self.delete_user_interaction_limits,
            self.list_user_issues,
            self.get_keys,
            self.create_user_key,
            self.get_user_key_by_id,
            self.delete_user_key_by_id,
            self.get_user_marketplace_purchases,
            self.get_marketplace_purchases,
            self.list_org_memberships,
            self.get_user_memberships_org,
            self.update_org_membership,
            self.list_user_migrations,
            self.create_user_migration,
            self.get_migration_by_id,
            self.get_user_migration_archive,
            self.delete_user_migration_archive,
            self.delete_repo_lock,
            self.list_migration_repositories,
            self.list_user_orgs,
            self.get_packages,
            self.get_user_package_by_type_name,
            self.delete_package_by_name,
            self.restore_user_package_by_type_name,
            self.get_package_versions,
            self.get_user_package_version_by_id,
            self.delete_package_version_by_id,
            self.restore_user_package_version,
            self.create_project,
            self.get_public_emails,
            self.list_user_repos,
            self.create_user_repo,
            self.list_repository_invitations,
            self.update_invitation,
            self.delete_repository_invitation,
            self.list_social_accounts,
            self.create_social_account,
            self.delete_social_accounts,
            self.list_ssh_signing_keys,
            self.create_user_ssh_signing_key,
            self.get_ssh_signing_key,
            self.delete_user_ssh_signing_key,
            self.list_starred_users,
            self.get_user_starred_repo,
            self.star_repo_for_user,
            self.delete_starred_repo,
            self.get_user_subscriptions,
            self.list_user_teams,
            self.users_get_by_id,
            self.users_list,
            self.users_get_by_username,
            self.users_list_attestations,
            self.get_docker_conflicts_by_username,
            self.get_user_events,
            self.get_org_events_by_user,
            self.get_public_events_by_user,
            self.users_list_followers_for_user,
            self.users_list_following_for_user,
            self.users_check_following_for_user,
            self.gists_list_for_user,
            self.users_list_gpg_keys_for_user,
            self.users_get_context_for_user,
            self.apps_get_user_installation,
            self.get_user_keys,
            self.orgs_list_for_user,
            self.get_packages_by_user,
            self.packages_get_package_for_user,
            self.delete_package_by_user,
            self.restore_user_package,
            self.get_user_package_versions,
            self.get_package_version_details,
            self.delete_user_package_version,
            self.restore_package_version,
            self.projects_list_for_user,
            self.get_received_events_for_user,
            self.get_user_public_received_events,
            self.repos_list_for_user,
            self.get_billing_actions_by_user,
            self.get_user_billing_packages,
            self.get_shared_storage_settings,
            self.get_billing_usage,
            self.get_social_accounts_by_user,
            self.list_user_ssh_signing_keys,
            self.get_user_starred_repositories,
            self.list_user_subscriptions,
            self.meta_get_all_versions,
            self.meta_get_zen
        ]
